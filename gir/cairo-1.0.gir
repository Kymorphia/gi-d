<?xml version="1.0"?>
<!-- This file was automatically generated from C sources - DO NOT EDIT!
To affect the contents of this file, edit the original C definitions,
and/or use gtk-doc annotations.  -->
<repository version="1.2"
            xmlns="http://www.gtk.org/introspection/core/1.0"
            xmlns:c="http://www.gtk.org/introspection/c/1.0"
            xmlns:glib="http://www.gtk.org/introspection/glib/1.0">
  <include name="GObject" version="2.0"/>
  <include name="freetype2" version="2.0"/>
  <namespace name="cairo"
             version="1.0"
             shared-library="libcairo-gobject.so.2"
             c:identifier-prefixes="cairo_,Cairo"
             c:symbol-prefixes="cairo,cairo_gobject">
    <alias name="Bool" c:type="cairo_bool_t">
      <doc xml:space="preserve"
           filename="cairo.h"
           line="102">#cairo_bool_t is used for boolean values. Returns of type
#cairo_bool_t will always be either 0 or 1, but testing against
these values explicitly is not encouraged; just use the
value as a boolean condition.

&lt;informalexample&gt;&lt;programlisting&gt;
 if (cairo_in_stroke (cr, x, y)) {
     /&lt;!-- --&gt;* do something *&lt;!-- --&gt;/
 }
&lt;/programlisting&gt;&lt;/informalexample&gt;</doc>
      <source-position filename="cairo.h" line="118"/>
      <type name="gint" c:type="int"/>
    </alias>
    <enumeration name="Antialias"
                 version="1.0"
                 glib:type-name="cairo_antialias_t"
                 glib:get-type="cairo_gobject_antialias_get_type"
                 c:type="cairo_antialias_t">
      <doc xml:space="preserve"
           filename="cairo.h"
           line="721">Specifies the type of antialiasing to do when rendering text or shapes.

These make no guarantee on how the backend will perform its rasterisation
(if it even rasterises!), nor that they have any differing effect other
than to enable some form of antialiasing. In the case of glyph rendering,
@CAIRO_ANTIALIAS_FAST and @CAIRO_ANTIALIAS_GOOD will be mapped to
@CAIRO_ANTIALIAS_GRAY, with @CAIRO_ANTALIAS_BEST being equivalent to
@CAIRO_ANTIALIAS_SUBPIXEL.

The interpretation of @CAIRO_ANTIALIAS_DEFAULT is left entirely up to
the backend, typically this will be similar to @CAIRO_ANTIALIAS_GOOD.</doc>
      <member name="default"
              value="0"
              c:identifier="CAIRO_ANTIALIAS_DEFAULT"
              glib:nick="default"
              glib:name="CAIRO_ANTIALIAS_DEFAULT">
        <doc xml:space="preserve"
             filename="cairo.h"
             line="723">Use the default antialiasing for
  the subsystem and target device, since 1.0</doc>
      </member>
      <member name="none"
              value="1"
              c:identifier="CAIRO_ANTIALIAS_NONE"
              glib:nick="none"
              glib:name="CAIRO_ANTIALIAS_NONE">
        <doc xml:space="preserve"
             filename="cairo.h"
             line="725">Use a bilevel alpha mask, since 1.0</doc>
      </member>
      <member name="gray"
              value="2"
              c:identifier="CAIRO_ANTIALIAS_GRAY"
              glib:nick="gray"
              glib:name="CAIRO_ANTIALIAS_GRAY">
        <doc xml:space="preserve"
             filename="cairo.h"
             line="726">Perform single-color antialiasing (using
 shades of gray for black text on a white background, for example), since 1.0</doc>
      </member>
      <member name="subpixel"
              value="3"
              c:identifier="CAIRO_ANTIALIAS_SUBPIXEL"
              glib:nick="subpixel"
              glib:name="CAIRO_ANTIALIAS_SUBPIXEL">
        <doc xml:space="preserve"
             filename="cairo.h"
             line="728">Perform antialiasing by taking
 advantage of the order of subpixel elements on devices
 such as LCD panels, since 1.0</doc>
      </member>
      <member name="fast"
              value="4"
              c:identifier="CAIRO_ANTIALIAS_FAST"
              glib:nick="fast"
              glib:name="CAIRO_ANTIALIAS_FAST">
        <doc xml:space="preserve"
             filename="cairo.h"
             line="731">Hint that the backend should perform some
antialiasing but prefer speed over quality, since 1.12</doc>
      </member>
      <member name="good"
              value="5"
              c:identifier="CAIRO_ANTIALIAS_GOOD"
              glib:nick="good"
              glib:name="CAIRO_ANTIALIAS_GOOD">
        <doc xml:space="preserve"
             filename="cairo.h"
             line="733">The backend should balance quality against
performance, since 1.12</doc>
      </member>
      <member name="best"
              value="6"
              c:identifier="CAIRO_ANTIALIAS_BEST"
              glib:nick="best"
              glib:name="CAIRO_ANTIALIAS_BEST">
        <doc xml:space="preserve"
             filename="cairo.h"
             line="735">Hint that the backend should render at the highest
quality, sacrificing speed if necessary, since 1.12</doc>
      </member>
    </enumeration>
    <constant name="COLOR_PALETTE_DEFAULT"
              value="0"
              c:type="CAIRO_COLOR_PALETTE_DEFAULT"
              version="1.18">
      <doc xml:space="preserve"
           filename="cairo-font-options.c"
           line="730">The default color palette index.</doc>
      <source-position filename="cairo.h" line="1505"/>
      <type name="gint" c:type="gint"/>
    </constant>
    <enumeration name="ColorMode" version="1.18" c:type="cairo_color_mode_t">
      <doc xml:space="preserve"
           filename="cairo.h"
           line="1411">Specifies if color fonts are to be rendered using the color
glyphs or outline glyphs. Glyphs that do not have a color
presentation, and non-color fonts are not affected by this font
option.</doc>
      <source-position filename="cairo.h" line="1432"/>
      <member name="default" value="0" c:identifier="CAIRO_COLOR_MODE_DEFAULT">
        <doc xml:space="preserve"
             filename="cairo.h"
             line="1413">Use the default color mode for
font backend and target device, since 1.18.</doc>
      </member>
      <member name="no_color"
              value="1"
              c:identifier="CAIRO_COLOR_MODE_NO_COLOR">
        <doc xml:space="preserve"
             filename="cairo.h"
             line="1415">Disable rendering color glyphs. Glyphs are
always rendered as outline glyphs, since 1.18.</doc>
      </member>
      <member name="color" value="2" c:identifier="CAIRO_COLOR_MODE_COLOR">
        <doc xml:space="preserve"
             filename="cairo.h"
             line="1417">Enable rendering color glyphs. If the font
contains a color presentation for a glyph, and when supported by
the font backend, the glyph will be rendered in color, since 1.18.</doc>
      </member>
    </enumeration>
    <enumeration name="Content"
                 version="1.0"
                 glib:type-name="cairo_content_t"
                 glib:get-type="cairo_gobject_content_get_type"
                 c:type="cairo_content_t">
      <doc xml:space="preserve"
           filename="cairo.h"
           line="376">#cairo_content_t is used to describe the content that a surface will
contain, whether color information, alpha information (translucence
vs. opacity), or both.

Note: The large values here are designed to keep #cairo_content_t
values distinct from #cairo_format_t values so that the
implementation can detect the error if users confuse the two types.</doc>
      <member name="color"
              value="4096"
              c:identifier="CAIRO_CONTENT_COLOR"
              glib:nick="color"
              glib:name="CAIRO_CONTENT_COLOR">
        <doc xml:space="preserve"
             filename="cairo.h"
             line="378">The surface will hold color content only. (Since 1.0)</doc>
      </member>
      <member name="alpha"
              value="8192"
              c:identifier="CAIRO_CONTENT_ALPHA"
              glib:nick="alpha"
              glib:name="CAIRO_CONTENT_ALPHA">
        <doc xml:space="preserve"
             filename="cairo.h"
             line="379">The surface will hold alpha content only. (Since 1.0)</doc>
      </member>
      <member name="color_alpha"
              value="12288"
              c:identifier="CAIRO_CONTENT_COLOR_ALPHA"
              glib:nick="color-alpha"
              glib:name="CAIRO_CONTENT_COLOR_ALPHA">
        <doc xml:space="preserve"
             filename="cairo.h"
             line="380">The surface will hold color and alpha content. (Since 1.0)</doc>
      </member>
    </enumeration>
    <record name="Context"
            c:type="cairo_t"
            opaque="1"
            version="1.0"
            glib:type-name="cairo_t"
            glib:get-type="cairo_gobject_context_get_type"
            c:symbol-prefix="gobject_context">
      <doc xml:space="preserve"
           filename="cairo.h"
           line="120">A #cairo_t contains the current state of the rendering device,
including coordinates of yet to be drawn shapes.

Cairo contexts, as #cairo_t objects are named, are central to
cairo and all drawing with cairo is always done to a #cairo_t
object.

Memory management of #cairo_t is done with
cairo_reference() and cairo_destroy().</doc>
      <source-position filename="cairo.h" line="135"/>
      <method name="append_path"
              c:identifier="cairo_append_path"
              version="1.0">
        <doc xml:space="preserve"
             filename="cairo.c"
             line="4307">Append the @path onto the current path. The @path may be either the
return value from one of cairo_copy_path() or
cairo_copy_path_flat() or it may be constructed manually.  See
#cairo_path_t for details on how the path data structure should be
initialized, and note that &lt;literal&gt;path-&gt;status&lt;/literal&gt; must be
initialized to %CAIRO_STATUS_SUCCESS.</doc>
        <source-position filename="cairo.h" line="2252"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="cr" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo.c"
                 line="4309">a cairo context</doc>
            <type name="Context" c:type="cairo_t*"/>
          </instance-parameter>
          <parameter name="path" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo.c"
                 line="4310">path to be appended</doc>
            <type name="Path" c:type="const cairo_path_t*"/>
          </parameter>
        </parameters>
      </method>
      <method name="arc" c:identifier="cairo_arc" version="1.0">
        <doc xml:space="preserve"
             filename="cairo.c"
             line="1802">Adds a circular arc of the given @radius to the current path.  The
arc is centered at (@xc, @yc), begins at @angle1 and proceeds in
the direction of increasing angles to end at @angle2. If @angle2 is
less than @angle1 it will be progressively increased by
&lt;literal&gt;2*M_PI&lt;/literal&gt; until it is greater than @angle1.

If there is a current point, an initial line segment will be added
to the path to connect the current point to the beginning of the
arc. If this initial line is undesired, it can be avoided by
calling cairo_new_sub_path() before calling cairo_arc().

Angles are measured in radians. An angle of 0.0 is in the direction
of the positive X axis (in user space). An angle of
&lt;literal&gt;M_PI/2.0&lt;/literal&gt; radians (90 degrees) is in the
direction of the positive Y axis (in user space). Angles increase
in the direction from the positive X axis toward the positive Y
axis. So with the default transformation matrix, angles increase in
a clockwise direction.

(To convert from degrees to radians, use &lt;literal&gt;degrees * (M_PI /
180.)&lt;/literal&gt;.)

This function gives the arc in the direction of increasing angles;
see cairo_arc_negative() to get the arc in the direction of
decreasing angles.

The arc is circular in user space. To achieve an elliptical arc,
you can scale the current transformation matrix by different
amounts in the X and Y directions. For example, to draw an ellipse
in the box given by @x, @y, @width, @height:

&lt;informalexample&gt;&lt;programlisting&gt;
cairo_save (cr);
cairo_translate (cr, x + width / 2., y + height / 2.);
cairo_scale (cr, width / 2., height / 2.);
cairo_arc (cr, 0., 0., 1., 0., 2 * M_PI);
cairo_restore (cr);
&lt;/programlisting&gt;&lt;/informalexample&gt;</doc>
        <source-position filename="cairo.h" line="916"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="cr" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo.c"
                 line="1804">a cairo context</doc>
            <type name="Context" c:type="cairo_t*"/>
          </instance-parameter>
          <parameter name="xc" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo.c"
                 line="1805">X position of the center of the arc</doc>
            <type name="gdouble" c:type="double"/>
          </parameter>
          <parameter name="yc" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo.c"
                 line="1806">Y position of the center of the arc</doc>
            <type name="gdouble" c:type="double"/>
          </parameter>
          <parameter name="radius" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo.c"
                 line="1807">the radius of the arc</doc>
            <type name="gdouble" c:type="double"/>
          </parameter>
          <parameter name="angle1" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo.c"
                 line="1808">the start angle, in radians</doc>
            <type name="gdouble" c:type="double"/>
          </parameter>
          <parameter name="angle2" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo.c"
                 line="1809">the end angle, in radians</doc>
            <type name="gdouble" c:type="double"/>
          </parameter>
        </parameters>
      </method>
      <method name="arc_negative"
              c:identifier="cairo_arc_negative"
              version="1.0">
        <doc xml:space="preserve"
             filename="cairo.c"
             line="1877">Adds a circular arc of the given @radius to the current path.  The
arc is centered at (@xc, @yc), begins at @angle1 and proceeds in
the direction of decreasing angles to end at @angle2. If @angle2 is
greater than @angle1 it will be progressively decreased by
&lt;literal&gt;2*M_PI&lt;/literal&gt; until it is less than @angle1.

See cairo_arc() for more details. This function differs only in the
direction of the arc between the two angles.</doc>
        <source-position filename="cairo.h" line="922"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="cr" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo.c"
                 line="1879">a cairo context</doc>
            <type name="Context" c:type="cairo_t*"/>
          </instance-parameter>
          <parameter name="xc" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo.c"
                 line="1880">X position of the center of the arc</doc>
            <type name="gdouble" c:type="double"/>
          </parameter>
          <parameter name="yc" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo.c"
                 line="1881">Y position of the center of the arc</doc>
            <type name="gdouble" c:type="double"/>
          </parameter>
          <parameter name="radius" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo.c"
                 line="1882">the radius of the arc</doc>
            <type name="gdouble" c:type="double"/>
          </parameter>
          <parameter name="angle1" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo.c"
                 line="1883">the start angle, in radians</doc>
            <type name="gdouble" c:type="double"/>
          </parameter>
          <parameter name="angle2" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo.c"
                 line="1884">the end angle, in radians</doc>
            <type name="gdouble" c:type="double"/>
          </parameter>
        </parameters>
      </method>
      <method name="clip" c:identifier="cairo_clip" version="1.0">
        <doc xml:space="preserve"
             filename="cairo.c"
             line="2686">Establishes a new clip region by intersecting the current clip
region with the current path as it would be filled by cairo_fill()
and according to the current fill rule (see cairo_set_fill_rule()).

After cairo_clip(), the current path will be cleared from the cairo
context.

The current clip region affects all drawing operations by
effectively masking out any changes to the surface that are outside
the current clip region.

Calling cairo_clip() can only make the clip region smaller, never
larger. But the current clip is part of the graphics state, so a
temporary restriction of the clip region can be achieved by
calling cairo_clip() within a cairo_save()/cairo_restore()
pair. The only other means of increasing the size of the clip
region is cairo_reset_clip().</doc>
        <source-position filename="cairo.h" line="1027"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="cr" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo.c"
                 line="2688">a cairo context</doc>
            <type name="Context" c:type="cairo_t*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="clip_extents"
              c:identifier="cairo_clip_extents"
              version="1.4">
        <doc xml:space="preserve"
             filename="cairo.c"
             line="2791">Computes a bounding box in user coordinates covering the area inside the
current clip.</doc>
        <source-position filename="cairo.h" line="1033"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="cr" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo.c"
                 line="2793">a cairo context</doc>
            <type name="Context" c:type="cairo_t*"/>
          </instance-parameter>
          <parameter name="x1" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo.c"
                 line="2794">left of the resulting extents</doc>
            <type name="gdouble" c:type="double*"/>
          </parameter>
          <parameter name="y1" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo.c"
                 line="2795">top of the resulting extents</doc>
            <type name="gdouble" c:type="double*"/>
          </parameter>
          <parameter name="x2" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo.c"
                 line="2796">right of the resulting extents</doc>
            <type name="gdouble" c:type="double*"/>
          </parameter>
          <parameter name="y2" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo.c"
                 line="2797">bottom of the resulting extents</doc>
            <type name="gdouble" c:type="double*"/>
          </parameter>
        </parameters>
      </method>
      <method name="clip_preserve"
              c:identifier="cairo_clip_preserve"
              version="1.0">
        <doc xml:space="preserve"
             filename="cairo.c"
             line="2723">Establishes a new clip region by intersecting the current clip
region with the current path as it would be filled by cairo_fill()
and according to the current fill rule (see cairo_set_fill_rule()).

Unlike cairo_clip(), cairo_clip_preserve() preserves the path within
the cairo context.

The current clip region affects all drawing operations by
effectively masking out any changes to the surface that are outside
the current clip region.

Calling cairo_clip_preserve() can only make the clip region smaller, never
larger. But the current clip is part of the graphics state, so a
temporary restriction of the clip region can be achieved by
calling cairo_clip_preserve() within a cairo_save()/cairo_restore()
pair. The only other means of increasing the size of the clip
region is cairo_reset_clip().</doc>
        <source-position filename="cairo.h" line="1030"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="cr" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo.c"
                 line="2725">a cairo context</doc>
            <type name="Context" c:type="cairo_t*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="close_path" c:identifier="cairo_close_path" version="1.0">
        <doc xml:space="preserve"
             filename="cairo.c"
             line="2121">Adds a line segment to the path from the current point to the
beginning of the current sub-path, (the most recent point passed to
cairo_move_to()), and closes this sub-path. After this call the
current point will be at the joined endpoint of the sub-path.

The behavior of cairo_close_path() is distinct from simply calling
cairo_line_to() with the equivalent coordinate in the case of
stroking. When a closed sub-path is stroked, there are no caps on
the ends of the sub-path. Instead, there is a line join connecting
the final and initial segments of the sub-path.

If there is no current point before the call to cairo_close_path(),
this function will have no effect.

Note: As of cairo version 1.2.4 any call to cairo_close_path() will
place an explicit MOVE_TO element into the path immediately after
the CLOSE_PATH element, (which can be seen in cairo_copy_path() for
example). This can simplify path processing in some cases as it may
not be necessary to save the "last move_to point" during processing
as the MOVE_TO immediately after the CLOSE_PATH will provide that
point.</doc>
        <source-position filename="cairo.h" line="958"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="cr" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo.c"
                 line="2123">a cairo context</doc>
            <type name="Context" c:type="cairo_t*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="copy_clip_rectangle_list"
              c:identifier="cairo_copy_clip_rectangle_list"
              version="1.4">
        <doc xml:space="preserve"
             filename="cairo.c"
             line="2861">Gets the current clip region as a list of rectangles in user coordinates.
Never returns %NULL.

The status in the list may be %CAIRO_STATUS_CLIP_NOT_REPRESENTABLE to
indicate that the clip region cannot be represented as a list of
user-space rectangles. The status may have other values to indicate
other errors.</doc>
        <source-position filename="cairo.h" line="1070"/>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve"
               filename="cairo.c"
               line="2873">the current clip region as a list of rectangles in user coordinates,
which should be destroyed using cairo_rectangle_list_destroy().</doc>
          <type name="RectangleList" c:type="cairo_rectangle_list_t*"/>
        </return-value>
        <parameters>
          <instance-parameter name="cr" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo.c"
                 line="2863">a cairo context</doc>
            <type name="Context" c:type="cairo_t*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="copy_page" c:identifier="cairo_copy_page" version="1.0">
        <doc xml:space="preserve"
             filename="cairo.c"
             line="2459">Emits the current page for backends that support multiple pages, but
doesn't clear it, so, the contents of the current page will be retained
for the next page too.  Use cairo_show_page() if you want to get an
empty page after the emission.

This is a convenience function that simply calls
cairo_surface_copy_page() on @cr's target.</doc>
        <source-position filename="cairo.h" line="996"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="cr" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo.c"
                 line="2461">a cairo context</doc>
            <type name="Context" c:type="cairo_t*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="copy_path" c:identifier="cairo_copy_path" version="1.0">
        <doc xml:space="preserve"
             filename="cairo.c"
             line="4226">Creates a copy of the current path and returns it to the user as a
#cairo_path_t. See #cairo_path_data_t for hints on how to iterate
over the returned data structure.

This function will always return a valid pointer, but the result
will have no data (&lt;literal&gt;data==%NULL&lt;/literal&gt; and
&lt;literal&gt;num_data==0&lt;/literal&gt;), if either of the following
conditions hold:

&lt;orderedlist&gt;
&lt;listitem&gt;If there is insufficient memory to copy the path. In this
    case &lt;literal&gt;path-&gt;status&lt;/literal&gt; will be set to
    %CAIRO_STATUS_NO_MEMORY.&lt;/listitem&gt;
&lt;listitem&gt;If @cr is already in an error state. In this case
   &lt;literal&gt;path-&gt;status&lt;/literal&gt; will contain the same status that
   would be returned by cairo_status().&lt;/listitem&gt;
&lt;/orderedlist&gt;</doc>
        <source-position filename="cairo.h" line="2246"/>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve"
               filename="cairo.c"
               line="4248">the copy of the current path. The caller owns the
returned object and should call cairo_path_destroy() when finished
with it.</doc>
          <type name="Path" c:type="cairo_path_t*"/>
        </return-value>
        <parameters>
          <instance-parameter name="cr" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo.c"
                 line="4228">a cairo context</doc>
            <type name="Context" c:type="cairo_t*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="copy_path_flat"
              c:identifier="cairo_copy_path_flat"
              version="1.0">
        <doc xml:space="preserve"
             filename="cairo.c"
             line="4263">Gets a flattened copy of the current path and returns it to the
user as a #cairo_path_t. See #cairo_path_data_t for hints on
how to iterate over the returned data structure.

This function is like cairo_copy_path() except that any curves
in the path will be approximated with piecewise-linear
approximations, (accurate to within the current tolerance
value). That is, the result is guaranteed to not have any elements
of type %CAIRO_PATH_CURVE_TO which will instead be replaced by a
series of %CAIRO_PATH_LINE_TO elements.

This function will always return a valid pointer, but the result
will have no data (&lt;literal&gt;data==%NULL&lt;/literal&gt; and
&lt;literal&gt;num_data==0&lt;/literal&gt;), if either of the following
conditions hold:

&lt;orderedlist&gt;
&lt;listitem&gt;If there is insufficient memory to copy the path. In this
    case &lt;literal&gt;path-&gt;status&lt;/literal&gt; will be set to
    %CAIRO_STATUS_NO_MEMORY.&lt;/listitem&gt;
&lt;listitem&gt;If @cr is already in an error state. In this case
   &lt;literal&gt;path-&gt;status&lt;/literal&gt; will contain the same status that
   would be returned by cairo_status().&lt;/listitem&gt;
&lt;/orderedlist&gt;</doc>
        <source-position filename="cairo.h" line="2249"/>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve"
               filename="cairo.c"
               line="4292">the copy of the current path. The caller owns the
returned object and should call cairo_path_destroy() when finished
with it.</doc>
          <type name="Path" c:type="cairo_path_t*"/>
        </return-value>
        <parameters>
          <instance-parameter name="cr" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo.c"
                 line="4265">a cairo context</doc>
            <type name="Context" c:type="cairo_t*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="curve_to" c:identifier="cairo_curve_to" version="1.0">
        <doc xml:space="preserve"
             filename="cairo.c"
             line="1762">Adds a cubic Bézier spline to the path from the current point to
position (@x3, @y3) in user-space coordinates, using (@x1, @y1) and
(@x2, @y2) as the control points. After this call the current point
will be (@x3, @y3).

If there is no current point before the call to cairo_curve_to()
this function will behave as if preceded by a call to
cairo_move_to(@cr, @x1, @y1).</doc>
        <source-position filename="cairo.h" line="910"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="cr" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo.c"
                 line="1764">a cairo context</doc>
            <type name="Context" c:type="cairo_t*"/>
          </instance-parameter>
          <parameter name="x1" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo.c"
                 line="1765">the X coordinate of the first control point</doc>
            <type name="gdouble" c:type="double"/>
          </parameter>
          <parameter name="y1" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo.c"
                 line="1766">the Y coordinate of the first control point</doc>
            <type name="gdouble" c:type="double"/>
          </parameter>
          <parameter name="x2" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo.c"
                 line="1767">the X coordinate of the second control point</doc>
            <type name="gdouble" c:type="double"/>
          </parameter>
          <parameter name="y2" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo.c"
                 line="1768">the Y coordinate of the second control point</doc>
            <type name="gdouble" c:type="double"/>
          </parameter>
          <parameter name="x3" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo.c"
                 line="1769">the X coordinate of the end of the curve</doc>
            <type name="gdouble" c:type="double"/>
          </parameter>
          <parameter name="y3" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo.c"
                 line="1770">the Y coordinate of the end of the curve</doc>
            <type name="gdouble" c:type="double"/>
          </parameter>
        </parameters>
      </method>
      <method name="device_to_user"
              c:identifier="cairo_device_to_user"
              version="1.0">
        <doc xml:space="preserve"
             filename="cairo.c"
             line="1614">Transform a coordinate from device space to user space by
multiplying the given point by the inverse of the current
transformation matrix (CTM).</doc>
        <source-position filename="cairo.h" line="891"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="cr" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo.c"
                 line="1616">a cairo</doc>
            <type name="Context" c:type="cairo_t*"/>
          </instance-parameter>
          <parameter name="x" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo.c"
                 line="1617">X value of coordinate (in/out parameter)</doc>
            <type name="gdouble" c:type="double*"/>
          </parameter>
          <parameter name="y" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo.c"
                 line="1618">Y value of coordinate (in/out parameter)</doc>
            <type name="gdouble" c:type="double*"/>
          </parameter>
        </parameters>
      </method>
      <method name="device_to_user_distance"
              c:identifier="cairo_device_to_user_distance"
              version="1.0">
        <doc xml:space="preserve"
             filename="cairo.c"
             line="1635">Transform a distance vector from device space to user space. This
function is similar to cairo_device_to_user() except that the
translation components of the inverse CTM will be ignored when
transforming (@dx,@dy).</doc>
        <source-position filename="cairo.h" line="894"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="cr" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo.c"
                 line="1637">a cairo context</doc>
            <type name="Context" c:type="cairo_t*"/>
          </instance-parameter>
          <parameter name="dx" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo.c"
                 line="1638">X component of a distance vector (in/out parameter)</doc>
            <type name="gdouble" c:type="double*"/>
          </parameter>
          <parameter name="dy" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo.c"
                 line="1639">Y component of a distance vector (in/out parameter)</doc>
            <type name="gdouble" c:type="double*"/>
          </parameter>
        </parameters>
      </method>
      <method name="fill" c:identifier="cairo_fill" version="1.0">
        <doc xml:space="preserve"
             filename="cairo.c"
             line="2408">A drawing operator that fills the current path according to the
current fill rule, (each sub-path is implicitly closed before being
filled). After cairo_fill(), the current path will be cleared from
the cairo context. See cairo_set_fill_rule() and
cairo_fill_preserve().</doc>
        <source-position filename="cairo.h" line="990"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="cr" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo.c"
                 line="2410">a cairo context</doc>
            <type name="Context" c:type="cairo_t*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="fill_extents"
              c:identifier="cairo_fill_extents"
              version="1.0">
        <doc xml:space="preserve"
             filename="cairo.c"
             line="2635">Computes a bounding box in user coordinates covering the area that
would be affected, (the "inked" area), by a cairo_fill() operation
given the current path and fill parameters. If the current path is
empty, returns an empty rectangle ((0,0), (0,0)). Surface
dimensions and clipping are not taken into account.

Contrast with cairo_path_extents(), which is similar, but returns
non-zero extents for some paths with no inked area, (such as a
simple line segment).

Note that cairo_fill_extents() must necessarily do more work to
compute the precise inked areas in light of the fill rule, so
cairo_path_extents() may be more desirable for sake of performance
if the non-inked path extents are desired.

See cairo_fill(), cairo_set_fill_rule() and cairo_fill_preserve().</doc>
        <source-position filename="cairo.h" line="1018"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="cr" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo.c"
                 line="2637">a cairo context</doc>
            <type name="Context" c:type="cairo_t*"/>
          </instance-parameter>
          <parameter name="x1" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo.c"
                 line="2638">left of the resulting extents</doc>
            <type name="gdouble" c:type="double*"/>
          </parameter>
          <parameter name="y1" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo.c"
                 line="2639">top of the resulting extents</doc>
            <type name="gdouble" c:type="double*"/>
          </parameter>
          <parameter name="x2" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo.c"
                 line="2640">right of the resulting extents</doc>
            <type name="gdouble" c:type="double*"/>
          </parameter>
          <parameter name="y2" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo.c"
                 line="2641">bottom of the resulting extents</doc>
            <type name="gdouble" c:type="double*"/>
          </parameter>
        </parameters>
      </method>
      <method name="fill_preserve"
              c:identifier="cairo_fill_preserve"
              version="1.0">
        <doc xml:space="preserve"
             filename="cairo.c"
             line="2433">A drawing operator that fills the current path according to the
current fill rule, (each sub-path is implicitly closed before being
filled). Unlike cairo_fill(), cairo_fill_preserve() preserves the
path within the cairo context.

See cairo_set_fill_rule() and cairo_fill().</doc>
        <source-position filename="cairo.h" line="993"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="cr" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo.c"
                 line="2435">a cairo context</doc>
            <type name="Context" c:type="cairo_t*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="font_extents"
              c:identifier="cairo_font_extents"
              version="1.0">
        <doc xml:space="preserve"
             filename="cairo.c"
             line="3075">Gets the font extents for the currently selected font.</doc>
        <source-position filename="cairo.h" line="1614"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="cr" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo.c"
                 line="3077">a #cairo_t</doc>
            <type name="Context" c:type="cairo_t*"/>
          </instance-parameter>
          <parameter name="extents" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo.c"
                 line="3078">a #cairo_font_extents_t object into which the results
will be stored.</doc>
            <type name="FontExtents" c:type="cairo_font_extents_t*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_antialias"
              c:identifier="cairo_get_antialias"
              version="1.0">
        <doc xml:space="preserve"
             filename="cairo.c"
             line="3943">Gets the current shape antialiasing mode, as set by
cairo_set_antialias().</doc>
        <source-position filename="cairo.h" line="2078"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cairo.c"
               line="3950">the current shape antialiasing mode.</doc>
          <type name="Antialias" c:type="cairo_antialias_t"/>
        </return-value>
        <parameters>
          <instance-parameter name="cr" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo.c"
                 line="3945">a cairo context</doc>
            <type name="Context" c:type="cairo_t*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_current_point"
              c:identifier="cairo_get_current_point"
              version="1.0">
        <doc xml:space="preserve"
             filename="cairo.c"
             line="3983">Gets the current point of the current path, which is
conceptually the final point reached by the path so far.

The current point is returned in the user-space coordinate
system. If there is no defined current point or if @cr is in an
error status, @x and @y will both be set to 0.0. It is possible to
check this in advance with cairo_has_current_point().

Most path construction functions alter the current point. See the
following for details on how they affect the current point:
cairo_new_path(), cairo_new_sub_path(),
cairo_append_path(), cairo_close_path(),
cairo_move_to(), cairo_line_to(), cairo_curve_to(),
cairo_rel_move_to(), cairo_rel_line_to(), cairo_rel_curve_to(),
cairo_arc(), cairo_arc_negative(), cairo_rectangle(),
cairo_text_path(), cairo_glyph_path().

Some functions use and alter the current point but do not
otherwise change current path:
cairo_show_text().

Some functions unset the current path and as a result, current point:
cairo_fill(), cairo_stroke().</doc>
        <source-position filename="cairo.h" line="2084"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="cr" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo.c"
                 line="3985">a cairo context</doc>
            <type name="Context" c:type="cairo_t*"/>
          </instance-parameter>
          <parameter name="x" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo.c"
                 line="3986">return value for X coordinate of the current point</doc>
            <type name="gdouble" c:type="double*"/>
          </parameter>
          <parameter name="y" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo.c"
                 line="3987">return value for Y coordinate of the current point</doc>
            <type name="gdouble" c:type="double*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_dash" c:identifier="cairo_get_dash" version="1.4">
        <doc xml:space="preserve"
             filename="cairo.c"
             line="1353">Gets the current dash array.  If not %NULL, @dashes should be big
enough to hold at least the number of values returned by
cairo_get_dash_count().</doc>
        <source-position filename="cairo.h" line="2108"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="cr" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo.c"
                 line="1355">a #cairo_t</doc>
            <type name="Context" c:type="cairo_t*"/>
          </instance-parameter>
          <parameter name="dashes" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo.c"
                 line="1356">return value for the dash array, or %NULL</doc>
            <type name="gdouble" c:type="double*"/>
          </parameter>
          <parameter name="offset" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo.c"
                 line="1357">return value for the current dash offset, or %NULL</doc>
            <type name="gdouble" c:type="double*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_dash_count"
              c:identifier="cairo_get_dash_count"
              version="1.4">
        <doc xml:space="preserve"
             filename="cairo.c"
             line="1327">This function returns the length of the dash array in @cr (0 if dashing
is not currently in effect).

See also cairo_set_dash() and cairo_get_dash().</doc>
        <source-position filename="cairo.h" line="2105"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cairo.c"
               line="1336">the length of the dash array, or 0 if no dash array set.</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="cr" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo.c"
                 line="1329">a #cairo_t</doc>
            <type name="Context" c:type="cairo_t*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_fill_rule"
              c:identifier="cairo_get_fill_rule"
              version="1.0">
        <doc xml:space="preserve"
             filename="cairo.c"
             line="4033">Gets the current fill rule, as set by cairo_set_fill_rule().</doc>
        <source-position filename="cairo.h" line="2087"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cairo.c"
               line="4039">the current fill rule.</doc>
          <type name="FillRule" c:type="cairo_fill_rule_t"/>
        </return-value>
        <parameters>
          <instance-parameter name="cr" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo.c"
                 line="4035">a cairo context</doc>
            <type name="Context" c:type="cairo_t*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_font_face"
              c:identifier="cairo_get_font_face"
              version="1.0">
        <doc xml:space="preserve"
             filename="cairo.c"
             line="3130">Gets the current font face for a #cairo_t.</doc>
        <source-position filename="cairo.h" line="1571"/>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve"
               filename="cairo.c"
               line="3136">the current font face.  This object is owned by
cairo. To keep a reference to it, you must call
cairo_font_face_reference().

This function never returns %NULL. If memory cannot be allocated, a
special "nil" #cairo_font_face_t object will be returned on which
cairo_font_face_status() returns %CAIRO_STATUS_NO_MEMORY. Using
this nil object will cause its error state to propagate to other
objects it is passed to, (for example, calling
cairo_set_font_face() with a nil font will trigger an error that
will shutdown the #cairo_t object).</doc>
          <type name="FontFace" c:type="cairo_font_face_t*"/>
        </return-value>
        <parameters>
          <instance-parameter name="cr" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo.c"
                 line="3132">a #cairo_t</doc>
            <type name="Context" c:type="cairo_t*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_font_matrix"
              c:identifier="cairo_get_font_matrix"
              version="1.0">
        <doc xml:space="preserve"
             filename="cairo.c"
             line="3218">Stores the current font matrix into @matrix. See
cairo_set_font_matrix().</doc>
        <source-position filename="cairo.h" line="1556"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="cr" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo.c"
                 line="3220">a #cairo_t</doc>
            <type name="Context" c:type="cairo_t*"/>
          </instance-parameter>
          <parameter name="matrix" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo.c"
                 line="3221">return value for the matrix</doc>
            <type name="Matrix" c:type="cairo_matrix_t*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_font_options"
              c:identifier="cairo_get_font_options"
              version="1.0">
        <doc xml:space="preserve"
             filename="cairo.c"
             line="3272">Retrieves font rendering options set via #cairo_set_font_options.
Note that the returned options do not include any options derived
from the underlying surface; they are literally the options
passed to cairo_set_font_options().</doc>
        <source-position filename="cairo.h" line="1564"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="cr" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo.c"
                 line="3274">a #cairo_t</doc>
            <type name="Context" c:type="cairo_t*"/>
          </instance-parameter>
          <parameter name="options" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo.c"
                 line="3275">a #cairo_font_options_t object into which to store
  the retrieved options. All existing values are overwritten</doc>
            <type name="FontOptions" c:type="cairo_font_options_t*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_group_target"
              c:identifier="cairo_get_group_target"
              version="1.2">
        <doc xml:space="preserve"
             filename="cairo.c"
             line="4197">Gets the current destination surface for the context. This is either
the original target surface as passed to cairo_create() or the target
surface for the current group as started by the most recent call to
cairo_push_group() or cairo_push_group_with_content().

This function will always return a valid pointer, but the result
can be a "nil" surface if @cr is already in an error state,
(ie. cairo_status() &lt;literal&gt;!=&lt;/literal&gt; %CAIRO_STATUS_SUCCESS).
A nil surface is indicated by cairo_surface_status()
&lt;literal&gt;!=&lt;/literal&gt; %CAIRO_STATUS_SUCCESS.</doc>
        <source-position filename="cairo.h" line="2117"/>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve"
               filename="cairo.c"
               line="4212">the target surface. This object is owned by cairo. To
keep a reference to it, you must call cairo_surface_reference().</doc>
          <type name="Surface" c:type="cairo_surface_t*"/>
        </return-value>
        <parameters>
          <instance-parameter name="cr" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo.c"
                 line="4199">a cairo context</doc>
            <type name="Context" c:type="cairo_t*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_hairline"
              c:identifier="cairo_get_hairline"
              version="1.18">
        <doc xml:space="preserve"
             filename="cairo.c"
             line="4074">Returns whether or not hairline mode is set, as set by cairo_set_hairline().</doc>
        <source-position filename="cairo.h" line="2093"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cairo.c"
               line="4080">whether hairline mode is set.</doc>
          <type name="Bool" c:type="cairo_bool_t"/>
        </return-value>
        <parameters>
          <instance-parameter name="cr" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo.c"
                 line="4076">a cairo context</doc>
            <type name="Context" c:type="cairo_t*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_line_cap"
              c:identifier="cairo_get_line_cap"
              version="1.0">
        <doc xml:space="preserve"
             filename="cairo.c"
             line="4093">Gets the current line cap style, as set by cairo_set_line_cap().</doc>
        <source-position filename="cairo.h" line="2096"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cairo.c"
               line="4099">the current line cap style.</doc>
          <type name="LineCap" c:type="cairo_line_cap_t"/>
        </return-value>
        <parameters>
          <instance-parameter name="cr" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo.c"
                 line="4095">a cairo context</doc>
            <type name="Context" c:type="cairo_t*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_line_join"
              c:identifier="cairo_get_line_join"
              version="1.0">
        <doc xml:space="preserve"
             filename="cairo.c"
             line="4112">Gets the current line join style, as set by cairo_set_line_join().</doc>
        <source-position filename="cairo.h" line="2099"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cairo.c"
               line="4118">the current line join style.</doc>
          <type name="LineJoin" c:type="cairo_line_join_t"/>
        </return-value>
        <parameters>
          <instance-parameter name="cr" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo.c"
                 line="4114">a cairo context</doc>
            <type name="Context" c:type="cairo_t*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_line_width"
              c:identifier="cairo_get_line_width"
              version="1.0">
        <doc xml:space="preserve"
             filename="cairo.c"
             line="4052">This function returns the current line width value exactly as set by
cairo_set_line_width(). Note that the value is unchanged even if
the CTM has changed between the calls to cairo_set_line_width() and
cairo_get_line_width().</doc>
        <source-position filename="cairo.h" line="2090"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cairo.c"
               line="4061">the current line width.</doc>
          <type name="gdouble" c:type="double"/>
        </return-value>
        <parameters>
          <instance-parameter name="cr" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo.c"
                 line="4054">a cairo context</doc>
            <type name="Context" c:type="cairo_t*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_matrix" c:identifier="cairo_get_matrix" version="1.0">
        <doc xml:space="preserve"
             filename="cairo.c"
             line="4150">Stores the current transformation matrix (CTM) into @matrix.</doc>
        <source-position filename="cairo.h" line="2111"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="cr" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo.c"
                 line="4152">a cairo context</doc>
            <type name="Context" c:type="cairo_t*"/>
          </instance-parameter>
          <parameter name="matrix" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo.c"
                 line="4153">return value for the matrix</doc>
            <type name="Matrix" c:type="cairo_matrix_t*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_miter_limit"
              c:identifier="cairo_get_miter_limit"
              version="1.0">
        <doc xml:space="preserve"
             filename="cairo.c"
             line="4131">Gets the current miter limit, as set by cairo_set_miter_limit().</doc>
        <source-position filename="cairo.h" line="2102"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cairo.c"
               line="4137">the current miter limit.</doc>
          <type name="gdouble" c:type="double"/>
        </return-value>
        <parameters>
          <instance-parameter name="cr" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo.c"
                 line="4133">a cairo context</doc>
            <type name="Context" c:type="cairo_t*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_operator"
              c:identifier="cairo_get_operator"
              version="1.0">
        <doc xml:space="preserve"
             filename="cairo.c"
             line="3884">Gets the current compositing operator for a cairo context.</doc>
        <source-position filename="cairo.h" line="2069"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cairo.c"
               line="3890">the current compositing operator.</doc>
          <type name="Operator" c:type="cairo_operator_t"/>
        </return-value>
        <parameters>
          <instance-parameter name="cr" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo.c"
                 line="3886">a cairo context</doc>
            <type name="Context" c:type="cairo_t*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_scaled_font"
              c:identifier="cairo_get_scaled_font"
              version="1.4">
        <doc xml:space="preserve"
             filename="cairo.c"
             line="3339">Gets the current scaled font for a #cairo_t.</doc>
        <source-position filename="cairo.h" line="1578"/>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve"
               filename="cairo.c"
               line="3345">the current scaled font. This object is owned by
cairo. To keep a reference to it, you must call
cairo_scaled_font_reference().

This function never returns %NULL. If memory cannot be allocated, a
special "nil" #cairo_scaled_font_t object will be returned on which
cairo_scaled_font_status() returns %CAIRO_STATUS_NO_MEMORY. Using
this nil object will cause its error state to propagate to other
objects it is passed to, (for example, calling
cairo_set_scaled_font() with a nil font will trigger an error that
will shutdown the #cairo_t object).</doc>
          <type name="ScaledFont" c:type="cairo_scaled_font_t*"/>
        </return-value>
        <parameters>
          <instance-parameter name="cr" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo.c"
                 line="3341">a #cairo_t</doc>
            <type name="Context" c:type="cairo_t*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_source" c:identifier="cairo_get_source" version="1.0">
        <doc xml:space="preserve"
             filename="cairo.c"
             line="1026">Gets the current source pattern for @cr.</doc>
        <source-position filename="cairo.h" line="2072"/>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve"
               filename="cairo.c"
               line="1032">the current source pattern. This object is owned by
cairo. To keep a reference to it, you must call
cairo_pattern_reference().</doc>
          <type name="Pattern" c:type="cairo_pattern_t*"/>
        </return-value>
        <parameters>
          <instance-parameter name="cr" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo.c"
                 line="1028">a cairo context</doc>
            <type name="Context" c:type="cairo_t*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_target" c:identifier="cairo_get_target" version="1.0">
        <doc xml:space="preserve"
             filename="cairo.c"
             line="4170">Gets the target surface for the cairo context as passed to
cairo_create().

This function will always return a valid pointer, but the result
can be a "nil" surface if @cr is already in an error state,
(ie. cairo_status() &lt;literal&gt;!=&lt;/literal&gt; %CAIRO_STATUS_SUCCESS).
A nil surface is indicated by cairo_surface_status()
&lt;literal&gt;!=&lt;/literal&gt; %CAIRO_STATUS_SUCCESS.</doc>
        <source-position filename="cairo.h" line="2114"/>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve"
               filename="cairo.c"
               line="4183">the target surface. This object is owned by cairo. To
keep a reference to it, you must call cairo_surface_reference().</doc>
          <type name="Surface" c:type="cairo_surface_t*"/>
        </return-value>
        <parameters>
          <instance-parameter name="cr" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo.c"
                 line="4172">a cairo context</doc>
            <type name="Context" c:type="cairo_t*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_tolerance"
              c:identifier="cairo_get_tolerance"
              version="1.0">
        <doc xml:space="preserve"
             filename="cairo.c"
             line="3924">Gets the current tolerance value, as set by cairo_set_tolerance().</doc>
        <source-position filename="cairo.h" line="2075"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cairo.c"
               line="3930">the current tolerance value.</doc>
          <type name="gdouble" c:type="double"/>
        </return-value>
        <parameters>
          <instance-parameter name="cr" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo.c"
                 line="3926">a cairo context</doc>
            <type name="Context" c:type="cairo_t*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="glyph_extents"
              c:identifier="cairo_glyph_extents"
              version="1.0">
        <doc xml:space="preserve"
             filename="cairo.c"
             line="3438">Gets the extents for an array of glyphs. The extents describe a
user-space rectangle that encloses the "inked" portion of the
glyphs, (as they would be drawn by cairo_show_glyphs()).
Additionally, the x_advance and y_advance values indicate the
amount by which the current point would be advanced by
cairo_show_glyphs().

Note that whitespace glyphs do not contribute to the size of the
rectangle (extents.width and extents.height).</doc>
        <source-position filename="cairo.h" line="1608"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="cr" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo.c"
                 line="3440">a #cairo_t</doc>
            <type name="Context" c:type="cairo_t*"/>
          </instance-parameter>
          <parameter name="glyphs" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo.c"
                 line="3441">an array of #cairo_glyph_t objects</doc>
            <type name="Glyph" c:type="const cairo_glyph_t*"/>
          </parameter>
          <parameter name="num_glyphs" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo.c"
                 line="3442">the number of elements in @glyphs</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="extents" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo.c"
                 line="3443">a #cairo_text_extents_t object into which the results
will be stored</doc>
            <type name="TextExtents" c:type="cairo_text_extents_t*"/>
          </parameter>
        </parameters>
      </method>
      <method name="glyph_path" c:identifier="cairo_glyph_path" version="1.0">
        <doc xml:space="preserve"
             filename="cairo.c"
             line="3846">Adds closed paths for the glyphs to the current path.  The generated
path if filled, achieves an effect similar to that of
cairo_show_glyphs().</doc>
        <source-position filename="cairo.h" line="1600"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="cr" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo.c"
                 line="3848">a cairo context</doc>
            <type name="Context" c:type="cairo_t*"/>
          </instance-parameter>
          <parameter name="glyphs" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo.c"
                 line="3849">array of glyphs to show</doc>
            <type name="Glyph" c:type="const cairo_glyph_t*"/>
          </parameter>
          <parameter name="num_glyphs" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo.c"
                 line="3850">number of glyphs to show</doc>
            <type name="gint" c:type="int"/>
          </parameter>
        </parameters>
      </method>
      <method name="has_current_point"
              c:identifier="cairo_has_current_point"
              version="1.6">
        <doc xml:space="preserve"
             filename="cairo.c"
             line="3963">Returns whether a current point is defined on the current path.
See cairo_get_current_point() for details on the current point.</doc>
        <source-position filename="cairo.h" line="2081"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cairo.c"
               line="3970">whether a current point is defined.</doc>
          <type name="Bool" c:type="cairo_bool_t"/>
        </return-value>
        <parameters>
          <instance-parameter name="cr" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo.c"
                 line="3965">a cairo context</doc>
            <type name="Context" c:type="cairo_t*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="identity_matrix"
              c:identifier="cairo_identity_matrix"
              version="1.0">
        <doc xml:space="preserve"
             filename="cairo.c"
             line="1547">Resets the current transformation matrix (CTM) by setting it equal
to the identity matrix. That is, the user-space and device-space
axes will be aligned and one user-space unit will transform to one
device-space unit.</doc>
        <source-position filename="cairo.h" line="882"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="cr" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo.c"
                 line="1549">a cairo context</doc>
            <type name="Context" c:type="cairo_t*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="in_clip" c:identifier="cairo_in_clip" version="1.10">
        <doc xml:space="preserve"
             filename="cairo.c"
             line="2828">Tests whether the given point is inside the area that would be
visible through the current clip, i.e. the area that would be filled by
a cairo_paint() operation.

See cairo_clip(), and cairo_clip_preserve().</doc>
        <source-position filename="cairo.h" line="1009"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cairo.c"
               line="2840">A non-zero value if the point is inside, or zero if
outside.</doc>
          <type name="Bool" c:type="cairo_bool_t"/>
        </return-value>
        <parameters>
          <instance-parameter name="cr" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo.c"
                 line="2830">a cairo context</doc>
            <type name="Context" c:type="cairo_t*"/>
          </instance-parameter>
          <parameter name="x" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo.c"
                 line="2831">X coordinate of the point to test</doc>
            <type name="gdouble" c:type="double"/>
          </parameter>
          <parameter name="y" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo.c"
                 line="2832">Y coordinate of the point to test</doc>
            <type name="gdouble" c:type="double"/>
          </parameter>
        </parameters>
      </method>
      <method name="in_fill" c:identifier="cairo_in_fill" version="1.0">
        <doc xml:space="preserve"
             filename="cairo.c"
             line="2547">Tests whether the given point is inside the area that would be
affected by a cairo_fill() operation given the current path and
filling parameters. Surface dimensions and clipping are not taken
into account.

See cairo_fill(), cairo_set_fill_rule() and cairo_fill_preserve().</doc>
        <source-position filename="cairo.h" line="1006"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cairo.c"
               line="2560">A non-zero value if the point is inside, or zero if
outside.</doc>
          <type name="Bool" c:type="cairo_bool_t"/>
        </return-value>
        <parameters>
          <instance-parameter name="cr" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo.c"
                 line="2549">a cairo context</doc>
            <type name="Context" c:type="cairo_t*"/>
          </instance-parameter>
          <parameter name="x" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo.c"
                 line="2550">X coordinate of the point to test</doc>
            <type name="gdouble" c:type="double"/>
          </parameter>
          <parameter name="y" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo.c"
                 line="2551">Y coordinate of the point to test</doc>
            <type name="gdouble" c:type="double"/>
          </parameter>
        </parameters>
      </method>
      <method name="in_stroke" c:identifier="cairo_in_stroke" version="1.0">
        <doc xml:space="preserve"
             filename="cairo.c"
             line="2511">Tests whether the given point is inside the area that would be
affected by a cairo_stroke() operation given the current path and
stroking parameters. Surface dimensions and clipping are not taken
into account.

See cairo_stroke(), cairo_set_line_width(), cairo_set_line_join(),
cairo_set_line_cap(), cairo_set_dash(), and
cairo_stroke_preserve().</doc>
        <source-position filename="cairo.h" line="1003"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cairo.c"
               line="2526">A non-zero value if the point is inside, or zero if
outside.</doc>
          <type name="Bool" c:type="cairo_bool_t"/>
        </return-value>
        <parameters>
          <instance-parameter name="cr" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo.c"
                 line="2513">a cairo context</doc>
            <type name="Context" c:type="cairo_t*"/>
          </instance-parameter>
          <parameter name="x" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo.c"
                 line="2514">X coordinate of the point to test</doc>
            <type name="gdouble" c:type="double"/>
          </parameter>
          <parameter name="y" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo.c"
                 line="2515">Y coordinate of the point to test</doc>
            <type name="gdouble" c:type="double"/>
          </parameter>
        </parameters>
      </method>
      <method name="line_to" c:identifier="cairo_line_to" version="1.0">
        <doc xml:space="preserve"
             filename="cairo.c"
             line="1734">Adds a line to the path from the current point to position (@x, @y)
in user-space coordinates. After this call the current point
will be (@x, @y).

If there is no current point before the call to cairo_line_to()
this function will behave as cairo_move_to(@cr, @x, @y).</doc>
        <source-position filename="cairo.h" line="907"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="cr" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo.c"
                 line="1736">a cairo context</doc>
            <type name="Context" c:type="cairo_t*"/>
          </instance-parameter>
          <parameter name="x" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo.c"
                 line="1737">the X coordinate of the end of the new line</doc>
            <type name="gdouble" c:type="double"/>
          </parameter>
          <parameter name="y" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo.c"
                 line="1738">the Y coordinate of the end of the new line</doc>
            <type name="gdouble" c:type="double"/>
          </parameter>
        </parameters>
      </method>
      <method name="mask" c:identifier="cairo_mask" version="1.0">
        <doc xml:space="preserve"
             filename="cairo.c"
             line="2261">A drawing operator that paints the current source
using the alpha channel of @pattern as a mask. (Opaque
areas of @pattern are painted with the source, transparent
areas are not painted.)</doc>
        <source-position filename="cairo.h" line="974"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="cr" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo.c"
                 line="2263">a cairo context</doc>
            <type name="Context" c:type="cairo_t*"/>
          </instance-parameter>
          <parameter name="pattern" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo.c"
                 line="2264">a #cairo_pattern_t</doc>
            <type name="Pattern" c:type="cairo_pattern_t*"/>
          </parameter>
        </parameters>
      </method>
      <method name="mask_surface"
              c:identifier="cairo_mask_surface"
              version="1.0">
        <doc xml:space="preserve"
             filename="cairo.c"
             line="2297">A drawing operator that paints the current source
using the alpha channel of @surface as a mask. (Opaque
areas of @surface are painted with the source, transparent
areas are not painted.)</doc>
        <source-position filename="cairo.h" line="978"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="cr" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo.c"
                 line="2299">a cairo context</doc>
            <type name="Context" c:type="cairo_t*"/>
          </instance-parameter>
          <parameter name="surface" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo.c"
                 line="2300">a #cairo_surface_t</doc>
            <type name="Surface" c:type="cairo_surface_t*"/>
          </parameter>
          <parameter name="surface_x" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo.c"
                 line="2301">X coordinate at which to place the origin of @surface</doc>
            <type name="gdouble" c:type="double"/>
          </parameter>
          <parameter name="surface_y" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo.c"
                 line="2302">Y coordinate at which to place the origin of @surface</doc>
            <type name="gdouble" c:type="double"/>
          </parameter>
        </parameters>
      </method>
      <method name="move_to" c:identifier="cairo_move_to" version="1.0">
        <doc xml:space="preserve"
             filename="cairo.c"
             line="1710">Begin a new sub-path. After this call the current point will be (@x,
@y).</doc>
        <source-position filename="cairo.h" line="901"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="cr" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo.c"
                 line="1712">a cairo context</doc>
            <type name="Context" c:type="cairo_t*"/>
          </instance-parameter>
          <parameter name="x" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo.c"
                 line="1713">the X coordinate of the new position</doc>
            <type name="gdouble" c:type="double"/>
          </parameter>
          <parameter name="y" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo.c"
                 line="1714">the Y coordinate of the new position</doc>
            <type name="gdouble" c:type="double"/>
          </parameter>
        </parameters>
      </method>
      <method name="new_path" c:identifier="cairo_new_path" version="1.0">
        <doc xml:space="preserve"
             filename="cairo.c"
             line="1657">Clears the current path. After this call there will be no path and
no current point.</doc>
        <source-position filename="cairo.h" line="898"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="cr" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo.c"
                 line="1659">a cairo context</doc>
            <type name="Context" c:type="cairo_t*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="new_sub_path"
              c:identifier="cairo_new_sub_path"
              version="1.2">
        <doc xml:space="preserve"
             filename="cairo.c"
             line="1679">Begin a new sub-path. Note that the existing path is not
affected. After this call there will be no current point.

In many cases, this call is not needed since new sub-paths are
frequently started with cairo_move_to().

A call to cairo_new_sub_path() is particularly useful when
beginning a new sub-path with one of the cairo_arc() calls. This
makes things easier as it is no longer necessary to manually
compute the arc's initial coordinates for a call to
cairo_move_to().</doc>
        <source-position filename="cairo.h" line="904"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="cr" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo.c"
                 line="1681">a cairo context</doc>
            <type name="Context" c:type="cairo_t*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="paint" c:identifier="cairo_paint" version="1.0">
        <doc xml:space="preserve"
             filename="cairo.c"
             line="2213">A drawing operator that paints the current source everywhere within
the current clip region.</doc>
        <source-position filename="cairo.h" line="967"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="cr" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo.c"
                 line="2215">a cairo context</doc>
            <type name="Context" c:type="cairo_t*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="paint_with_alpha"
              c:identifier="cairo_paint_with_alpha"
              version="1.0">
        <doc xml:space="preserve"
             filename="cairo.c"
             line="2235">A drawing operator that paints the current source everywhere within
the current clip region using a mask of constant alpha value
@alpha. The effect is similar to cairo_paint(), but the drawing
is faded out using the alpha value.</doc>
        <source-position filename="cairo.h" line="970"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="cr" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo.c"
                 line="2237">a cairo context</doc>
            <type name="Context" c:type="cairo_t*"/>
          </instance-parameter>
          <parameter name="alpha" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo.c"
                 line="2238">alpha value, between 0 (transparent) and 1 (opaque)</doc>
            <type name="gdouble" c:type="double"/>
          </parameter>
        </parameters>
      </method>
      <method name="path_extents"
              c:identifier="cairo_path_extents"
              version="1.6">
        <doc xml:space="preserve"
             filename="cairo.c"
             line="2162">Computes a bounding box in user-space coordinates covering the
points on the current path. If the current path is empty, returns
an empty rectangle ((0,0), (0,0)). Stroke parameters, fill rule,
surface dimensions and clipping are not taken into account.

Contrast with cairo_fill_extents() and cairo_stroke_extents() which
return the extents of only the area that would be "inked" by
the corresponding drawing operations.

The result of cairo_path_extents() is defined as equivalent to the
limit of cairo_stroke_extents() with %CAIRO_LINE_CAP_ROUND as the
line width approaches 0.0, (but never reaching the empty-rectangle
returned by cairo_stroke_extents() for a line width of 0.0).

Specifically, this means that zero-area sub-paths such as
cairo_move_to();cairo_line_to() segments, (even degenerate cases
where the coordinates to both calls are identical), will be
considered as contributing to the extents. However, a lone
cairo_move_to() will not contribute to the results of
cairo_path_extents().</doc>
        <source-position filename="cairo.h" line="961"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="cr" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo.c"
                 line="2164">a cairo context</doc>
            <type name="Context" c:type="cairo_t*"/>
          </instance-parameter>
          <parameter name="x1" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo.c"
                 line="2165">left of the resulting extents</doc>
            <type name="gdouble" c:type="double*"/>
          </parameter>
          <parameter name="y1" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo.c"
                 line="2166">top of the resulting extents</doc>
            <type name="gdouble" c:type="double*"/>
          </parameter>
          <parameter name="x2" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo.c"
                 line="2167">right of the resulting extents</doc>
            <type name="gdouble" c:type="double*"/>
          </parameter>
          <parameter name="y2" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo.c"
                 line="2168">bottom of the resulting extents</doc>
            <type name="gdouble" c:type="double*"/>
          </parameter>
        </parameters>
      </method>
      <method name="pop_group" c:identifier="cairo_pop_group" version="1.2">
        <doc xml:space="preserve"
             filename="cairo.c"
             line="739">Terminates the redirection begun by a call to cairo_push_group() or
cairo_push_group_with_content() and returns a new pattern
containing the results of all drawing operations performed to the
group.

The cairo_pop_group() function calls cairo_restore(), (balancing a
call to cairo_save() by the push_group function), so that any
changes to the graphics state will not be visible outside the
group.</doc>
        <source-position filename="cairo.h" line="574"/>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve"
               filename="cairo.c"
               line="753">a newly created (surface) pattern containing the
results of all drawing operations performed to the group. The
caller owns the returned object and should call
cairo_pattern_destroy() when finished with it.</doc>
          <type name="Pattern" c:type="cairo_pattern_t*"/>
        </return-value>
        <parameters>
          <instance-parameter name="cr" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo.c"
                 line="741">a cairo context</doc>
            <type name="Context" c:type="cairo_t*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="pop_group_to_source"
              c:identifier="cairo_pop_group_to_source"
              version="1.2">
        <doc xml:space="preserve"
             filename="cairo.c"
             line="775">Terminates the redirection begun by a call to cairo_push_group() or
cairo_push_group_with_content() and installs the resulting pattern
as the source pattern in the given cairo context.

The behavior of this function is equivalent to the sequence of
operations:

&lt;informalexample&gt;&lt;programlisting&gt;
cairo_pattern_t *group = cairo_pop_group (cr);
cairo_set_source (cr, group);
cairo_pattern_destroy (group);
&lt;/programlisting&gt;&lt;/informalexample&gt;

but is more convenient as their is no need for a variable to store
the short-lived pointer to the pattern.

The cairo_pop_group() function calls cairo_restore(), (balancing a
call to cairo_save() by the push_group function), so that any
changes to the graphics state will not be visible outside the
group.</doc>
        <source-position filename="cairo.h" line="577"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="cr" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo.c"
                 line="777">a cairo context</doc>
            <type name="Context" c:type="cairo_t*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="push_group" c:identifier="cairo_push_group" version="1.2">
        <doc xml:space="preserve"
             filename="cairo.c"
             line="657">Temporarily redirects drawing to an intermediate surface known as a
group. The redirection lasts until the group is completed by a call
to cairo_pop_group() or cairo_pop_group_to_source(). These calls
provide the result of any drawing to the group as a pattern,
(either as an explicit object, or set as the source pattern).

This group functionality can be convenient for performing
intermediate compositing. One common use of a group is to render
objects as opaque within the group, (so that they occlude each
other), and then blend the result with translucence onto the
destination.

Groups can be nested arbitrarily deep by making balanced calls to
cairo_push_group()/cairo_pop_group(). Each call pushes/pops the new
target group onto/from a stack.

The cairo_push_group() function calls cairo_save() so that any
changes to the graphics state will not be visible outside the
group, (the pop_group functions call cairo_restore()).

By default the intermediate group will have a content type of
%CAIRO_CONTENT_COLOR_ALPHA. Other content types can be chosen for
the group by using cairo_push_group_with_content() instead.

As an example, here is how one might fill and stroke a path with
translucence, but without any portion of the fill being visible
under the stroke:

&lt;informalexample&gt;&lt;programlisting&gt;
cairo_push_group (cr);
cairo_set_source (cr, fill_pattern);
cairo_fill_preserve (cr);
cairo_set_source (cr, stroke_pattern);
cairo_stroke (cr);
cairo_pop_group_to_source (cr);
cairo_paint_with_alpha (cr, alpha);
&lt;/programlisting&gt;&lt;/informalexample&gt;</doc>
        <source-position filename="cairo.h" line="568"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="cr" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo.c"
                 line="659">a cairo context</doc>
            <type name="Context" c:type="cairo_t*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="push_group_with_content"
              c:identifier="cairo_push_group_with_content"
              version="1.2">
        <doc xml:space="preserve"
             filename="cairo.c"
             line="707">Temporarily redirects drawing to an intermediate surface known as a
group. The redirection lasts until the group is completed by a call
to cairo_pop_group() or cairo_pop_group_to_source(). These calls
provide the result of any drawing to the group as a pattern,
(either as an explicit object, or set as the source pattern).

The group will have a content type of @content. The ability to
control this content type is the only distinction between this
function and cairo_push_group() which you should see for a more
detailed description of group rendering.</doc>
        <source-position filename="cairo.h" line="571"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="cr" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo.c"
                 line="709">a cairo context</doc>
            <type name="Context" c:type="cairo_t*"/>
          </instance-parameter>
          <parameter name="content" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo.c"
                 line="710">a #cairo_content_t indicating the type of group that
          will be created</doc>
            <type name="Content" c:type="cairo_content_t"/>
          </parameter>
        </parameters>
      </method>
      <method name="rectangle" c:identifier="cairo_rectangle" version="1.0">
        <doc xml:space="preserve"
             filename="cairo.c"
             line="2066">Adds a closed sub-path rectangle of the given size to the current
path at position (@x, @y) in user-space coordinates.

This function is logically equivalent to:
&lt;informalexample&gt;&lt;programlisting&gt;
cairo_move_to (cr, x, y);
cairo_rel_line_to (cr, width, 0);
cairo_rel_line_to (cr, 0, height);
cairo_rel_line_to (cr, -width, 0);
cairo_close_path (cr);
&lt;/programlisting&gt;&lt;/informalexample&gt;</doc>
        <source-position filename="cairo.h" line="948"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="cr" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo.c"
                 line="2068">a cairo context</doc>
            <type name="Context" c:type="cairo_t*"/>
          </instance-parameter>
          <parameter name="x" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo.c"
                 line="2069">the X coordinate of the top left corner of the rectangle</doc>
            <type name="gdouble" c:type="double"/>
          </parameter>
          <parameter name="y" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo.c"
                 line="2070">the Y coordinate to the top left corner of the rectangle</doc>
            <type name="gdouble" c:type="double"/>
          </parameter>
          <parameter name="width" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo.c"
                 line="2071">the width of the rectangle</doc>
            <type name="gdouble" c:type="double"/>
          </parameter>
          <parameter name="height" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo.c"
                 line="2072">the height of the rectangle</doc>
            <type name="gdouble" c:type="double"/>
          </parameter>
        </parameters>
      </method>
      <method name="rel_curve_to"
              c:identifier="cairo_rel_curve_to"
              version="1.0">
        <doc xml:space="preserve"
             filename="cairo.c"
             line="2020">Relative-coordinate version of cairo_curve_to(). All offsets are
relative to the current point. Adds a cubic Bézier spline to the
path from the current point to a point offset from the current
point by (@dx3, @dy3), using points offset by (@dx1, @dy1) and
(@dx2, @dy2) as the control points. After this call the current
point will be offset by (@dx3, @dy3).

Given a current point of (x, y), cairo_rel_curve_to(@cr, @dx1,
@dy1, @dx2, @dy2, @dx3, @dy3) is logically equivalent to
cairo_curve_to(@cr, x+@dx1, y+@dy1, x+@dx2, y+@dy2, x+@dx3, y+@dy3).

It is an error to call this function with no current point. Doing
so will cause @cr to shutdown with a status of
%CAIRO_STATUS_NO_CURRENT_POINT.</doc>
        <source-position filename="cairo.h" line="942"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="cr" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo.c"
                 line="2022">a cairo context</doc>
            <type name="Context" c:type="cairo_t*"/>
          </instance-parameter>
          <parameter name="dx1" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo.c"
                 line="2023">the X offset to the first control point</doc>
            <type name="gdouble" c:type="double"/>
          </parameter>
          <parameter name="dy1" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo.c"
                 line="2024">the Y offset to the first control point</doc>
            <type name="gdouble" c:type="double"/>
          </parameter>
          <parameter name="dx2" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo.c"
                 line="2025">the X offset to the second control point</doc>
            <type name="gdouble" c:type="double"/>
          </parameter>
          <parameter name="dy2" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo.c"
                 line="2026">the Y offset to the second control point</doc>
            <type name="gdouble" c:type="double"/>
          </parameter>
          <parameter name="dx3" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo.c"
                 line="2027">the X offset to the end of the curve</doc>
            <type name="gdouble" c:type="double"/>
          </parameter>
          <parameter name="dy3" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo.c"
                 line="2028">the Y offset to the end of the curve</doc>
            <type name="gdouble" c:type="double"/>
          </parameter>
        </parameters>
      </method>
      <method name="rel_line_to"
              c:identifier="cairo_rel_line_to"
              version="1.0">
        <doc xml:space="preserve"
             filename="cairo.c"
             line="1987">Relative-coordinate version of cairo_line_to(). Adds a line to the
path from the current point to a point that is offset from the
current point by (@dx, @dy) in user space. After this call the
current point will be offset by (@dx, @dy).

Given a current point of (x, y), cairo_rel_line_to(@cr, @dx, @dy)
is logically equivalent to cairo_line_to(@cr, x + @dx, y + @dy).

It is an error to call this function with no current point. Doing
so will cause @cr to shutdown with a status of
%CAIRO_STATUS_NO_CURRENT_POINT.</doc>
        <source-position filename="cairo.h" line="939"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="cr" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo.c"
                 line="1989">a cairo context</doc>
            <type name="Context" c:type="cairo_t*"/>
          </instance-parameter>
          <parameter name="dx" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo.c"
                 line="1990">the X offset to the end of the new line</doc>
            <type name="gdouble" c:type="double"/>
          </parameter>
          <parameter name="dy" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo.c"
                 line="1991">the Y offset to the end of the new line</doc>
            <type name="gdouble" c:type="double"/>
          </parameter>
        </parameters>
      </method>
      <method name="rel_move_to"
              c:identifier="cairo_rel_move_to"
              version="1.0">
        <doc xml:space="preserve"
             filename="cairo.c"
             line="1956">Begin a new sub-path. After this call the current point will offset
by (@x, @y).

Given a current point of (x, y), cairo_rel_move_to(@cr, @dx, @dy)
is logically equivalent to cairo_move_to(@cr, x + @dx, y + @dy).

It is an error to call this function with no current point. Doing
so will cause @cr to shutdown with a status of
%CAIRO_STATUS_NO_CURRENT_POINT.</doc>
        <source-position filename="cairo.h" line="936"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="cr" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo.c"
                 line="1958">a cairo context</doc>
            <type name="Context" c:type="cairo_t*"/>
          </instance-parameter>
          <parameter name="dx" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo.c"
                 line="1959">the X offset</doc>
            <type name="gdouble" c:type="double"/>
          </parameter>
          <parameter name="dy" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo.c"
                 line="1960">the Y offset</doc>
            <type name="gdouble" c:type="double"/>
          </parameter>
        </parameters>
      </method>
      <method name="reset_clip" c:identifier="cairo_reset_clip" version="1.0">
        <doc xml:space="preserve"
             filename="cairo.c"
             line="2760">Reset the current clip region to its original, unrestricted
state. That is, set the clip region to an infinitely large shape
containing the target surface. Equivalently, if infinity is too
hard to grasp, one can imagine the clip region being reset to the
exact bounds of the target surface.

Note that code meant to be reusable should not call
cairo_reset_clip() as it will cause results unexpected by
higher-level code which calls cairo_clip(). Consider using
cairo_save() and cairo_restore() around cairo_clip() as a more
robust means of temporarily restricting the clip region.</doc>
        <source-position filename="cairo.h" line="1024"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="cr" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo.c"
                 line="2762">a cairo context</doc>
            <type name="Context" c:type="cairo_t*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="restore" c:identifier="cairo_restore" version="1.0">
        <doc xml:space="preserve"
             filename="cairo.c"
             line="634">Restores @cr to the state saved by a preceding call to
cairo_save() and removes that state from the stack of
saved states.</doc>
        <source-position filename="cairo.h" line="565"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="cr" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo.c"
                 line="636">a #cairo_t</doc>
            <type name="Context" c:type="cairo_t*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="rotate" c:identifier="cairo_rotate" version="1.0">
        <doc xml:space="preserve"
             filename="cairo.c"
             line="1471">Modifies the current transformation matrix (CTM) by rotating the
user-space axes by @angle radians. The rotation of the axes takes
places after any existing transformation of user space. The
rotation direction for positive angles is from the positive X axis
toward the positive Y axis.</doc>
        <source-position filename="cairo.h" line="871"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="cr" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo.c"
                 line="1473">a cairo context</doc>
            <type name="Context" c:type="cairo_t*"/>
          </instance-parameter>
          <parameter name="angle" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo.c"
                 line="1474">angle (in radians) by which the user-space axes will be
rotated</doc>
            <type name="gdouble" c:type="double"/>
          </parameter>
        </parameters>
      </method>
      <method name="save" c:identifier="cairo_save" version="1.0">
        <doc xml:space="preserve"
             filename="cairo.c"
             line="603">Makes a copy of the current state of @cr and saves it
on an internal stack of saved states for @cr. When
cairo_restore() is called, @cr will be restored to
the saved state. Multiple calls to cairo_save() and
cairo_restore() can be nested; each call to cairo_restore()
restores the state from the matching paired cairo_save().

It isn't necessary to clear all saved states before
a #cairo_t is freed. If the reference count of a #cairo_t
drops to zero in response to a call to cairo_destroy(),
any saved states will be freed along with the #cairo_t.</doc>
        <source-position filename="cairo.h" line="562"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="cr" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo.c"
                 line="605">a #cairo_t</doc>
            <type name="Context" c:type="cairo_t*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="scale" c:identifier="cairo_scale" version="1.0">
        <doc xml:space="preserve"
             filename="cairo.c"
             line="1445">Modifies the current transformation matrix (CTM) by scaling the X
and Y user-space axes by @sx and @sy respectively. The scaling of
the axes takes place after any existing transformation of user
space.</doc>
        <source-position filename="cairo.h" line="868"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="cr" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo.c"
                 line="1447">a cairo context</doc>
            <type name="Context" c:type="cairo_t*"/>
          </instance-parameter>
          <parameter name="sx" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo.c"
                 line="1448">scale factor for the X dimension</doc>
            <type name="gdouble" c:type="double"/>
          </parameter>
          <parameter name="sy" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo.c"
                 line="1449">scale factor for the Y dimension</doc>
            <type name="gdouble" c:type="double"/>
          </parameter>
        </parameters>
      </method>
      <method name="select_font_face"
              c:identifier="cairo_select_font_face"
              version="1.0">
        <doc xml:space="preserve"
             filename="cairo.c"
             line="2997">Note: The cairo_select_font_face() function call is part of what
the cairo designers call the "toy" text API. It is convenient for
short demos and simple programs, but it is not expected to be
adequate for serious text-using applications.

Selects a family and style of font from a simplified description as
a family name, slant and weight. Cairo provides no operation to
list available family names on the system (this is a "toy",
remember), but the standard CSS2 generic family names, ("serif",
"sans-serif", "cursive", "fantasy", "monospace"), are likely to
work as expected.

If @family starts with the string "@cairo:", or if no native font
backends are compiled in, cairo will use an internal font family.
The internal font family recognizes many modifiers in the @family
string, most notably, it recognizes the string "monospace".  That is,
the family name "@cairo:monospace" will use the monospace version of
the internal font family.

For "real" font selection, see the font-backend-specific
font_face_create functions for the font backend you are using. (For
example, if you are using the freetype-based cairo-ft font backend,
see cairo_ft_font_face_create_for_ft_face() or
cairo_ft_font_face_create_for_pattern().) The resulting font face
could then be used with cairo_scaled_font_create() and
cairo_set_scaled_font().

Similarly, when using the "real" font support, you can call
directly into the underlying font system, (such as fontconfig or
freetype), for operations such as listing available fonts, etc.

It is expected that most applications will need to use a more
comprehensive font handling and text layout library, (for example,
pango), in conjunction with cairo.

If text is drawn without a call to cairo_select_font_face(), (nor
cairo_set_font_face() nor cairo_set_scaled_font()), the default
family is platform-specific, but is essentially "sans-serif".
Default slant is %CAIRO_FONT_SLANT_NORMAL, and default weight is
%CAIRO_FONT_WEIGHT_NORMAL.

This function is equivalent to a call to cairo_toy_font_face_create()
followed by cairo_set_font_face().</doc>
        <source-position filename="cairo.h" line="1543"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="cr" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo.c"
                 line="2999">a #cairo_t</doc>
            <type name="Context" c:type="cairo_t*"/>
          </instance-parameter>
          <parameter name="family" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo.c"
                 line="3000">a font family name, encoded in UTF-8</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter name="slant" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo.c"
                 line="3001">the slant for the font</doc>
            <type name="FontSlant" c:type="cairo_font_slant_t"/>
          </parameter>
          <parameter name="weight" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo.c"
                 line="3002">the weight for the font</doc>
            <type name="FontWeight" c:type="cairo_font_weight_t"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_antialias"
              c:identifier="cairo_set_antialias"
              version="1.0">
        <doc xml:space="preserve"
             filename="cairo.c"
             line="1078">Set the antialiasing mode of the rasterizer used for drawing shapes.
This value is a hint, and a particular backend may or may not support
a particular value.  At the current time, no backend supports
%CAIRO_ANTIALIAS_SUBPIXEL when drawing shapes.

Note that this option does not affect text rendering, instead see
cairo_font_options_set_antialias().</doc>
        <source-position filename="cairo.h" line="767"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="cr" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo.c"
                 line="1080">a #cairo_t</doc>
            <type name="Context" c:type="cairo_t*"/>
          </instance-parameter>
          <parameter name="antialias" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo.c"
                 line="1081">the new antialiasing mode</doc>
            <type name="Antialias" c:type="cairo_antialias_t"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_dash" c:identifier="cairo_set_dash" version="1.0">
        <doc xml:space="preserve"
             filename="cairo.c"
             line="1277">Sets the dash pattern to be used by cairo_stroke(). A dash pattern
is specified by @dashes, an array of positive values. Each value
provides the length of alternate "on" and "off" portions of the
stroke. The @offset specifies an offset into the pattern at which
the stroke begins.

Each "on" segment will have caps applied as if the segment were a
separate sub-path. In particular, it is valid to use an "on" length
of 0.0 with %CAIRO_LINE_CAP_ROUND or %CAIRO_LINE_CAP_SQUARE in order
to distributed dots or squares along a path.

Note: The length values are in user-space units as evaluated at the
time of stroking. This is not necessarily the same as the user
space at the time of cairo_set_dash().

If @num_dashes is 0 dashing is disabled.

If @num_dashes is 1 a symmetric pattern is assumed with alternating
on and off portions of the size specified by the single value in
@dashes.

If any value in @dashes is negative, or if all values are 0, then
@cr will be put into an error state with a status of
%CAIRO_STATUS_INVALID_DASH.</doc>
        <source-position filename="cairo.h" line="856"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="cr" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo.c"
                 line="1279">a cairo context</doc>
            <type name="Context" c:type="cairo_t*"/>
          </instance-parameter>
          <parameter name="dashes" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo.c"
                 line="1280">an array specifying alternate lengths of on and off stroke portions</doc>
            <type name="gdouble" c:type="const double*"/>
          </parameter>
          <parameter name="num_dashes" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo.c"
                 line="1281">the length of the dashes array</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="offset" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo.c"
                 line="1282">an offset into the dash pattern at which the stroke should start</doc>
            <type name="gdouble" c:type="double"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_fill_rule"
              c:identifier="cairo_set_fill_rule"
              version="1.0">
        <doc xml:space="preserve"
             filename="cairo.c"
             line="1106">Set the current fill rule within the cairo context. The fill rule
is used to determine which regions are inside or outside a complex
(potentially self-intersecting) path. The current fill rule affects
both cairo_fill() and cairo_clip(). See #cairo_fill_rule_t for details
on the semantics of each available fill rule.

The default fill rule is %CAIRO_FILL_RULE_WINDING.</doc>
        <source-position filename="cairo.h" line="802"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="cr" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo.c"
                 line="1108">a #cairo_t</doc>
            <type name="Context" c:type="cairo_t*"/>
          </instance-parameter>
          <parameter name="fill_rule" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo.c"
                 line="1109">a fill rule, specified as a #cairo_fill_rule_t</doc>
            <type name="FillRule" c:type="cairo_fill_rule_t"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_font_face"
              c:identifier="cairo_set_font_face"
              version="1.0">
        <doc xml:space="preserve"
             filename="cairo.c"
             line="3105">Replaces the current #cairo_font_face_t object in the #cairo_t with
@font_face. The replaced font face in the #cairo_t will be
destroyed if there are no other references to it.</doc>
        <source-position filename="cairo.h" line="1568"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="cr" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo.c"
                 line="3107">a #cairo_t</doc>
            <type name="Context" c:type="cairo_t*"/>
          </instance-parameter>
          <parameter name="font_face" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo.c"
                 line="3108">a #cairo_font_face_t, or %NULL to restore to the default font</doc>
            <type name="FontFace" c:type="cairo_font_face_t*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_font_matrix"
              c:identifier="cairo_set_font_matrix"
              version="1.0">
        <doc xml:space="preserve"
             filename="cairo.c"
             line="3189">Sets the current font matrix to @matrix. The font matrix gives a
transformation from the design space of the font (in this space,
the em-square is 1 unit by 1 unit) to user space. Normally, a
simple scale is used (see cairo_set_font_size()), but a more
complex font matrix can be used to shear the font
or stretch it unequally along the two axes</doc>
        <source-position filename="cairo.h" line="1552"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="cr" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo.c"
                 line="3191">a #cairo_t</doc>
            <type name="Context" c:type="cairo_t*"/>
          </instance-parameter>
          <parameter name="matrix" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo.c"
                 line="3192">a #cairo_matrix_t describing a transform to be applied to
the current font.</doc>
            <type name="Matrix" c:type="const cairo_matrix_t*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_font_options"
              c:identifier="cairo_set_font_options"
              version="1.0">
        <doc xml:space="preserve"
             filename="cairo.c"
             line="3239">Sets a set of custom font rendering options for the #cairo_t.
Rendering options are derived by merging these options with the
options derived from underlying surface; if the value in @options
has a default value (like %CAIRO_ANTIALIAS_DEFAULT), then the value
from the surface is used.</doc>
        <source-position filename="cairo.h" line="1560"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="cr" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo.c"
                 line="3241">a #cairo_t</doc>
            <type name="Context" c:type="cairo_t*"/>
          </instance-parameter>
          <parameter name="options" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo.c"
                 line="3242">font options to use</doc>
            <type name="FontOptions" c:type="const cairo_font_options_t*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_font_size"
              c:identifier="cairo_set_font_size"
              version="1.0">
        <doc xml:space="preserve"
             filename="cairo.c"
             line="3159">Sets the current font matrix to a scale by a factor of @size, replacing
any font matrix previously set with cairo_set_font_size() or
cairo_set_font_matrix(). This results in a font size of @size user space
units. (More precisely, this matrix will result in the font's
em-square being a @size by @size square in user space.)

If text is drawn without a call to cairo_set_font_size(), (nor
cairo_set_font_matrix() nor cairo_set_scaled_font()), the default
font size is 10.0.</doc>
        <source-position filename="cairo.h" line="1549"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="cr" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo.c"
                 line="3161">a #cairo_t</doc>
            <type name="Context" c:type="cairo_t*"/>
          </instance-parameter>
          <parameter name="size" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo.c"
                 line="3162">the new font size, in user space units</doc>
            <type name="gdouble" c:type="double"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_hairline"
              c:identifier="cairo_set_hairline"
              version="1.18">
        <doc xml:space="preserve"
             filename="cairo.c"
             line="1177">Sets lines within the cairo context to be hairlines.
Hairlines are logically zero-width lines that are drawn at the
thinnest renderable width possible in the current context.

On surfaces with native hairline support, the native hairline
functionality will be used. Surfaces that support hairlines include:
- pdf/ps: Encoded as 0-width line.
- win32_printing: Rendered with PS_COSMETIC pen.
- svg: Encoded as 1px non-scaling-stroke.
- script: Encoded with set-hairline function.

Cairo will always render hairlines at 1 device unit wide, even if
an anisotropic scaling was applied to the stroke width. In the wild,
handling of this situation is not well-defined. Some PDF, PS, and SVG
renderers match Cairo's output, but some very popular implementations
(Acrobat, Chrome, rsvg) will scale the hairline unevenly.
As such, best practice is to reset any anisotropic scaling before calling
cairo_stroke(). See https://cairographics.org/cookbook/ellipses/
for an example.</doc>
        <source-position filename="cairo.h" line="808"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="cr" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo.c"
                 line="1179">a #cairo_t</doc>
            <type name="Context" c:type="cairo_t*"/>
          </instance-parameter>
          <parameter name="set_hairline" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo.c"
                 line="1180">whether or not to set hairline mode</doc>
            <type name="Bool" c:type="cairo_bool_t"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_line_cap"
              c:identifier="cairo_set_line_cap"
              version="1.0">
        <doc xml:space="preserve"
             filename="cairo.c"
             line="1217">Sets the current line cap style within the cairo context. See
#cairo_line_cap_t for details about how the available line cap
styles are drawn.

As with the other stroke parameters, the current line cap style is
examined by cairo_stroke(), and cairo_stroke_extents(), but does not have
any effect during path construction.

The default line cap style is %CAIRO_LINE_CAP_BUTT.</doc>
        <source-position filename="cairo.h" line="829"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="cr" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo.c"
                 line="1219">a cairo context</doc>
            <type name="Context" c:type="cairo_t*"/>
          </instance-parameter>
          <parameter name="line_cap" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo.c"
                 line="1220">a line cap style</doc>
            <type name="LineCap" c:type="cairo_line_cap_t"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_line_join"
              c:identifier="cairo_set_line_join"
              version="1.0">
        <doc xml:space="preserve"
             filename="cairo.c"
             line="1247">Sets the current line join style within the cairo context. See
#cairo_line_join_t for details about how the available line join
styles are drawn.

As with the other stroke parameters, the current line join style is
examined by cairo_stroke(), and cairo_stroke_extents(), but does not have
any effect during path construction.

The default line join style is %CAIRO_LINE_JOIN_MITER.</doc>
        <source-position filename="cairo.h" line="853"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="cr" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo.c"
                 line="1249">a cairo context</doc>
            <type name="Context" c:type="cairo_t*"/>
          </instance-parameter>
          <parameter name="line_join" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo.c"
                 line="1250">a line join style</doc>
            <type name="LineJoin" c:type="cairo_line_join_t"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_line_width"
              c:identifier="cairo_set_line_width"
              version="1.0">
        <doc xml:space="preserve"
             filename="cairo.c"
             line="1134">Sets the current line width within the cairo context. The line
width value specifies the diameter of a pen that is circular in
user space, (though device-space pen may be an ellipse in general
due to scaling/shear/rotation of the CTM).

Note: When the description above refers to user space and CTM it
refers to the user space and CTM in effect at the time of the
stroking operation, not the user space and CTM in effect at the
time of the call to cairo_set_line_width(). The simplest usage
makes both of these spaces identical. That is, if there is no
change to the CTM between a call to cairo_set_line_width() and the
stroking operation, then one can just pass user-space values to
cairo_set_line_width() and ignore this note.

As with the other stroke parameters, the current line width is
examined by cairo_stroke(), and cairo_stroke_extents(), but does not have
any effect during path construction.

The default line width value is 2.0.</doc>
        <source-position filename="cairo.h" line="805"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="cr" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo.c"
                 line="1136">a #cairo_t</doc>
            <type name="Context" c:type="cairo_t*"/>
          </instance-parameter>
          <parameter name="width" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo.c"
                 line="1137">a line width</doc>
            <type name="gdouble" c:type="double"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_matrix" c:identifier="cairo_set_matrix" version="1.0">
        <doc xml:space="preserve"
             filename="cairo.c"
             line="1523">Modifies the current transformation matrix (CTM) by setting it
equal to @matrix.</doc>
        <source-position filename="cairo.h" line="878"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="cr" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo.c"
                 line="1525">a cairo context</doc>
            <type name="Context" c:type="cairo_t*"/>
          </instance-parameter>
          <parameter name="matrix" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo.c"
                 line="1526">a transformation matrix from user space to device space</doc>
            <type name="Matrix" c:type="const cairo_matrix_t*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_miter_limit"
              c:identifier="cairo_set_miter_limit"
              version="1.0">
        <doc xml:space="preserve"
             filename="cairo.c"
             line="1376">Sets the current miter limit within the cairo context.

If the current line join style is set to %CAIRO_LINE_JOIN_MITER
(see cairo_set_line_join()), the miter limit is used to determine
whether the lines should be joined with a bevel instead of a miter.
Cairo divides the length of the miter by the line width.
If the result is greater than the miter limit, the style is
converted to a bevel.

As with the other stroke parameters, the current line miter limit is
examined by cairo_stroke(), and cairo_stroke_extents(), but does not have
any effect during path construction.

The default miter limit value is 10.0, which will convert joins
with interior angles less than 11 degrees to bevels instead of
miters. For reference, a miter limit of 2.0 makes the miter cutoff
at 60 degrees, and a miter limit of 1.414 makes the cutoff at 90
degrees.

A miter limit for a desired angle can be computed as: miter limit =
1/sin(angle/2)</doc>
        <source-position filename="cairo.h" line="862"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="cr" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo.c"
                 line="1378">a cairo context</doc>
            <type name="Context" c:type="cairo_t*"/>
          </instance-parameter>
          <parameter name="limit" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo.c"
                 line="1379">miter limit to set</doc>
            <type name="gdouble" c:type="double"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_operator"
              c:identifier="cairo_set_operator"
              version="1.0">
        <doc xml:space="preserve"
             filename="cairo.c"
             line="812">Sets the compositing operator to be used for all drawing
operations. See #cairo_operator_t for details on the semantics of
each available compositing operator.

The default operator is %CAIRO_OPERATOR_OVER.</doc>
        <source-position filename="cairo.h" line="699"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="cr" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo.c"
                 line="814">a #cairo_t</doc>
            <type name="Context" c:type="cairo_t*"/>
          </instance-parameter>
          <parameter name="op" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo.c"
                 line="815">a compositing operator, specified as a #cairo_operator_t</doc>
            <type name="Operator" c:type="cairo_operator_t"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_scaled_font"
              c:identifier="cairo_set_scaled_font"
              version="1.2">
        <doc xml:space="preserve"
             filename="cairo.c"
             line="3301">Replaces the current font face, font matrix, and font options in
the #cairo_t with those of the #cairo_scaled_font_t.  Except for
some translation, the current CTM of the #cairo_t should be the
same as that of the #cairo_scaled_font_t, which can be accessed
using cairo_scaled_font_get_ctm().</doc>
        <source-position filename="cairo.h" line="1574"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="cr" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo.c"
                 line="3303">a #cairo_t</doc>
            <type name="Context" c:type="cairo_t*"/>
          </instance-parameter>
          <parameter name="scaled_font" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo.c"
                 line="3304">a #cairo_scaled_font_t</doc>
            <type name="ScaledFont" c:type="const cairo_scaled_font_t*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_source" c:identifier="cairo_set_source" version="1.0">
        <doc xml:space="preserve"
             filename="cairo.c"
             line="982">Sets the source pattern within @cr to @source. This pattern
will then be used for any subsequent drawing operation until a new
source pattern is set.

Note: The pattern's transformation matrix will be locked to the
user space in effect at the time of cairo_set_source(). This means
that further modifications of the current transformation matrix
will not affect the source pattern. See cairo_pattern_set_matrix().

The default source pattern is a solid pattern that is opaque black,
(that is, it is equivalent to cairo_set_source_rgb(cr, 0.0, 0.0,
0.0)).</doc>
        <source-position filename="cairo.h" line="702"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="cr" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo.c"
                 line="984">a cairo context</doc>
            <type name="Context" c:type="cairo_t*"/>
          </instance-parameter>
          <parameter name="source" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo.c"
                 line="985">a #cairo_pattern_t to be used as the source for
subsequent drawing operations.</doc>
            <type name="Pattern" c:type="cairo_pattern_t*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_source_rgb"
              c:identifier="cairo_set_source_rgb"
              version="1.0">
        <doc xml:space="preserve"
             filename="cairo.c"
             line="865">Sets the source pattern within @cr to an opaque color. This opaque
color will then be used for any subsequent drawing operation until
a new source pattern is set.

The color components are floating point numbers in the range 0 to
1. If the values passed in are outside that range, they will be
clamped.

The default source pattern is opaque black, (that is, it is
equivalent to cairo_set_source_rgb(cr, 0.0, 0.0, 0.0)).</doc>
        <source-position filename="cairo.h" line="705"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="cr" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo.c"
                 line="867">a cairo context</doc>
            <type name="Context" c:type="cairo_t*"/>
          </instance-parameter>
          <parameter name="red" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo.c"
                 line="868">red component of color</doc>
            <type name="gdouble" c:type="double"/>
          </parameter>
          <parameter name="green" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo.c"
                 line="869">green component of color</doc>
            <type name="gdouble" c:type="double"/>
          </parameter>
          <parameter name="blue" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo.c"
                 line="870">blue component of color</doc>
            <type name="gdouble" c:type="double"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_source_rgba"
              c:identifier="cairo_set_source_rgba"
              version="1.0">
        <doc xml:space="preserve"
             filename="cairo.c"
             line="898">Sets the source pattern within @cr to a translucent color. This
color will then be used for any subsequent drawing operation until
a new source pattern is set.

The color and alpha components are floating point numbers in the
range 0 to 1. If the values passed in are outside that range, they
will be clamped.

Note that the color and alpha values are not premultiplied.

The default source pattern is opaque black, (that is, it is
equivalent to cairo_set_source_rgba(cr, 0.0, 0.0, 0.0, 1.0)).</doc>
        <source-position filename="cairo.h" line="708"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="cr" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo.c"
                 line="900">a cairo context</doc>
            <type name="Context" c:type="cairo_t*"/>
          </instance-parameter>
          <parameter name="red" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo.c"
                 line="901">red component of color</doc>
            <type name="gdouble" c:type="double"/>
          </parameter>
          <parameter name="green" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo.c"
                 line="902">green component of color</doc>
            <type name="gdouble" c:type="double"/>
          </parameter>
          <parameter name="blue" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo.c"
                 line="903">blue component of color</doc>
            <type name="gdouble" c:type="double"/>
          </parameter>
          <parameter name="alpha" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo.c"
                 line="904">alpha component of color</doc>
            <type name="gdouble" c:type="double"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_source_surface"
              c:identifier="cairo_set_source_surface"
              version="1.0">
        <doc xml:space="preserve"
             filename="cairo.c"
             line="936">This is a convenience function for creating a pattern from @surface
and setting it as the source in @cr with cairo_set_source().

The @x and @y parameters give the user-space coordinate at which
the surface origin should appear. (The surface origin is its
upper-left corner before any transformation has been applied.) The
@x and @y parameters are negated and then set as translation values
in the pattern matrix.

Other than the initial translation pattern matrix, as described
above, all other pattern attributes, (such as its extend mode), are
set to the default values as in cairo_pattern_create_for_surface().
The resulting pattern can be queried with cairo_get_source() so
that these attributes can be modified if desired, (eg. to create a
repeating pattern with cairo_pattern_set_extend()).</doc>
        <source-position filename="cairo.h" line="713"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="cr" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo.c"
                 line="938">a cairo context</doc>
            <type name="Context" c:type="cairo_t*"/>
          </instance-parameter>
          <parameter name="surface" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo.c"
                 line="939">a surface to be used to set the source pattern</doc>
            <type name="Surface" c:type="cairo_surface_t*"/>
          </parameter>
          <parameter name="x" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo.c"
                 line="940">User-space X coordinate for surface origin</doc>
            <type name="gdouble" c:type="double"/>
          </parameter>
          <parameter name="y" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo.c"
                 line="941">User-space Y coordinate for surface origin</doc>
            <type name="gdouble" c:type="double"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_tolerance"
              c:identifier="cairo_set_tolerance"
              version="1.0">
        <doc xml:space="preserve"
             filename="cairo.c"
             line="1047">Sets the tolerance used when converting paths into trapezoids.
Curved segments of the path will be subdivided until the maximum
deviation between the original path and the polygonal approximation
is less than @tolerance. The default value is 0.1. A larger
value will give better performance, a smaller value, better
appearance. (Reducing the value from the default value of 0.1
is unlikely to improve appearance significantly.)  The accuracy of paths
within Cairo is limited by the precision of its internal arithmetic, and
the prescribed @tolerance is restricted to the smallest
representable internal value.</doc>
        <source-position filename="cairo.h" line="719"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="cr" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo.c"
                 line="1049">a #cairo_t</doc>
            <type name="Context" c:type="cairo_t*"/>
          </instance-parameter>
          <parameter name="tolerance" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo.c"
                 line="1050">the tolerance, in device units (typically pixels)</doc>
            <type name="gdouble" c:type="double"/>
          </parameter>
        </parameters>
      </method>
      <method name="show_glyphs"
              c:identifier="cairo_show_glyphs"
              version="1.0">
        <doc xml:space="preserve"
             filename="cairo.c"
             line="3613">A drawing operator that generates the shape from an array of glyphs,
rendered according to the current font face, font size
(font matrix), and font options.</doc>
        <source-position filename="cairo.h" line="1584"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="cr" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo.c"
                 line="3615">a cairo context</doc>
            <type name="Context" c:type="cairo_t*"/>
          </instance-parameter>
          <parameter name="glyphs" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo.c"
                 line="3616">array of glyphs to show</doc>
            <type name="Glyph" c:type="const cairo_glyph_t*"/>
          </parameter>
          <parameter name="num_glyphs" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo.c"
                 line="3617">number of glyphs to show</doc>
            <type name="gint" c:type="int"/>
          </parameter>
        </parameters>
      </method>
      <method name="show_page" c:identifier="cairo_show_page" version="1.0">
        <doc xml:space="preserve"
             filename="cairo.c"
             line="2486">Emits and clears the current page for backends that support multiple
pages.  Use cairo_copy_page() if you don't want to clear the page.

This is a convenience function that simply calls
cairo_surface_show_page() on @cr's target.</doc>
        <source-position filename="cairo.h" line="999"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="cr" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo.c"
                 line="2488">a cairo context</doc>
            <type name="Context" c:type="cairo_t*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="show_text" c:identifier="cairo_show_text" version="1.0">
        <doc xml:space="preserve"
             filename="cairo.c"
             line="3494">A drawing operator that generates the shape from a string of UTF-8
characters, rendered according to the current font_face, font_size
(font_matrix), and font_options.

This function first computes a set of glyphs for the string of
text. The first glyph is placed so that its origin is at the
current point. The origin of each subsequent glyph is offset from
that of the previous glyph by the advance values of the previous
glyph.

After this call the current point is moved to the origin of where
the next glyph would be placed in this same progression. That is,
the current point will be at the origin of the final glyph offset
by its advance values. This allows for easy display of a single
logical string with multiple calls to cairo_show_text().

Note: The cairo_show_text() function call is part of what the cairo
designers call the "toy" text API. It is convenient for short demos
and simple programs, but it is not expected to be adequate for
serious text-using applications. See cairo_show_glyphs() for the
"real" text display API in cairo.</doc>
        <source-position filename="cairo.h" line="1581"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="cr" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo.c"
                 line="3496">a cairo context</doc>
            <type name="Context" c:type="cairo_t*"/>
          </instance-parameter>
          <parameter name="utf8" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo.c"
                 line="3497">a NUL-terminated string of text encoded in UTF-8, or %NULL</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </method>
      <method name="show_text_glyphs"
              c:identifier="cairo_show_text_glyphs"
              version="1.8">
        <doc xml:space="preserve"
             filename="cairo.c"
             line="3651">This operation has rendering effects similar to cairo_show_glyphs()
but, if the target surface supports it, uses the provided text and
cluster mapping to embed the text for the glyphs shown in the output.
If the target does not support the extended attributes, this function
acts like the basic cairo_show_glyphs() as if it had been passed
@glyphs and @num_glyphs.

The mapping between @utf8 and @glyphs is provided by an array of
&lt;firstterm&gt;clusters&lt;/firstterm&gt;.  Each cluster covers a number of
text bytes and glyphs, and neighboring clusters cover neighboring
areas of @utf8 and @glyphs.  The clusters should collectively cover @utf8
and @glyphs in entirety.

The first cluster always covers bytes from the beginning of @utf8.
If @cluster_flags do not have the %CAIRO_TEXT_CLUSTER_FLAG_BACKWARD
set, the first cluster also covers the beginning
of @glyphs, otherwise it covers the end of the @glyphs array and
following clusters move backward.

See #cairo_text_cluster_t for constraints on valid clusters.</doc>
        <source-position filename="cairo.h" line="1587"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="cr" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo.c"
                 line="3653">a cairo context</doc>
            <type name="Context" c:type="cairo_t*"/>
          </instance-parameter>
          <parameter name="utf8" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo.c"
                 line="3654">a string of text encoded in UTF-8</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter name="utf8_len" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo.c"
                 line="3655">length of @utf8 in bytes, or -1 if it is NUL-terminated</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="glyphs" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo.c"
                 line="3656">array of glyphs to show</doc>
            <type name="Glyph" c:type="const cairo_glyph_t*"/>
          </parameter>
          <parameter name="num_glyphs" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo.c"
                 line="3657">number of glyphs to show</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="clusters" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo.c"
                 line="3658">array of cluster mapping information</doc>
            <type name="TextCluster" c:type="const cairo_text_cluster_t*"/>
          </parameter>
          <parameter name="num_clusters" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo.c"
                 line="3659">number of clusters in the mapping</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="cluster_flags" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo.c"
                 line="3660">cluster mapping flags</doc>
            <type name="TextClusterFlags" c:type="cairo_text_cluster_flags_t"/>
          </parameter>
        </parameters>
      </method>
      <method name="status" c:identifier="cairo_status" version="1.0">
        <doc xml:space="preserve"
             filename="cairo.c"
             line="4357">Checks whether an error has previously occurred for this context.</doc>
        <source-position filename="cairo.h" line="2261"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cairo.c"
               line="4363">the current status of this context, see #cairo_status_t</doc>
          <type name="Status" c:type="cairo_status_t"/>
        </return-value>
        <parameters>
          <instance-parameter name="cr" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo.c"
                 line="4359">a cairo context</doc>
            <type name="Context" c:type="cairo_t*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="stroke" c:identifier="cairo_stroke" version="1.0">
        <doc xml:space="preserve"
             filename="cairo.c"
             line="2333">A drawing operator that strokes the current path according to the
current line width, line join, line cap, and dash settings. After
cairo_stroke(), the current path will be cleared from the cairo
context. See cairo_set_line_width(), cairo_set_line_join(),
cairo_set_line_cap(), cairo_set_dash(), and
cairo_stroke_preserve().

Note: Degenerate segments and sub-paths are treated specially and
provide a useful result. These can result in two different
situations:

1. Zero-length "on" segments set in cairo_set_dash(). If the cap
style is %CAIRO_LINE_CAP_ROUND or %CAIRO_LINE_CAP_SQUARE then these
segments will be drawn as circular dots or squares respectively. In
the case of %CAIRO_LINE_CAP_SQUARE, the orientation of the squares
is determined by the direction of the underlying path.

2. A sub-path created by cairo_move_to() followed by either a
cairo_close_path() or one or more calls to cairo_line_to() to the
same coordinate as the cairo_move_to(). If the cap style is
%CAIRO_LINE_CAP_ROUND then these sub-paths will be drawn as circular
dots. Note that in the case of %CAIRO_LINE_CAP_SQUARE a degenerate
sub-path will not be drawn at all, (since the correct orientation
is indeterminate).

In no case will a cap style of %CAIRO_LINE_CAP_BUTT cause anything
to be drawn in the case of either degenerate segments or sub-paths.</doc>
        <source-position filename="cairo.h" line="984"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="cr" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo.c"
                 line="2335">a cairo context</doc>
            <type name="Context" c:type="cairo_t*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="stroke_extents"
              c:identifier="cairo_stroke_extents"
              version="1.0">
        <doc xml:space="preserve"
             filename="cairo.c"
             line="2581">Computes a bounding box in user coordinates covering the area that
would be affected, (the "inked" area), by a cairo_stroke()
operation given the current path and stroke parameters.
If the current path is empty, returns an empty rectangle ((0,0), (0,0)).
Surface dimensions and clipping are not taken into account.

Note that if the line width is set to exactly zero, then
cairo_stroke_extents() will return an empty rectangle. Contrast with
cairo_path_extents() which can be used to compute the non-empty
bounds as the line width approaches zero.

Note that cairo_stroke_extents() must necessarily do more work to
compute the precise inked areas in light of the stroke parameters,
so cairo_path_extents() may be more desirable for sake of
performance if non-inked path extents are desired.

See cairo_stroke(), cairo_set_line_width(), cairo_set_line_join(),
cairo_set_line_cap(), cairo_set_dash(), and
cairo_stroke_preserve().</doc>
        <source-position filename="cairo.h" line="1013"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="cr" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo.c"
                 line="2583">a cairo context</doc>
            <type name="Context" c:type="cairo_t*"/>
          </instance-parameter>
          <parameter name="x1" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo.c"
                 line="2584">left of the resulting extents</doc>
            <type name="gdouble" c:type="double*"/>
          </parameter>
          <parameter name="y1" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo.c"
                 line="2585">top of the resulting extents</doc>
            <type name="gdouble" c:type="double*"/>
          </parameter>
          <parameter name="x2" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo.c"
                 line="2586">right of the resulting extents</doc>
            <type name="gdouble" c:type="double*"/>
          </parameter>
          <parameter name="y2" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo.c"
                 line="2587">bottom of the resulting extents</doc>
            <type name="gdouble" c:type="double*"/>
          </parameter>
        </parameters>
      </method>
      <method name="stroke_preserve"
              c:identifier="cairo_stroke_preserve"
              version="1.0">
        <doc xml:space="preserve"
             filename="cairo.c"
             line="2380">A drawing operator that strokes the current path according to the
current line width, line join, line cap, and dash settings. Unlike
cairo_stroke(), cairo_stroke_preserve() preserves the path within the
cairo context.

See cairo_set_line_width(), cairo_set_line_join(),
cairo_set_line_cap(), cairo_set_dash(), and
cairo_stroke_preserve().</doc>
        <source-position filename="cairo.h" line="987"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="cr" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo.c"
                 line="2382">a cairo context</doc>
            <type name="Context" c:type="cairo_t*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="tag_begin" c:identifier="cairo_tag_begin" version="1.16">
        <doc xml:space="preserve"
             filename="cairo.c"
             line="2921">Marks the beginning of the @tag_name structure. Call
cairo_tag_end() with the same @tag_name to mark the end of the
structure.

The attributes string is of the form "key1=value2 key2=value2 ...".
Values may be boolean (true/false or 1/0), integer, float, string,
or an array.

String values are enclosed in single quotes
('). Single quotes and backslashes inside the string should be
escaped with a backslash.

Boolean values may be set to true by only
specifying the key. eg the attribute string "key" is the equivalent
to "key=true".

Arrays are enclosed in '[]'. eg "rect=[1.2 4.3 2.0 3.0]".

If no attributes are required, @attributes can be an empty string or NULL.

See [Tags and Links Description][cairo-Tags-and-Links.description]
for the list of tags and attributes.

Invalid nesting of tags or invalid attributes will cause @cr to
shutdown with a status of %CAIRO_STATUS_TAG_ERROR.

See cairo_tag_end().</doc>
        <source-position filename="cairo.h" line="1083"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="cr" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo.c"
                 line="2923">a cairo context</doc>
            <type name="Context" c:type="cairo_t*"/>
          </instance-parameter>
          <parameter name="tag_name" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo.c"
                 line="2924">tag name</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter name="attributes" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo.c"
                 line="2925">tag attributes</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </method>
      <method name="tag_end" c:identifier="cairo_tag_end" version="1.16">
        <doc xml:space="preserve"
             filename="cairo.c"
             line="2970">Marks the end of the @tag_name structure.

Invalid nesting of tags will cause @cr to shutdown with a status of
%CAIRO_STATUS_TAG_ERROR.

See cairo_tag_begin().</doc>
        <source-position filename="cairo.h" line="1086"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="cr" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo.c"
                 line="2972">a cairo context</doc>
            <type name="Context" c:type="cairo_t*"/>
          </instance-parameter>
          <parameter name="tag_name" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo.c"
                 line="2973">tag name</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </method>
      <method name="text_extents"
              c:identifier="cairo_text_extents"
              version="1.0">
        <doc xml:space="preserve"
             filename="cairo.c"
             line="3368">Gets the extents for a string of text. The extents describe a
user-space rectangle that encloses the "inked" portion of the text,
(as it would be drawn by cairo_show_text()). Additionally, the
x_advance and y_advance values indicate the amount by which the
current point would be advanced by cairo_show_text().

Note that whitespace characters do not directly contribute to the
size of the rectangle (extents.width and extents.height). They do
contribute indirectly by changing the position of non-whitespace
characters. In particular, trailing whitespace characters are
likely to not affect the size of the rectangle, though they will
affect the x_advance and y_advance values.</doc>
        <source-position filename="cairo.h" line="1603"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="cr" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo.c"
                 line="3370">a #cairo_t</doc>
            <type name="Context" c:type="cairo_t*"/>
          </instance-parameter>
          <parameter name="utf8" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo.c"
                 line="3371">a NUL-terminated string of text encoded in UTF-8, or %NULL</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter name="extents" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo.c"
                 line="3372">a #cairo_text_extents_t object into which the results
will be stored</doc>
            <type name="TextExtents" c:type="cairo_text_extents_t*"/>
          </parameter>
        </parameters>
      </method>
      <method name="text_path" c:identifier="cairo_text_path" version="1.0">
        <doc xml:space="preserve"
             filename="cairo.c"
             line="3760">Adds closed paths for text to the current path.  The generated
path if filled, achieves an effect similar to that of
cairo_show_text().

Text conversion and positioning is done similar to cairo_show_text().

Like cairo_show_text(), After this call the current point is
moved to the origin of where the next glyph would be placed in
this same progression.  That is, the current point will be at
the origin of the final glyph offset by its advance values.
This allows for chaining multiple calls to to cairo_text_path()
without having to set current point in between.

Note: The cairo_text_path() function call is part of what the cairo
designers call the "toy" text API. It is convenient for short demos
and simple programs, but it is not expected to be adequate for
serious text-using applications. See cairo_glyph_path() for the
"real" text path API in cairo.</doc>
        <source-position filename="cairo.h" line="1597"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="cr" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo.c"
                 line="3762">a cairo context</doc>
            <type name="Context" c:type="cairo_t*"/>
          </instance-parameter>
          <parameter name="utf8" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo.c"
                 line="3763">a NUL-terminated string of text encoded in UTF-8, or %NULL</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </method>
      <method name="transform" c:identifier="cairo_transform" version="1.0">
        <doc xml:space="preserve"
             filename="cairo.c"
             line="1498">Modifies the current transformation matrix (CTM) by applying
@matrix as an additional transformation. The new transformation of
user space takes place after any existing transformation.</doc>
        <source-position filename="cairo.h" line="874"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="cr" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo.c"
                 line="1500">a cairo context</doc>
            <type name="Context" c:type="cairo_t*"/>
          </instance-parameter>
          <parameter name="matrix" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo.c"
                 line="1501">a transformation to be applied to the user-space axes</doc>
            <type name="Matrix" c:type="const cairo_matrix_t*"/>
          </parameter>
        </parameters>
      </method>
      <method name="translate" c:identifier="cairo_translate" version="1.0">
        <doc xml:space="preserve"
             filename="cairo.c"
             line="1418">Modifies the current transformation matrix (CTM) by translating the
user-space origin by (@tx, @ty). This offset is interpreted as a
user-space coordinate according to the CTM in place before the new
call to cairo_translate(). In other words, the translation of the
user-space origin takes place after any existing transformation.</doc>
        <source-position filename="cairo.h" line="865"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="cr" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo.c"
                 line="1420">a cairo context</doc>
            <type name="Context" c:type="cairo_t*"/>
          </instance-parameter>
          <parameter name="tx" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo.c"
                 line="1421">amount to translate in the X direction</doc>
            <type name="gdouble" c:type="double"/>
          </parameter>
          <parameter name="ty" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo.c"
                 line="1422">amount to translate in the Y direction</doc>
            <type name="gdouble" c:type="double"/>
          </parameter>
        </parameters>
      </method>
      <method name="user_to_device"
              c:identifier="cairo_user_to_device"
              version="1.0">
        <doc xml:space="preserve"
             filename="cairo.c"
             line="1571">Transform a coordinate from user space to device space by
multiplying the given point by the current transformation matrix
(CTM).</doc>
        <source-position filename="cairo.h" line="885"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="cr" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo.c"
                 line="1573">a cairo context</doc>
            <type name="Context" c:type="cairo_t*"/>
          </instance-parameter>
          <parameter name="x" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo.c"
                 line="1574">X value of coordinate (in/out parameter)</doc>
            <type name="gdouble" c:type="double*"/>
          </parameter>
          <parameter name="y" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo.c"
                 line="1575">Y value of coordinate (in/out parameter)</doc>
            <type name="gdouble" c:type="double*"/>
          </parameter>
        </parameters>
      </method>
      <method name="user_to_device_distance"
              c:identifier="cairo_user_to_device_distance"
              version="1.0">
        <doc xml:space="preserve"
             filename="cairo.c"
             line="1592">Transform a distance vector from user space to device space. This
function is similar to cairo_user_to_device() except that the
translation components of the CTM will be ignored when transforming
(@dx,@dy).</doc>
        <source-position filename="cairo.h" line="888"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="cr" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo.c"
                 line="1594">a cairo context</doc>
            <type name="Context" c:type="cairo_t*"/>
          </instance-parameter>
          <parameter name="dx" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo.c"
                 line="1595">X component of a distance vector (in/out parameter)</doc>
            <type name="gdouble" c:type="double*"/>
          </parameter>
          <parameter name="dy" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo.c"
                 line="1596">Y component of a distance vector (in/out parameter)</doc>
            <type name="gdouble" c:type="double*"/>
          </parameter>
        </parameters>
      </method>
    </record>
    <callback name="DestroyFunc" c:type="cairo_destroy_func_t" version="1.0">
      <doc xml:space="preserve"
           filename="cairo.h"
           line="231">#cairo_destroy_func_t the type of function which is called when a
data element is destroyed. It is passed the pointer to the data
element and should free any memory and resources allocated for it.</doc>
      <source-position filename="cairo.h" line="241"/>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="data"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1">
          <doc xml:space="preserve"
               filename="cairo.h"
               line="233">The data element being destroyed.</doc>
          <type name="gpointer" c:type="void*"/>
        </parameter>
      </parameters>
    </callback>
    <record name="Device"
            c:type="cairo_device_t"
            opaque="1"
            version="1.10"
            glib:type-name="cairo_device_t"
            glib:get-type="cairo_gobject_device_get_type"
            c:symbol-prefix="gobject_device">
      <doc xml:space="preserve"
           filename="cairo.h"
           line="166">A #cairo_device_t represents the driver interface for drawing
operations to a #cairo_surface_t.  There are different subtypes of
#cairo_device_t for different drawing backends.

The type of a device can be queried with cairo_device_get_type().

Memory management of #cairo_device_t is done with
cairo_device_reference() and cairo_device_destroy().</doc>
      <source-position filename="cairo.h" line="180"/>
      <method name="acquire"
              c:identifier="cairo_device_acquire"
              version="1.10">
        <doc xml:space="preserve"
             filename="cairo-device.c"
             line="381">Acquires the @device for the current thread. This function will block
until no other thread has acquired the device.

If the return value is %CAIRO_STATUS_SUCCESS, you successfully acquired the
device. From now on your thread owns the device and no other thread will be
able to acquire it until a matching call to cairo_device_release(). It is
allowed to recursively acquire the device multiple times from the same
thread.

&lt;note&gt;&lt;para&gt;You must never acquire two different devices at the same time
unless this is explicitly allowed. Otherwise the possibility of deadlocks
exist.

As various Cairo functions can acquire devices when called, these functions
may also cause deadlocks when you call them with an acquired device. So you
must not have a device acquired when calling them. These functions are
marked in the documentation.
&lt;/para&gt;&lt;/note&gt;</doc>
        <source-position filename="cairo.h" line="2322"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cairo-device.c"
               line="404">%CAIRO_STATUS_SUCCESS on success or an error code if
              the device is in an error state and could not be
              acquired. After a successful call to cairo_device_acquire(),
              a matching call to cairo_device_release() is required.</doc>
          <type name="Status" c:type="cairo_status_t"/>
        </return-value>
        <parameters>
          <instance-parameter name="device" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo-device.c"
                 line="383">a #cairo_device_t</doc>
            <type name="Device" c:type="cairo_device_t*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="destroy"
              c:identifier="cairo_device_destroy"
              version="1.10"
              introspectable="0">
        <doc xml:space="preserve"
             filename="cairo-device.c"
             line="318">Decreases the reference count on @device by one. If the result is
zero, then @device and all associated resources are freed.  See
cairo_device_reference().

This function may acquire devices if the last reference was dropped.</doc>
        <source-position filename="cairo.h" line="2334"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="device" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo-device.c"
                 line="320">a #cairo_device_t</doc>
            <type name="Device" c:type="cairo_device_t*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="finish" c:identifier="cairo_device_finish" version="1.10">
        <doc xml:space="preserve"
             filename="cairo-device.c"
             line="275">This function finishes the device and drops all references to
external resources. All surfaces, fonts and other objects created
for this @device will be finished, too.
Further operations on the @device will not affect the @device but
will instead trigger a %CAIRO_STATUS_DEVICE_FINISHED error.

When the last call to cairo_device_destroy() decreases the
reference count to zero, cairo will call cairo_device_finish() if
it hasn't been called already, before freeing the resources
associated with the device.

This function may acquire devices.</doc>
        <source-position filename="cairo.h" line="2331"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="device" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo-device.c"
                 line="277">the #cairo_device_t to finish</doc>
            <type name="Device" c:type="cairo_device_t*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="flush" c:identifier="cairo_device_flush" version="1.10">
        <doc xml:space="preserve"
             filename="cairo-device.c"
             line="242">Finish any pending operations for the device and also restore any
temporary modifications cairo has made to the device's state.
This function must be called before switching from using the
device with Cairo to operating on it directly with native APIs.
If the device doesn't support direct access, then this function
does nothing.

This function may acquire devices.</doc>
        <source-position filename="cairo.h" line="2328"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="device" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo-device.c"
                 line="244">a #cairo_device_t</doc>
            <type name="Device" c:type="cairo_device_t*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_reference_count"
              c:identifier="cairo_device_get_reference_count"
              version="1.10"
              introspectable="0">
        <doc xml:space="preserve"
             filename="cairo-device.c"
             line="469">Returns the current reference count of @device.</doc>
        <source-position filename="cairo.h" line="2337"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cairo-device.c"
               line="475">the current reference count of @device.  If the
object is a nil object, 0 will be returned.</doc>
          <type name="guint" c:type="unsigned int"/>
        </return-value>
        <parameters>
          <instance-parameter name="device" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo-device.c"
                 line="471">a #cairo_device_t</doc>
            <type name="Device" c:type="cairo_device_t*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_type"
              c:identifier="cairo_device_get_type"
              version="1.10">
        <doc xml:space="preserve"
             filename="cairo-device.c"
             line="358">This function returns the type of the device. See #cairo_device_type_t
for available types.</doc>
        <source-position filename="cairo.h" line="2316"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cairo-device.c"
               line="365">The type of @device.</doc>
          <type name="DeviceType" c:type="cairo_device_type_t"/>
        </return-value>
        <parameters>
          <instance-parameter name="device" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo-device.c"
                 line="360">a #cairo_device_t</doc>
            <type name="Device" c:type="cairo_device_t*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_user_data"
              c:identifier="cairo_device_get_user_data"
              version="1.10">
        <doc xml:space="preserve"
             filename="cairo-device.c"
             line="490">Return user data previously attached to @device using the
specified key.  If no user data has been attached with the given
key this function returns %NULL.</doc>
        <source-position filename="cairo.h" line="2340"/>
        <return-value transfer-ownership="none" nullable="1">
          <doc xml:space="preserve"
               filename="cairo-device.c"
               line="500">the user data previously attached or %NULL.</doc>
          <type name="gpointer" c:type="void*"/>
        </return-value>
        <parameters>
          <instance-parameter name="device" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo-device.c"
                 line="492">a #cairo_device_t</doc>
            <type name="Device" c:type="cairo_device_t*"/>
          </instance-parameter>
          <parameter name="key" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo-device.c"
                 line="493">the address of the #cairo_user_data_key_t the user data was
attached to</doc>
            <type name="UserDataKey" c:type="const cairo_user_data_key_t*"/>
          </parameter>
        </parameters>
      </method>
      <method name="observer_elapsed"
              c:identifier="cairo_device_observer_elapsed"
              version="1.12">
        <doc xml:space="preserve"
             filename="cairo-surface-observer.c"
             line="2153">Returns the total elapsed time of the observation.</doc>
        <source-position filename="cairo.h" line="2459"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cairo-surface-observer.c"
               line="2159">the elapsed time, in nanoseconds.</doc>
          <type name="gdouble" c:type="double"/>
        </return-value>
        <parameters>
          <instance-parameter name="abstract_device" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo-surface-observer.c"
                 line="2155">the observed #cairo_device_t</doc>
            <type name="Device" c:type="cairo_device_t*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="observer_fill_elapsed"
              c:identifier="cairo_device_observer_fill_elapsed"
              version="1.12">
        <doc xml:space="preserve"
             filename="cairo-surface-observer.c"
             line="2228">Returns the elapsed time of the fill operations.</doc>
        <source-position filename="cairo.h" line="2468"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cairo-surface-observer.c"
               line="2234">the elapsed time, in nanoseconds.</doc>
          <type name="gdouble" c:type="double"/>
        </return-value>
        <parameters>
          <instance-parameter name="abstract_device" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo-surface-observer.c"
                 line="2230">the observed #cairo_device_t</doc>
            <type name="Device" c:type="cairo_device_t*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="observer_glyphs_elapsed"
              c:identifier="cairo_device_observer_glyphs_elapsed"
              version="1.12">
        <doc xml:space="preserve"
             filename="cairo-surface-observer.c"
             line="2278">Returns the elapsed time of the glyph operations.</doc>
        <source-position filename="cairo.h" line="2474"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cairo-surface-observer.c"
               line="2284">the elapsed time, in nanoseconds.</doc>
          <type name="gdouble" c:type="double"/>
        </return-value>
        <parameters>
          <instance-parameter name="abstract_device" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo-surface-observer.c"
                 line="2280">the observed #cairo_device_t</doc>
            <type name="Device" c:type="cairo_device_t*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="observer_mask_elapsed"
              c:identifier="cairo_device_observer_mask_elapsed"
              version="1.12">
        <doc xml:space="preserve"
             filename="cairo-surface-observer.c"
             line="2203">Returns the elapsed time of the mask operations.</doc>
        <source-position filename="cairo.h" line="2465"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cairo-surface-observer.c"
               line="2209">the elapsed time, in nanoseconds</doc>
          <type name="gdouble" c:type="double"/>
        </return-value>
        <parameters>
          <instance-parameter name="abstract_device" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo-surface-observer.c"
                 line="2205">the observed #cairo_device_t</doc>
            <type name="Device" c:type="cairo_device_t*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="observer_paint_elapsed"
              c:identifier="cairo_device_observer_paint_elapsed"
              version="1.12">
        <doc xml:space="preserve"
             filename="cairo-surface-observer.c"
             line="2178">Returns the elapsed time of the paint operations.</doc>
        <source-position filename="cairo.h" line="2462"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cairo-surface-observer.c"
               line="2184">the elapsed time, in nanoseconds.</doc>
          <type name="gdouble" c:type="double"/>
        </return-value>
        <parameters>
          <instance-parameter name="abstract_device" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo-surface-observer.c"
                 line="2180">the observed #cairo_device_t</doc>
            <type name="Device" c:type="cairo_device_t*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="observer_print"
              c:identifier="cairo_device_observer_print"
              version="1.12">
        <doc xml:space="preserve"
             filename="cairo-surface-observer.c"
             line="2120">Prints the device log using the given function.</doc>
        <source-position filename="cairo.h" line="2454"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cairo-surface-observer.c"
               line="2128">the status after the operation</doc>
          <type name="Status" c:type="cairo_status_t"/>
        </return-value>
        <parameters>
          <instance-parameter name="abstract_device" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo-surface-observer.c"
                 line="2122">the observed #cairo_device_t</doc>
            <type name="Device" c:type="cairo_device_t*"/>
          </instance-parameter>
          <parameter name="write_func" transfer-ownership="none" scope="call">
            <doc xml:space="preserve"
                 filename="cairo-surface-observer.c"
                 line="2123">the write function</doc>
            <type name="WriteFunc" c:type="cairo_write_func_t"/>
          </parameter>
          <parameter name="closure"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve"
                 filename="cairo-surface-observer.c"
                 line="2124">data to pass to the @write_func</doc>
            <type name="gpointer" c:type="void*"/>
          </parameter>
        </parameters>
      </method>
      <method name="observer_stroke_elapsed"
              c:identifier="cairo_device_observer_stroke_elapsed"
              version="1.12">
        <doc xml:space="preserve"
             filename="cairo-surface-observer.c"
             line="2253">Returns the elapsed time of the stroke operations.</doc>
        <source-position filename="cairo.h" line="2471"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cairo-surface-observer.c"
               line="2259">the elapsed time, in nanoseconds.</doc>
          <type name="gdouble" c:type="double"/>
        </return-value>
        <parameters>
          <instance-parameter name="abstract_device" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo-surface-observer.c"
                 line="2255">the observed #cairo_device_t</doc>
            <type name="Device" c:type="cairo_device_t*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="reference"
              c:identifier="cairo_device_reference"
              version="1.10"
              introspectable="0">
        <doc xml:space="preserve"
             filename="cairo-device.c"
             line="191">Increases the reference count on @device by one. This prevents
@device from being destroyed until a matching call to
cairo_device_destroy() is made.

Use cairo_device_get_reference_count() to get the number of references
to a #cairo_device_t.</doc>
        <source-position filename="cairo.h" line="2269"/>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve"
               filename="cairo-device.c"
               line="202">the referenced #cairo_device_t.</doc>
          <type name="Device" c:type="cairo_device_t*"/>
        </return-value>
        <parameters>
          <instance-parameter name="device" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo-device.c"
                 line="193">a #cairo_device_t</doc>
            <type name="Device" c:type="cairo_device_t*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="release"
              c:identifier="cairo_device_release"
              version="1.10">
        <doc xml:space="preserve"
             filename="cairo-device.c"
             line="432">Releases a @device previously acquired using cairo_device_acquire(). See
that function for details.</doc>
        <source-position filename="cairo.h" line="2325"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="device" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo-device.c"
                 line="434">a #cairo_device_t</doc>
            <type name="Device" c:type="cairo_device_t*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="set_user_data"
              c:identifier="cairo_device_set_user_data"
              version="1.10"
              introspectable="0">
        <doc xml:space="preserve"
             filename="cairo-device.c"
             line="512">Attach user data to @device.  To remove user data from a surface,
call this function with the key that was used to set it and %NULL
for @data.</doc>
        <source-position filename="cairo.h" line="2344"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cairo-device.c"
               line="525">%CAIRO_STATUS_SUCCESS or %CAIRO_STATUS_NO_MEMORY if a
slot could not be allocated for the user data.</doc>
          <type name="Status" c:type="cairo_status_t"/>
        </return-value>
        <parameters>
          <instance-parameter name="device" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo-device.c"
                 line="514">a #cairo_device_t</doc>
            <type name="Device" c:type="cairo_device_t*"/>
          </instance-parameter>
          <parameter name="key" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo-device.c"
                 line="515">the address of a #cairo_user_data_key_t to attach the user data to</doc>
            <type name="UserDataKey" c:type="const cairo_user_data_key_t*"/>
          </parameter>
          <parameter name="user_data"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve"
                 filename="cairo-device.c"
                 line="516">the user data to attach to the #cairo_device_t</doc>
            <type name="gpointer" c:type="void*"/>
          </parameter>
          <parameter name="destroy" transfer-ownership="none" scope="async">
            <doc xml:space="preserve"
                 filename="cairo-device.c"
                 line="517">a #cairo_destroy_func_t which will be called when the
#cairo_t is destroyed or when new user data is attached using the
same key.</doc>
            <type name="DestroyFunc" c:type="cairo_destroy_func_t"/>
          </parameter>
        </parameters>
      </method>
      <method name="status" c:identifier="cairo_device_status" version="1.10">
        <doc xml:space="preserve"
             filename="cairo-device.c"
             line="221">Checks whether an error has previously occurred for this
device.</doc>
        <source-position filename="cairo.h" line="2319"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cairo-device.c"
               line="228">%CAIRO_STATUS_SUCCESS on success or an error code if
              the device is in an error state.</doc>
          <type name="Status" c:type="cairo_status_t"/>
        </return-value>
        <parameters>
          <instance-parameter name="device" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo-device.c"
                 line="223">a #cairo_device_t</doc>
            <type name="Device" c:type="cairo_device_t*"/>
          </instance-parameter>
        </parameters>
      </method>
    </record>
    <enumeration name="DeviceType"
                 version="1.10"
                 glib:type-name="cairo_device_type_t"
                 glib:get-type="cairo_gobject_device_type_get_type"
                 c:type="cairo_device_type_t">
      <doc xml:space="preserve"
           filename="cairo.h"
           line="2271">#cairo_device_type_t is used to describe the type of a given
device. The devices types are also known as "backends" within cairo.

The device type can be queried with cairo_device_get_type()

The various #cairo_device_t functions can be used with devices of
any type, but some backends also provide type-specific functions
that must only be called with a device of the appropriate
type. These functions have names that begin with
&lt;literal&gt;cairo_&lt;emphasis&gt;type&lt;/emphasis&gt;_device&lt;/literal&gt; such as
cairo_xcb_device_debug_cap_xrender_version().

The behavior of calling a type-specific function with a device of
the wrong type is undefined.

New entries may be added in future versions.</doc>
      <member name="drm"
              value="0"
              c:identifier="CAIRO_DEVICE_TYPE_DRM"
              glib:nick="drm"
              glib:name="CAIRO_DEVICE_TYPE_DRM">
        <doc xml:space="preserve"
             filename="cairo.h"
             line="2273">The device is of type Direct Render Manager, since 1.10</doc>
      </member>
      <member name="gl"
              value="1"
              c:identifier="CAIRO_DEVICE_TYPE_GL"
              glib:nick="gl"
              glib:name="CAIRO_DEVICE_TYPE_GL">
        <doc xml:space="preserve"
             filename="cairo.h"
             line="2274">The device is of type OpenGL, since 1.10</doc>
      </member>
      <member name="script"
              value="2"
              c:identifier="CAIRO_DEVICE_TYPE_SCRIPT"
              glib:nick="script"
              glib:name="CAIRO_DEVICE_TYPE_SCRIPT">
        <doc xml:space="preserve"
             filename="cairo.h"
             line="2275">The device is of type script, since 1.10</doc>
      </member>
      <member name="xcb"
              value="3"
              c:identifier="CAIRO_DEVICE_TYPE_XCB"
              glib:nick="xcb"
              glib:name="CAIRO_DEVICE_TYPE_XCB">
        <doc xml:space="preserve"
             filename="cairo.h"
             line="2276">The device is of type xcb, since 1.10</doc>
      </member>
      <member name="xlib"
              value="4"
              c:identifier="CAIRO_DEVICE_TYPE_XLIB"
              glib:nick="xlib"
              glib:name="CAIRO_DEVICE_TYPE_XLIB">
        <doc xml:space="preserve"
             filename="cairo.h"
             line="2277">The device is of type xlib, since 1.10</doc>
      </member>
      <member name="xml"
              value="5"
              c:identifier="CAIRO_DEVICE_TYPE_XML"
              glib:nick="xml"
              glib:name="CAIRO_DEVICE_TYPE_XML">
        <doc xml:space="preserve"
             filename="cairo.h"
             line="2278">The device is of type XML, since 1.10</doc>
      </member>
    </enumeration>
    <enumeration name="Dither" version="1.18" c:type="cairo_dither_t">
      <doc xml:space="preserve"
           filename="cairo.h"
           line="443">Dither is an intentionally applied form of noise used to randomize
quantization error, preventing large-scale patterns such as color banding
in images (e.g. for gradients). Ordered dithering applies a precomputed
threshold matrix to spread the errors smoothly.

 #cairo_dither_t is modeled on pixman dithering algorithm choice.
As of Pixman 0.40, FAST corresponds to a 8x8 ordered bayer noise and GOOD
and BEST use an ordered 64x64 precomputed blue noise.</doc>
      <source-position filename="cairo.h" line="468"/>
      <member name="none" value="0" c:identifier="CAIRO_DITHER_NONE">
        <doc xml:space="preserve"
             filename="cairo.h"
             line="445">No dithering.</doc>
      </member>
      <member name="default" value="1" c:identifier="CAIRO_DITHER_DEFAULT">
        <doc xml:space="preserve"
             filename="cairo.h"
             line="446">Default choice at cairo compile time. Currently NONE.</doc>
      </member>
      <member name="fast" value="2" c:identifier="CAIRO_DITHER_FAST">
        <doc xml:space="preserve"
             filename="cairo.h"
             line="447">Fastest dithering algorithm supported by the backend</doc>
      </member>
      <member name="good" value="3" c:identifier="CAIRO_DITHER_GOOD">
        <doc xml:space="preserve"
             filename="cairo.h"
             line="448">An algorithm with smoother dithering than FAST</doc>
      </member>
      <member name="best" value="4" c:identifier="CAIRO_DITHER_BEST">
        <doc xml:space="preserve"
             filename="cairo.h"
             line="449">Best algorithm available in the backend</doc>
      </member>
    </enumeration>
    <enumeration name="Extend"
                 version="1.0"
                 glib:type-name="cairo_extend_t"
                 glib:get-type="cairo_gobject_extend_get_type"
                 c:type="cairo_extend_t">
      <doc xml:space="preserve"
           filename="cairo.h"
           line="3051">#cairo_extend_t is used to describe how pattern color/alpha will be
determined for areas "outside" the pattern's natural area, (for
example, outside the surface bounds or outside the gradient
geometry).

Mesh patterns are not affected by the extend mode.

The default extend mode is %CAIRO_EXTEND_NONE for surface patterns
and %CAIRO_EXTEND_PAD for gradient patterns.

New entries may be added in future versions.</doc>
      <member name="none"
              value="0"
              c:identifier="CAIRO_EXTEND_NONE"
              glib:nick="none"
              glib:name="CAIRO_EXTEND_NONE">
        <doc xml:space="preserve"
             filename="cairo.h"
             line="3053">pixels outside of the source pattern
  are fully transparent (Since 1.0)</doc>
      </member>
      <member name="repeat"
              value="1"
              c:identifier="CAIRO_EXTEND_REPEAT"
              glib:nick="repeat"
              glib:name="CAIRO_EXTEND_REPEAT">
        <doc xml:space="preserve"
             filename="cairo.h"
             line="3055">the pattern is tiled by repeating (Since 1.0)</doc>
      </member>
      <member name="reflect"
              value="2"
              c:identifier="CAIRO_EXTEND_REFLECT"
              glib:nick="reflect"
              glib:name="CAIRO_EXTEND_REFLECT">
        <doc xml:space="preserve"
             filename="cairo.h"
             line="3056">the pattern is tiled by reflecting
  at the edges (Since 1.0; but only implemented for surface patterns since 1.6)</doc>
      </member>
      <member name="pad"
              value="3"
              c:identifier="CAIRO_EXTEND_PAD"
              glib:nick="pad"
              glib:name="CAIRO_EXTEND_PAD">
        <doc xml:space="preserve"
             filename="cairo.h"
             line="3058">pixels outside of the pattern copy
  the closest pixel from the source (Since 1.2; but only
  implemented for surface patterns since 1.6)</doc>
      </member>
    </enumeration>
    <enumeration name="FillRule"
                 version="1.0"
                 glib:type-name="cairo_fill_rule_t"
                 glib:get-type="cairo_gobject_fill_rule_get_type"
                 c:type="cairo_fill_rule_t">
      <doc xml:space="preserve"
           filename="cairo.h"
           line="769">#cairo_fill_rule_t is used to select how paths are filled. For both
fill rules, whether or not a point is included in the fill is
determined by taking a ray from that point to infinity and looking
at intersections with the path. The ray can be in any direction,
as long as it doesn't pass through the end point of a segment
or have a tricky intersection such as intersecting tangent to the path.
(Note that filling is not actually implemented in this way. This
is just a description of the rule that is applied.)

The default fill rule is %CAIRO_FILL_RULE_WINDING.

New entries may be added in future versions.</doc>
      <member name="winding"
              value="0"
              c:identifier="CAIRO_FILL_RULE_WINDING"
              glib:nick="winding"
              glib:name="CAIRO_FILL_RULE_WINDING">
        <doc xml:space="preserve"
             filename="cairo.h"
             line="771">If the path crosses the ray from
left-to-right, counts +1. If the path crosses the ray
from right to left, counts -1. (Left and right are determined
from the perspective of looking along the ray from the starting
point.) If the total count is non-zero, the point will be filled. (Since 1.0)</doc>
      </member>
      <member name="even_odd"
              value="1"
              c:identifier="CAIRO_FILL_RULE_EVEN_ODD"
              glib:nick="even-odd"
              glib:name="CAIRO_FILL_RULE_EVEN_ODD">
        <doc xml:space="preserve"
             filename="cairo.h"
             line="776">Counts the total number of
intersections, without regard to the orientation of the contour. If
the total number of intersections is odd, the point will be
filled. (Since 1.0)</doc>
      </member>
    </enumeration>
    <enumeration name="Filter"
                 version="1.0"
                 glib:type-name="cairo_filter_t"
                 glib:get-type="cairo_gobject_filter_get_type"
                 c:type="cairo_filter_t">
      <doc xml:space="preserve"
           filename="cairo.h"
           line="3089">#cairo_filter_t is used to indicate what filtering should be
applied when reading pixel values from patterns. See
cairo_pattern_set_filter() for indicating the desired filter to be
used with a particular pattern.</doc>
      <member name="fast"
              value="0"
              c:identifier="CAIRO_FILTER_FAST"
              glib:nick="fast"
              glib:name="CAIRO_FILTER_FAST">
        <doc xml:space="preserve"
             filename="cairo.h"
             line="3091">A high-performance filter, with quality similar
    to %CAIRO_FILTER_NEAREST (Since 1.0)</doc>
      </member>
      <member name="good"
              value="1"
              c:identifier="CAIRO_FILTER_GOOD"
              glib:nick="good"
              glib:name="CAIRO_FILTER_GOOD">
        <doc xml:space="preserve"
             filename="cairo.h"
             line="3093">A reasonable-performance filter, with quality
    similar to %CAIRO_FILTER_BILINEAR (Since 1.0)</doc>
      </member>
      <member name="best"
              value="2"
              c:identifier="CAIRO_FILTER_BEST"
              glib:nick="best"
              glib:name="CAIRO_FILTER_BEST">
        <doc xml:space="preserve"
             filename="cairo.h"
             line="3095">The highest-quality available, performance may
    not be suitable for interactive use. (Since 1.0)</doc>
      </member>
      <member name="nearest"
              value="3"
              c:identifier="CAIRO_FILTER_NEAREST"
              glib:nick="nearest"
              glib:name="CAIRO_FILTER_NEAREST">
        <doc xml:space="preserve"
             filename="cairo.h"
             line="3097">Nearest-neighbor filtering (Since 1.0)</doc>
      </member>
      <member name="bilinear"
              value="4"
              c:identifier="CAIRO_FILTER_BILINEAR"
              glib:nick="bilinear"
              glib:name="CAIRO_FILTER_BILINEAR">
        <doc xml:space="preserve"
             filename="cairo.h"
             line="3098">Linear interpolation in two dimensions (Since 1.0)</doc>
      </member>
      <member name="gaussian"
              value="5"
              c:identifier="CAIRO_FILTER_GAUSSIAN"
              glib:nick="gaussian"
              glib:name="CAIRO_FILTER_GAUSSIAN">
        <doc xml:space="preserve"
             filename="cairo.h"
             line="3099">This filter value is currently
    unimplemented, and should not be used in current code. (Since 1.0)</doc>
      </member>
    </enumeration>
    <record name="FontExtents" c:type="cairo_font_extents_t" version="1.0">
      <doc xml:space="preserve"
           filename="cairo.h"
           line="1250">The #cairo_font_extents_t structure stores metric information for
a font. Values are given in the current user-space coordinate
system.

Because font metrics are in user-space coordinates, they are
mostly, but not entirely, independent of the current transformation
matrix. If you call &lt;literal&gt;cairo_scale(cr, 2.0, 2.0)&lt;/literal&gt;,
text will be drawn twice as big, but the reported text extents will
not be doubled. They will change slightly due to hinting (so you
can't assume that metrics are independent of the transformation
matrix), but otherwise will remain unchanged.</doc>
      <source-position filename="cairo.h" line="1299"/>
      <field name="ascent" writable="1">
        <doc xml:space="preserve"
             filename="cairo.h"
             line="1252">the distance that the font extends above the baseline.
         Note that this is not always exactly equal to the maximum
         of the extents of all the glyphs in the font, but rather
         is picked to express the font designer's intent as to
         how the font should align with elements above it.</doc>
        <type name="gdouble" c:type="double"/>
      </field>
      <field name="descent" writable="1">
        <doc xml:space="preserve"
             filename="cairo.h"
             line="1257">the distance that the font extends below the baseline.
          This value is positive for typical fonts that include
          portions below the baseline. Note that this is not always
          exactly equal to the maximum of the extents of all the
          glyphs in the font, but rather is picked to express the
          font designer's intent as to how the font should
          align with elements below it.</doc>
        <type name="gdouble" c:type="double"/>
      </field>
      <field name="height" writable="1">
        <doc xml:space="preserve"
             filename="cairo.h"
             line="1264">the recommended vertical distance between baselines when
         setting consecutive lines of text with the font. This
         is greater than @ascent+@descent by a
         quantity known as the &lt;firstterm&gt;line spacing&lt;/firstterm&gt;
         or &lt;firstterm&gt;external leading&lt;/firstterm&gt;. When space
         is at a premium, most fonts can be set with only
         a distance of @ascent+@descent between lines.</doc>
        <type name="gdouble" c:type="double"/>
      </field>
      <field name="max_x_advance" writable="1">
        <doc xml:space="preserve"
             filename="cairo.h"
             line="1271">the maximum distance in the X direction that
        the origin is advanced for any glyph in the font.</doc>
        <type name="gdouble" c:type="double"/>
      </field>
      <field name="max_y_advance" writable="1">
        <doc xml:space="preserve"
             filename="cairo.h"
             line="1273">the maximum distance in the Y direction that
        the origin is advanced for any glyph in the font.
        This will be zero for normal fonts used for horizontal
        writing. (The scripts of East Asia are sometimes written
        vertically.)</doc>
        <type name="gdouble" c:type="double"/>
      </field>
    </record>
    <record name="FontFace"
            c:type="cairo_font_face_t"
            opaque="1"
            version="1.0"
            glib:type-name="cairo_font_face_t"
            glib:get-type="cairo_gobject_font_face_get_type"
            c:symbol-prefix="gobject_font_face">
      <doc xml:space="preserve"
           filename="cairo.h"
           line="1109">A #cairo_font_face_t specifies all aspects of a font other
than the size or font matrix (a font matrix is used to distort
a font by shearing it or scaling it unequally in the two
directions) . A font face can be set on a #cairo_t by using
cairo_set_font_face(); the size and font matrix are set with
cairo_set_font_size() and cairo_set_font_matrix().

There are various types of font faces, depending on the
&lt;firstterm&gt;font backend&lt;/firstterm&gt; they use. The type of a
font face can be queried using cairo_font_face_get_type().

Memory management of #cairo_font_face_t is done with
cairo_font_face_reference() and cairo_font_face_destroy().</doc>
      <source-position filename="cairo.h" line="1128"/>
      <method name="destroy"
              c:identifier="cairo_font_face_destroy"
              version="1.0"
              introspectable="0">
        <doc xml:space="preserve"
             filename="cairo-font-face.c"
             line="159">Decreases the reference count on @font_face by one. If the result
is zero, then @font_face and all associated resources are freed.
See cairo_font_face_reference().</doc>
        <source-position filename="cairo.h" line="1623"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="font_face" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo-font-face.c"
                 line="161">a #cairo_font_face_t</doc>
            <type name="FontFace" c:type="cairo_font_face_t*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_reference_count"
              c:identifier="cairo_font_face_get_reference_count"
              version="1.4"
              introspectable="0">
        <doc xml:space="preserve"
             filename="cairo-font-face.c"
             line="213">Returns the current reference count of @font_face.</doc>
        <source-position filename="cairo.h" line="1626"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cairo-font-face.c"
               line="219">the current reference count of @font_face.  If the
object is a nil object, 0 will be returned.</doc>
          <type name="guint" c:type="unsigned int"/>
        </return-value>
        <parameters>
          <instance-parameter name="font_face" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo-font-face.c"
                 line="215">a #cairo_font_face_t</doc>
            <type name="FontFace" c:type="cairo_font_face_t*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_type"
              c:identifier="cairo_font_face_get_type"
              version="1.2">
        <doc xml:space="preserve"
             filename="cairo-font-face.c"
             line="193">This function returns the type of the backend used to create
a font face. See #cairo_font_type_t for available types.</doc>
        <source-position filename="cairo.h" line="1682"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cairo-font-face.c"
               line="200">The type of @font_face.</doc>
          <type name="FontType" c:type="cairo_font_type_t"/>
        </return-value>
        <parameters>
          <instance-parameter name="font_face" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo-font-face.c"
                 line="195">a font face</doc>
            <type name="FontFace" c:type="cairo_font_face_t*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_user_data"
              c:identifier="cairo_font_face_get_user_data"
              version="1.0">
        <doc xml:space="preserve"
             filename="cairo-font-face.c"
             line="252">Return user data previously attached to @font_face using the specified
key.  If no user data has been attached with the given key this
function returns %NULL.</doc>
        <source-position filename="cairo.h" line="1685"/>
        <return-value transfer-ownership="none" nullable="1">
          <doc xml:space="preserve"
               filename="cairo-font-face.c"
               line="262">the user data previously attached or %NULL.</doc>
          <type name="gpointer" c:type="void*"/>
        </return-value>
        <parameters>
          <instance-parameter name="font_face" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo-font-face.c"
                 line="254">a #cairo_font_face_t</doc>
            <type name="FontFace" c:type="cairo_font_face_t*"/>
          </instance-parameter>
          <parameter name="key" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo-font-face.c"
                 line="255">the address of the #cairo_user_data_key_t the user data was
attached to</doc>
            <type name="UserDataKey" c:type="const cairo_user_data_key_t*"/>
          </parameter>
        </parameters>
      </method>
      <method name="reference"
              c:identifier="cairo_font_face_reference"
              version="1.0"
              introspectable="0">
        <doc xml:space="preserve"
             filename="cairo-font-face.c"
             line="105">Increases the reference count on @font_face by one. This prevents
@font_face from being destroyed until a matching call to
cairo_font_face_destroy() is made.

Use cairo_font_face_get_reference_count() to get the number of
references to a #cairo_font_face_t.</doc>
        <source-position filename="cairo.h" line="1620"/>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve"
               filename="cairo-font-face.c"
               line="117">the referenced #cairo_font_face_t.</doc>
          <type name="FontFace" c:type="cairo_font_face_t*"/>
        </return-value>
        <parameters>
          <instance-parameter name="font_face" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo-font-face.c"
                 line="107">a #cairo_font_face_t, (may be %NULL in which case this
function does nothing).</doc>
            <type name="FontFace" c:type="cairo_font_face_t*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="set_user_data"
              c:identifier="cairo_font_face_set_user_data"
              version="1.0"
              introspectable="0">
        <doc xml:space="preserve"
             filename="cairo-font-face.c"
             line="274">Attach user data to @font_face.  To remove user data from a font face,
call this function with the key that was used to set it and %NULL
for @data.</doc>
        <source-position filename="cairo.h" line="1689"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cairo-font-face.c"
               line="287">%CAIRO_STATUS_SUCCESS or %CAIRO_STATUS_NO_MEMORY if a
slot could not be allocated for the user data.</doc>
          <type name="Status" c:type="cairo_status_t"/>
        </return-value>
        <parameters>
          <instance-parameter name="font_face" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo-font-face.c"
                 line="276">a #cairo_font_face_t</doc>
            <type name="FontFace" c:type="cairo_font_face_t*"/>
          </instance-parameter>
          <parameter name="key" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo-font-face.c"
                 line="277">the address of a #cairo_user_data_key_t to attach the user data to</doc>
            <type name="UserDataKey" c:type="const cairo_user_data_key_t*"/>
          </parameter>
          <parameter name="user_data"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve"
                 filename="cairo-font-face.c"
                 line="278">the user data to attach to the font face</doc>
            <type name="gpointer" c:type="void*"/>
          </parameter>
          <parameter name="destroy" transfer-ownership="none" scope="async">
            <doc xml:space="preserve"
                 filename="cairo-font-face.c"
                 line="279">a #cairo_destroy_func_t which will be called when the
font face is destroyed or when new user data is attached using the
same key.</doc>
            <type name="DestroyFunc" c:type="cairo_destroy_func_t"/>
          </parameter>
        </parameters>
      </method>
      <method name="status"
              c:identifier="cairo_font_face_status"
              version="1.0">
        <doc xml:space="preserve"
             filename="cairo-font-face.c"
             line="234">Checks whether an error has previously occurred for this
font face</doc>
        <source-position filename="cairo.h" line="1629"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cairo-font-face.c"
               line="241">%CAIRO_STATUS_SUCCESS or another error such as
  %CAIRO_STATUS_NO_MEMORY.</doc>
          <type name="Status" c:type="cairo_status_t"/>
        </return-value>
        <parameters>
          <instance-parameter name="font_face" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo-font-face.c"
                 line="236">a #cairo_font_face_t</doc>
            <type name="FontFace" c:type="cairo_font_face_t*"/>
          </instance-parameter>
        </parameters>
      </method>
    </record>
    <record name="FontOptions"
            c:type="cairo_font_options_t"
            opaque="1"
            version="1.0"
            glib:type-name="cairo_font_options_t"
            glib:get-type="cairo_gobject_font_options_get_type"
            c:symbol-prefix="gobject_font_options">
      <doc xml:space="preserve"
           filename="cairo.h"
           line="1434">An opaque structure holding all options that are used when
rendering fonts.

Individual features of a #cairo_font_options_t can be set or
accessed using functions named
&lt;function&gt;cairo_font_options_set_&lt;emphasis&gt;feature_name&lt;/emphasis&gt;()&lt;/function&gt; and
&lt;function&gt;cairo_font_options_get_&lt;emphasis&gt;feature_name&lt;/emphasis&gt;()&lt;/function&gt;, like
cairo_font_options_set_antialias() and
cairo_font_options_get_antialias().

New features may be added to a #cairo_font_options_t in the
future.  For this reason, cairo_font_options_copy(),
cairo_font_options_equal(), cairo_font_options_merge(), and
cairo_font_options_hash() should be used to copy, check
for equality, merge, or compute a hash value of
#cairo_font_options_t objects.</doc>
      <source-position filename="cairo.h" line="1456"/>
      <method name="copy" c:identifier="cairo_font_options_copy" version="1.0">
        <doc xml:space="preserve"
             filename="cairo-font-options.c"
             line="173">Allocates a new font options object copying the option values from
 @original.</doc>
        <source-position filename="cairo.h" line="1462"/>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve"
               filename="cairo-font-options.c"
               line="180">a newly allocated #cairo_font_options_t. Free with
  cairo_font_options_destroy(). This function always returns a
  valid pointer; if memory cannot be allocated, then a special
  error object is returned where all operations on the object do nothing.
  You can check for this with cairo_font_options_status().</doc>
          <type name="FontOptions" c:type="cairo_font_options_t*"/>
        </return-value>
        <parameters>
          <instance-parameter name="original" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo-font-options.c"
                 line="175">a #cairo_font_options_t</doc>
            <type name="FontOptions" c:type="const cairo_font_options_t*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="destroy"
              c:identifier="cairo_font_options_destroy"
              version="1.0"
              introspectable="0">
        <doc xml:space="preserve"
             filename="cairo-font-options.c"
             line="214">Destroys a #cairo_font_options_t object created with
cairo_font_options_create() or cairo_font_options_copy().</doc>
        <source-position filename="cairo.h" line="1465"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="options" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo-font-options.c"
                 line="216">a #cairo_font_options_t</doc>
            <type name="FontOptions" c:type="cairo_font_options_t*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="equal"
              c:identifier="cairo_font_options_equal"
              version="1.0">
        <doc xml:space="preserve"
             filename="cairo-font-options.c"
             line="321">Compares two font options objects for equality.</doc>
        <source-position filename="cairo.h" line="1474"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cairo-font-options.c"
               line="328">%TRUE if all fields of the two font options objects match.
Note that this function will return %FALSE if either object is in
error.</doc>
          <type name="Bool" c:type="cairo_bool_t"/>
        </return-value>
        <parameters>
          <instance-parameter name="options" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo-font-options.c"
                 line="323">a #cairo_font_options_t</doc>
            <type name="FontOptions" c:type="const cairo_font_options_t*"/>
          </instance-parameter>
          <parameter name="other" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo-font-options.c"
                 line="324">another #cairo_font_options_t</doc>
            <type name="FontOptions" c:type="const cairo_font_options_t*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_antialias"
              c:identifier="cairo_font_options_get_antialias"
              version="1.0">
        <doc xml:space="preserve"
             filename="cairo-font-options.c"
             line="419">Gets the antialiasing mode for the font options object.</doc>
        <source-position filename="cairo.h" line="1484"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cairo-font-options.c"
               line="425">the antialiasing mode</doc>
          <type name="Antialias" c:type="cairo_antialias_t"/>
        </return-value>
        <parameters>
          <instance-parameter name="options" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo-font-options.c"
                 line="421">a #cairo_font_options_t</doc>
            <type name="FontOptions" c:type="const cairo_font_options_t*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_color_mode"
              c:identifier="cairo_font_options_get_color_mode"
              version="1.18">
        <doc xml:space="preserve"
             filename="cairo-font-options.c"
             line="710">Gets the color mode for the font options object.
See the documentation for #cairo_color_mode_t for full details.</doc>
        <source-position filename="cairo.h" line="1518"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cairo-font-options.c"
               line="717">the color mode for the font options object</doc>
          <type name="ColorMode" c:type="cairo_color_mode_t"/>
        </return-value>
        <parameters>
          <instance-parameter name="options" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo-font-options.c"
                 line="712">a #cairo_font_options_t</doc>
            <type name="FontOptions" c:type="const cairo_font_options_t*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_color_palette"
              c:identifier="cairo_font_options_get_color_palette"
              version="1.18">
        <doc xml:space="preserve"
             filename="cairo-font-options.c"
             line="764">Gets the current OpenType color font palette for the font options object.</doc>
        <source-position filename="cairo.h" line="1521"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cairo-font-options.c"
               line="770">the palette index</doc>
          <type name="guint" c:type="unsigned int"/>
        </return-value>
        <parameters>
          <instance-parameter name="options" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo-font-options.c"
                 line="766">a #cairo_font_options_t</doc>
            <type name="FontOptions" c:type="const cairo_font_options_t*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_custom_palette_color"
              c:identifier="cairo_font_options_get_custom_palette_color"
              version="1.18">
        <doc xml:space="preserve"
             filename="cairo-font-options.c"
             line="835">Gets the custom palette color for the color index for the font options object.</doc>
        <source-position filename="cairo.h" line="1534"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cairo-font-options.c"
               line="846">`CAIRO_STATUS_SUCCESS` if a custom palette color is
returned, `CAIRO_STATUS_INVALID_INDEX` if no custom color exists
for the color index.</doc>
          <type name="Status" c:type="cairo_status_t"/>
        </return-value>
        <parameters>
          <instance-parameter name="options" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo-font-options.c"
                 line="837">a #cairo_font_options_t</doc>
            <type name="FontOptions" c:type="cairo_font_options_t*"/>
          </instance-parameter>
          <parameter name="index" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo-font-options.c"
                 line="838">the index of the color to get</doc>
            <type name="guint" c:type="unsigned int"/>
          </parameter>
          <parameter name="red" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo-font-options.c"
                 line="839">return location for red component of color</doc>
            <type name="gdouble" c:type="double*"/>
          </parameter>
          <parameter name="green" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo-font-options.c"
                 line="840">return location for green component of color</doc>
            <type name="gdouble" c:type="double*"/>
          </parameter>
          <parameter name="blue" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo-font-options.c"
                 line="841">return location for blue component of color</doc>
            <type name="gdouble" c:type="double*"/>
          </parameter>
          <parameter name="alpha" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo-font-options.c"
                 line="842">return location for alpha component of color</doc>
            <type name="gdouble" c:type="double*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_hint_metrics"
              c:identifier="cairo_font_options_get_hint_metrics"
              version="1.0">
        <doc xml:space="preserve"
             filename="cairo-font-options.c"
             line="618">Gets the metrics hinting mode for the font options object.
See the documentation for #cairo_hint_metrics_t for full details.</doc>
        <source-position filename="cairo.h" line="1502"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cairo-font-options.c"
               line="625">the metrics hinting mode for the font options object</doc>
          <type name="HintMetrics" c:type="cairo_hint_metrics_t"/>
        </return-value>
        <parameters>
          <instance-parameter name="options" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo-font-options.c"
                 line="620">a #cairo_font_options_t</doc>
            <type name="FontOptions" c:type="const cairo_font_options_t*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_hint_style"
              c:identifier="cairo_font_options_get_hint_style"
              version="1.0">
        <doc xml:space="preserve"
             filename="cairo-font-options.c"
             line="576">Gets the hint style for font outlines for the font options object.
See the documentation for #cairo_hint_style_t for full details.</doc>
        <source-position filename="cairo.h" line="1496"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cairo-font-options.c"
               line="583">the hint style for the font options object</doc>
          <type name="HintStyle" c:type="cairo_hint_style_t"/>
        </return-value>
        <parameters>
          <instance-parameter name="options" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo-font-options.c"
                 line="578">a #cairo_font_options_t</doc>
            <type name="FontOptions" c:type="const cairo_font_options_t*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_subpixel_order"
              c:identifier="cairo_font_options_get_subpixel_order"
              version="1.0">
        <doc xml:space="preserve"
             filename="cairo-font-options.c"
             line="461">Gets the subpixel order for the font options object.
See the documentation for #cairo_subpixel_order_t for full details.</doc>
        <source-position filename="cairo.h" line="1490"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cairo-font-options.c"
               line="468">the subpixel order for the font options object</doc>
          <type name="SubpixelOrder" c:type="cairo_subpixel_order_t"/>
        </return-value>
        <parameters>
          <instance-parameter name="options" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo-font-options.c"
                 line="463">a #cairo_font_options_t</doc>
            <type name="FontOptions" c:type="const cairo_font_options_t*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_variations"
              c:identifier="cairo_font_options_get_variations"
              version="1.16">
        <doc xml:space="preserve"
             filename="cairo-font-options.c"
             line="667">Gets the OpenType font variations for the font options object.
See cairo_font_options_set_variations() for details about the
string format.</doc>
        <source-position filename="cairo.h" line="1505"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cairo-font-options.c"
               line="675">the font variations for the font options object. The
  returned string belongs to the @options and must not be modified.
  It is valid until either the font options object is destroyed or
  the font variations in this object is modified with
  cairo_font_options_set_variations().</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="options" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo-font-options.c"
                 line="669">a #cairo_font_options_t</doc>
            <type name="FontOptions" c:type="cairo_font_options_t*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="hash" c:identifier="cairo_font_options_hash" version="1.0">
        <doc xml:space="preserve"
             filename="cairo-font-options.c"
             line="364">Compute a hash for the font options object; this value will
be useful when storing an object containing a #cairo_font_options_t
in a hash table.</doc>
        <source-position filename="cairo.h" line="1478"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cairo-font-options.c"
               line="372">the hash value for the font options object.
  The return value can be cast to a 32-bit type if a
  32-bit hash value is needed.</doc>
          <type name="gulong" c:type="unsigned long"/>
        </return-value>
        <parameters>
          <instance-parameter name="options" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo-font-options.c"
                 line="366">a #cairo_font_options_t</doc>
            <type name="FontOptions" c:type="const cairo_font_options_t*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="merge"
              c:identifier="cairo_font_options_merge"
              version="1.0">
        <doc xml:space="preserve"
             filename="cairo-font-options.c"
             line="256">Merges non-default options from @other into @options, replacing
existing values. This operation can be thought of as somewhat
similar to compositing @other onto @options with the operation
of %CAIRO_OPERATOR_OVER.</doc>
        <source-position filename="cairo.h" line="1471"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="options" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo-font-options.c"
                 line="258">a #cairo_font_options_t</doc>
            <type name="FontOptions" c:type="cairo_font_options_t*"/>
          </instance-parameter>
          <parameter name="other" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo-font-options.c"
                 line="259">another #cairo_font_options_t</doc>
            <type name="FontOptions" c:type="const cairo_font_options_t*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_antialias"
              c:identifier="cairo_font_options_set_antialias"
              version="1.0">
        <doc xml:space="preserve"
             filename="cairo-font-options.c"
             line="399">Sets the antialiasing mode for the font options object. This
specifies the type of antialiasing to do when rendering text.</doc>
        <source-position filename="cairo.h" line="1481"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="options" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo-font-options.c"
                 line="401">a #cairo_font_options_t</doc>
            <type name="FontOptions" c:type="cairo_font_options_t*"/>
          </instance-parameter>
          <parameter name="antialias" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo-font-options.c"
                 line="402">the new antialiasing mode</doc>
            <type name="Antialias" c:type="cairo_antialias_t"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_color_mode"
              c:identifier="cairo_font_options_set_color_mode"
              version="1.18">
        <doc xml:space="preserve"
             filename="cairo-font-options.c"
             line="689">Sets the color mode for the font options object. This controls
whether color fonts are to be rendered in color or as outlines.
See the documentation for #cairo_color_mode_t for full details.</doc>
        <source-position filename="cairo.h" line="1514"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="options" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo-font-options.c"
                 line="691">a #cairo_font_options_t</doc>
            <type name="FontOptions" c:type="cairo_font_options_t*"/>
          </instance-parameter>
          <parameter name="color_mode" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo-font-options.c"
                 line="692">the new color mode</doc>
            <type name="ColorMode" c:type="cairo_color_mode_t"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_color_palette"
              c:identifier="cairo_font_options_set_color_palette"
              version="1.18">
        <doc xml:space="preserve"
             filename="cairo-font-options.c"
             line="738">Sets the OpenType font color palette for the font options
object. OpenType color fonts with a CPAL table may contain multiple
palettes. The default color palette index is %CAIRO_COLOR_PALETTE_DEFAULT.

If @palette_index is invalid, the default palette is used.

Individual colors within the palette may be overriden with
cairo_font_options_set_custom_palette_color().</doc>
        <source-position filename="cairo.h" line="1524"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="options" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo-font-options.c"
                 line="740">a #cairo_font_options_t</doc>
            <type name="FontOptions" c:type="cairo_font_options_t*"/>
          </instance-parameter>
          <parameter name="palette_index" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo-font-options.c"
                 line="741">the palette index in the CPAL table</doc>
            <type name="guint" c:type="unsigned int"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_custom_palette_color"
              c:identifier="cairo_font_options_set_custom_palette_color"
              version="1.18">
        <doc xml:space="preserve"
             filename="cairo-font-options.c"
             line="783">Sets a custom palette color for the font options object. This
overrides the palette color at the specified color index. This override is
independent of the selected palette index and will remain in place
even if cairo_font_options_set_color_palette() is called to change
the palette index.

It is only possible to override color indexes already in the font
palette.</doc>
        <source-position filename="cairo.h" line="1528"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="options" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo-font-options.c"
                 line="785">a #cairo_font_options_t</doc>
            <type name="FontOptions" c:type="cairo_font_options_t*"/>
          </instance-parameter>
          <parameter name="index" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo-font-options.c"
                 line="786">the index of the color to set</doc>
            <type name="guint" c:type="unsigned int"/>
          </parameter>
          <parameter name="red" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo-font-options.c"
                 line="787">red component of color</doc>
            <type name="gdouble" c:type="double"/>
          </parameter>
          <parameter name="green" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo-font-options.c"
                 line="788">green component of color</doc>
            <type name="gdouble" c:type="double"/>
          </parameter>
          <parameter name="blue" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo-font-options.c"
                 line="789">blue component of color</doc>
            <type name="gdouble" c:type="double"/>
          </parameter>
          <parameter name="alpha" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo-font-options.c"
                 line="790">alpha component of color</doc>
            <type name="gdouble" c:type="double"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_hint_metrics"
              c:identifier="cairo_font_options_set_hint_metrics"
              version="1.0">
        <doc xml:space="preserve"
             filename="cairo-font-options.c"
             line="596">Sets the metrics hinting mode for the font options object. This
controls whether metrics are quantized to integer values in
device units.
See the documentation for #cairo_hint_metrics_t for full details.</doc>
        <source-position filename="cairo.h" line="1499"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="options" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo-font-options.c"
                 line="598">a #cairo_font_options_t</doc>
            <type name="FontOptions" c:type="cairo_font_options_t*"/>
          </instance-parameter>
          <parameter name="hint_metrics" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo-font-options.c"
                 line="599">the new metrics hinting mode</doc>
            <type name="HintMetrics" c:type="cairo_hint_metrics_t"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_hint_style"
              c:identifier="cairo_font_options_set_hint_style"
              version="1.0">
        <doc xml:space="preserve"
             filename="cairo-font-options.c"
             line="554">Sets the hint style for font outlines for the font options object.
This controls whether to fit font outlines to the pixel grid,
and if so, whether to optimize for fidelity or contrast.
See the documentation for #cairo_hint_style_t for full details.</doc>
        <source-position filename="cairo.h" line="1493"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="options" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo-font-options.c"
                 line="556">a #cairo_font_options_t</doc>
            <type name="FontOptions" c:type="cairo_font_options_t*"/>
          </instance-parameter>
          <parameter name="hint_style" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo-font-options.c"
                 line="557">the new hint style</doc>
            <type name="HintStyle" c:type="cairo_hint_style_t"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_subpixel_order"
              c:identifier="cairo_font_options_set_subpixel_order"
              version="1.0">
        <doc xml:space="preserve"
             filename="cairo-font-options.c"
             line="438">Sets the subpixel order for the font options object. The subpixel
order specifies the order of color elements within each pixel on
the display device when rendering with an antialiasing mode of
%CAIRO_ANTIALIAS_SUBPIXEL. See the documentation for
#cairo_subpixel_order_t for full details.</doc>
        <source-position filename="cairo.h" line="1487"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="options" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo-font-options.c"
                 line="440">a #cairo_font_options_t</doc>
            <type name="FontOptions" c:type="cairo_font_options_t*"/>
          </instance-parameter>
          <parameter name="subpixel_order" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo-font-options.c"
                 line="441">the new subpixel order</doc>
            <type name="SubpixelOrder" c:type="cairo_subpixel_order_t"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_variations"
              c:identifier="cairo_font_options_set_variations"
              version="1.16">
        <doc xml:space="preserve"
             filename="cairo-font-options.c"
             line="638">Sets the OpenType font variations for the font options object.
Font variations are specified as a string with a format that
is similar to the CSS font-variation-settings. The string contains
a comma-separated list of axis assignments, which each assignment
consists of a 4-character axis name and a value, separated by
whitespace and optional equals sign.

Examples:

wght=200,wdth=140.5

wght 200 , wdth 140.5</doc>
        <source-position filename="cairo.h" line="1508"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="options" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo-font-options.c"
                 line="640">a #cairo_font_options_t</doc>
            <type name="FontOptions" c:type="cairo_font_options_t*"/>
          </instance-parameter>
          <parameter name="variations" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo-font-options.c"
                 line="641">the new font variations, or %NULL</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </method>
      <method name="status"
              c:identifier="cairo_font_options_status"
              version="1.0">
        <doc xml:space="preserve"
             filename="cairo-font-options.c"
             line="233">Checks whether an error has previously occurred for this
font options object</doc>
        <source-position filename="cairo.h" line="1468"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cairo-font-options.c"
               line="240">%CAIRO_STATUS_SUCCESS, %CAIRO_STATUS_NO_MEMORY, or
%CAIRO_STATUS_NULL_POINTER.</doc>
          <type name="Status" c:type="cairo_status_t"/>
        </return-value>
        <parameters>
          <instance-parameter name="options" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo-font-options.c"
                 line="235">a #cairo_font_options_t</doc>
            <type name="FontOptions" c:type="cairo_font_options_t*"/>
          </instance-parameter>
        </parameters>
      </method>
    </record>
    <enumeration name="FontSlant"
                 version="1.0"
                 glib:type-name="cairo_font_slant_t"
                 glib:get-type="cairo_gobject_font_slant_get_type"
                 c:type="cairo_font_slant_t">
      <doc xml:space="preserve"
           filename="cairo.h"
           line="1301">Specifies variants of a font face based on their slant.</doc>
      <member name="normal"
              value="0"
              c:identifier="CAIRO_FONT_SLANT_NORMAL"
              glib:nick="normal"
              glib:name="CAIRO_FONT_SLANT_NORMAL">
        <doc xml:space="preserve"
             filename="cairo.h"
             line="1303">Upright font style, since 1.0</doc>
      </member>
      <member name="italic"
              value="1"
              c:identifier="CAIRO_FONT_SLANT_ITALIC"
              glib:nick="italic"
              glib:name="CAIRO_FONT_SLANT_ITALIC">
        <doc xml:space="preserve"
             filename="cairo.h"
             line="1304">Italic font style, since 1.0</doc>
      </member>
      <member name="oblique"
              value="2"
              c:identifier="CAIRO_FONT_SLANT_OBLIQUE"
              glib:nick="oblique"
              glib:name="CAIRO_FONT_SLANT_OBLIQUE">
        <doc xml:space="preserve"
             filename="cairo.h"
             line="1305">Oblique font style, since 1.0</doc>
      </member>
    </enumeration>
    <enumeration name="FontType"
                 version="1.2"
                 glib:type-name="cairo_font_type_t"
                 glib:get-type="cairo_gobject_font_type_get_type"
                 c:type="cairo_font_type_t">
      <doc xml:space="preserve"
           filename="cairo.h"
           line="1632">#cairo_font_type_t is used to describe the type of a given font
face or scaled font. The font types are also known as "font
backends" within cairo.

The type of a font face is determined by the function used to
create it, which will generally be of the form
&lt;function&gt;cairo_&lt;emphasis&gt;type&lt;/emphasis&gt;_font_face_create(&lt;!-- --&gt;)&lt;/function&gt;.
The font face type can be queried with cairo_font_face_get_type()

The various #cairo_font_face_t functions can be used with a font face
of any type.

The type of a scaled font is determined by the type of the font
face passed to cairo_scaled_font_create(). The scaled font type can
be queried with cairo_scaled_font_get_type()

The various #cairo_scaled_font_t functions can be used with scaled
fonts of any type, but some font backends also provide
type-specific functions that must only be called with a scaled font
of the appropriate type. These functions have names that begin with
&lt;function&gt;cairo_&lt;emphasis&gt;type&lt;/emphasis&gt;_scaled_font(&lt;!-- --&gt;)&lt;/function&gt;
such as cairo_ft_scaled_font_lock_face().

The behavior of calling a type-specific function with a scaled font
of the wrong type is undefined.

New entries may be added in future versions.</doc>
      <member name="toy"
              value="0"
              c:identifier="CAIRO_FONT_TYPE_TOY"
              glib:nick="toy"
              glib:name="CAIRO_FONT_TYPE_TOY">
        <doc xml:space="preserve"
             filename="cairo.h"
             line="1634">The font was created using cairo's toy font api (Since: 1.2)</doc>
      </member>
      <member name="ft"
              value="1"
              c:identifier="CAIRO_FONT_TYPE_FT"
              glib:nick="ft"
              glib:name="CAIRO_FONT_TYPE_FT">
        <doc xml:space="preserve"
             filename="cairo.h"
             line="1635">The font is of type FreeType (Since: 1.2)</doc>
      </member>
      <member name="win32"
              value="2"
              c:identifier="CAIRO_FONT_TYPE_WIN32"
              glib:nick="win32"
              glib:name="CAIRO_FONT_TYPE_WIN32">
        <doc xml:space="preserve"
             filename="cairo.h"
             line="1636">The font is of type Win32 (Since: 1.2)</doc>
      </member>
      <member name="quartz"
              value="3"
              c:identifier="CAIRO_FONT_TYPE_QUARTZ"
              glib:nick="quartz"
              glib:name="CAIRO_FONT_TYPE_QUARTZ">
        <doc xml:space="preserve"
             filename="cairo.h"
             line="1637">The font is of type Quartz (Since: 1.6, in 1.2 and
1.4 it was named CAIRO_FONT_TYPE_ATSUI)</doc>
      </member>
      <member name="user"
              value="4"
              c:identifier="CAIRO_FONT_TYPE_USER"
              glib:nick="user"
              glib:name="CAIRO_FONT_TYPE_USER">
        <doc xml:space="preserve"
             filename="cairo.h"
             line="1639">The font was create using cairo's user font api (Since: 1.8)</doc>
      </member>
    </enumeration>
    <enumeration name="FontWeight"
                 version="1.0"
                 glib:type-name="cairo_font_weight_t"
                 glib:get-type="cairo_gobject_font_weight_get_type"
                 c:type="cairo_font_weight_t">
      <doc xml:space="preserve"
           filename="cairo.h"
           line="1317">Specifies variants of a font face based on their weight.</doc>
      <member name="normal"
              value="0"
              c:identifier="CAIRO_FONT_WEIGHT_NORMAL"
              glib:nick="normal"
              glib:name="CAIRO_FONT_WEIGHT_NORMAL">
        <doc xml:space="preserve"
             filename="cairo.h"
             line="1319">Normal font weight, since 1.0</doc>
      </member>
      <member name="bold"
              value="1"
              c:identifier="CAIRO_FONT_WEIGHT_BOLD"
              glib:nick="bold"
              glib:name="CAIRO_FONT_WEIGHT_BOLD">
        <doc xml:space="preserve"
             filename="cairo.h"
             line="1320">Bold font weight, since 1.0</doc>
      </member>
    </enumeration>
    <enumeration name="Format"
                 version="1.0"
                 glib:type-name="cairo_format_t"
                 glib:get-type="cairo_gobject_format_get_type"
                 c:type="cairo_format_t">
      <doc xml:space="preserve"
           filename="cairo.h"
           line="398">#cairo_format_t is used to identify the memory format of
image data.

New entries may be added in future versions.</doc>
      <member name="invalid"
              value="-1"
              c:identifier="CAIRO_FORMAT_INVALID"
              glib:nick="invalid"
              glib:name="CAIRO_FORMAT_INVALID">
        <doc xml:space="preserve"
             filename="cairo.h"
             line="400">no such format exists or is supported.</doc>
      </member>
      <member name="argb32"
              value="0"
              c:identifier="CAIRO_FORMAT_ARGB32"
              glib:nick="argb32"
              glib:name="CAIRO_FORMAT_ARGB32">
        <doc xml:space="preserve"
             filename="cairo.h"
             line="401">each pixel is a 32-bit quantity, with
  alpha in the upper 8 bits, then red, then green, then blue.
  The 32-bit quantities are stored native-endian. Pre-multiplied
  alpha is used. (That is, 50% transparent red is 0x80800000,
  not 0x80ff0000.) (Since 1.0)</doc>
      </member>
      <member name="rgb24"
              value="1"
              c:identifier="CAIRO_FORMAT_RGB24"
              glib:nick="rgb24"
              glib:name="CAIRO_FORMAT_RGB24">
        <doc xml:space="preserve"
             filename="cairo.h"
             line="406">each pixel is a 32-bit quantity, with
  the upper 8 bits unused. Red, Green, and Blue are stored
  in the remaining 24 bits in that order. (Since 1.0)</doc>
      </member>
      <member name="a8"
              value="2"
              c:identifier="CAIRO_FORMAT_A8"
              glib:nick="a8"
              glib:name="CAIRO_FORMAT_A8">
        <doc xml:space="preserve"
             filename="cairo.h"
             line="409">each pixel is a 8-bit quantity holding
  an alpha value. (Since 1.0)</doc>
      </member>
      <member name="a1"
              value="3"
              c:identifier="CAIRO_FORMAT_A1"
              glib:nick="a1"
              glib:name="CAIRO_FORMAT_A1">
        <doc xml:space="preserve"
             filename="cairo.h"
             line="411">each pixel is a 1-bit quantity holding
  an alpha value. Pixels are packed together into 32-bit
  quantities. The ordering of the bits matches the
  endianness of the platform. On a big-endian machine, the
  first pixel is in the uppermost bit, on a little-endian
  machine the first pixel is in the least-significant bit. (Since 1.0)</doc>
      </member>
      <member name="rgb16_565"
              value="4"
              c:identifier="CAIRO_FORMAT_RGB16_565"
              glib:nick="rgb16-565"
              glib:name="CAIRO_FORMAT_RGB16_565">
        <doc xml:space="preserve"
             filename="cairo.h"
             line="417">each pixel is a 16-bit quantity
  with red in the upper 5 bits, then green in the middle
  6 bits, and blue in the lower 5 bits. (Since 1.2)</doc>
      </member>
    </enumeration>
    <record name="Glyph"
            c:type="cairo_glyph_t"
            version="1.0"
            glib:type-name="cairo_glyph_t"
            glib:get-type="cairo_gobject_glyph_get_type"
            c:symbol-prefix="gobject_glyph">
      <doc xml:space="preserve"
           filename="cairo.h"
           line="1130">The #cairo_glyph_t structure holds information about a single glyph
when drawing or measuring text. A font is (in simple terms) a
collection of shapes used to draw text. A glyph is one of these
shapes. There can be multiple glyphs for a single character
(alternates to be used in different contexts, for example), or a
glyph can be a &lt;firstterm&gt;ligature&lt;/firstterm&gt; of multiple
characters. Cairo doesn't expose any way of converting input text
into glyphs, so in order to use the Cairo interfaces that take
arrays of glyphs, you must directly access the appropriate
underlying font system.

Note that the offsets given by @x and @y are not cumulative. When
drawing or measuring text, each glyph is individually positioned
with respect to the overall origin</doc>
      <source-position filename="cairo.h" line="1160"/>
      <field name="index" writable="1">
        <doc xml:space="preserve"
             filename="cairo.h"
             line="1132">glyph index in the font. The exact interpretation of the
     glyph index depends on the font technology being used.</doc>
        <type name="gulong" c:type="unsigned long"/>
      </field>
      <field name="x" writable="1">
        <doc xml:space="preserve"
             filename="cairo.h"
             line="1134">the offset in the X direction between the origin used for
    drawing or measuring the string and the origin of this glyph.</doc>
        <type name="gdouble" c:type="double"/>
      </field>
      <field name="y" writable="1">
        <doc xml:space="preserve"
             filename="cairo.h"
             line="1136">the offset in the Y direction between the origin used for
    drawing or measuring the string and the origin of this glyph.</doc>
        <type name="gdouble" c:type="double"/>
      </field>
      <method name="free" c:identifier="cairo_glyph_free" version="1.8">
        <doc xml:space="preserve"
             filename="cairo-misc.c"
             line="216">Frees an array of #cairo_glyph_t's allocated using cairo_glyph_allocate().
This function is only useful to free glyph array returned
by cairo_scaled_font_text_to_glyphs() where cairo returns
an array of glyphs that the user will free.
For all other uses, user can use their own allocation method
for glyphs.</doc>
        <source-position filename="cairo.h" line="1166"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="glyphs" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo-misc.c"
                 line="218">array of glyphs to free, or %NULL</doc>
            <type name="Glyph" c:type="cairo_glyph_t*"/>
          </instance-parameter>
        </parameters>
      </method>
    </record>
    <enumeration name="HintMetrics"
                 version="1.0"
                 glib:type-name="cairo_hint_metrics_t"
                 glib:get-type="cairo_gobject_hint_metrics_get_type"
                 c:type="cairo_hint_metrics_t">
      <doc xml:space="preserve"
           filename="cairo.h"
           line="1390">Specifies whether to hint font metrics; hinting font metrics
means quantizing them so that they are integer values in
device space. Doing this improves the consistency of
letter and line spacing, however it also means that text
will be laid out differently at different zoom factors.</doc>
      <member name="default"
              value="0"
              c:identifier="CAIRO_HINT_METRICS_DEFAULT"
              glib:nick="default"
              glib:name="CAIRO_HINT_METRICS_DEFAULT">
        <doc xml:space="preserve"
             filename="cairo.h"
             line="1392">Hint metrics in the default
 manner for the font backend and target device, since 1.0</doc>
      </member>
      <member name="off"
              value="1"
              c:identifier="CAIRO_HINT_METRICS_OFF"
              glib:nick="off"
              glib:name="CAIRO_HINT_METRICS_OFF">
        <doc xml:space="preserve"
             filename="cairo.h"
             line="1394">Do not hint font metrics, since 1.0</doc>
      </member>
      <member name="on"
              value="2"
              c:identifier="CAIRO_HINT_METRICS_ON"
              glib:nick="on"
              glib:name="CAIRO_HINT_METRICS_ON">
        <doc xml:space="preserve"
             filename="cairo.h"
             line="1395">Hint font metrics, since 1.0</doc>
      </member>
    </enumeration>
    <enumeration name="HintStyle"
                 version="1.0"
                 glib:type-name="cairo_hint_style_t"
                 glib:get-type="cairo_gobject_hint_style_get_type"
                 c:type="cairo_hint_style_t">
      <doc xml:space="preserve"
           filename="cairo.h"
           line="1358">Specifies the type of hinting to do on font outlines. Hinting
is the process of fitting outlines to the pixel grid in order
to improve the appearance of the result. Since hinting outlines
involves distorting them, it also reduces the faithfulness
to the original outline shapes. Not all of the outline hinting
styles are supported by all font backends.

New entries may be added in future versions.</doc>
      <member name="default"
              value="0"
              c:identifier="CAIRO_HINT_STYLE_DEFAULT"
              glib:nick="default"
              glib:name="CAIRO_HINT_STYLE_DEFAULT">
        <doc xml:space="preserve"
             filename="cairo.h"
             line="1360">Use the default hint style for
  font backend and target device, since 1.0</doc>
      </member>
      <member name="none"
              value="1"
              c:identifier="CAIRO_HINT_STYLE_NONE"
              glib:nick="none"
              glib:name="CAIRO_HINT_STYLE_NONE">
        <doc xml:space="preserve"
             filename="cairo.h"
             line="1362">Do not hint outlines, since 1.0</doc>
      </member>
      <member name="slight"
              value="2"
              c:identifier="CAIRO_HINT_STYLE_SLIGHT"
              glib:nick="slight"
              glib:name="CAIRO_HINT_STYLE_SLIGHT">
        <doc xml:space="preserve"
             filename="cairo.h"
             line="1363">Hint outlines slightly to improve
  contrast while retaining good fidelity to the original
  shapes, since 1.0</doc>
      </member>
      <member name="medium"
              value="3"
              c:identifier="CAIRO_HINT_STYLE_MEDIUM"
              glib:nick="medium"
              glib:name="CAIRO_HINT_STYLE_MEDIUM">
        <doc xml:space="preserve"
             filename="cairo.h"
             line="1366">Hint outlines with medium strength
  giving a compromise between fidelity to the original shapes
  and contrast, since 1.0</doc>
      </member>
      <member name="full"
              value="4"
              c:identifier="CAIRO_HINT_STYLE_FULL"
              glib:nick="full"
              glib:name="CAIRO_HINT_STYLE_FULL">
        <doc xml:space="preserve"
             filename="cairo.h"
             line="1369">Hint outlines to maximize contrast, since 1.0</doc>
      </member>
    </enumeration>
    <enumeration name="LineCap"
                 version="1.0"
                 glib:type-name="cairo_line_cap_t"
                 glib:get-type="cairo_gobject_line_cap_get_type"
                 c:type="cairo_line_cap_t">
      <doc xml:space="preserve"
           filename="cairo.h"
           line="810">Specifies how to render the endpoints of the path when stroking.

The default line cap style is %CAIRO_LINE_CAP_BUTT.</doc>
      <member name="butt"
              value="0"
              c:identifier="CAIRO_LINE_CAP_BUTT"
              glib:nick="butt"
              glib:name="CAIRO_LINE_CAP_BUTT">
        <doc xml:space="preserve"
             filename="cairo.h"
             line="812">start(stop) the line exactly at the start(end) point (Since 1.0)</doc>
      </member>
      <member name="round"
              value="1"
              c:identifier="CAIRO_LINE_CAP_ROUND"
              glib:nick="round"
              glib:name="CAIRO_LINE_CAP_ROUND">
        <doc xml:space="preserve"
             filename="cairo.h"
             line="813">use a round ending, the center of the circle is the end point (Since 1.0)</doc>
      </member>
      <member name="square"
              value="2"
              c:identifier="CAIRO_LINE_CAP_SQUARE"
              glib:nick="square"
              glib:name="CAIRO_LINE_CAP_SQUARE">
        <doc xml:space="preserve"
             filename="cairo.h"
             line="814">use squared ending, the center of the square is the end point (Since 1.0)</doc>
      </member>
    </enumeration>
    <enumeration name="LineJoin"
                 version="1.0"
                 glib:type-name="cairo_line_join_t"
                 glib:get-type="cairo_gobject_line_join_get_type"
                 c:type="cairo_line_join_t">
      <doc xml:space="preserve"
           filename="cairo.h"
           line="831">Specifies how to render the junction of two lines when stroking.

The default line join style is %CAIRO_LINE_JOIN_MITER.</doc>
      <member name="miter"
              value="0"
              c:identifier="CAIRO_LINE_JOIN_MITER"
              glib:nick="miter"
              glib:name="CAIRO_LINE_JOIN_MITER">
        <doc xml:space="preserve"
             filename="cairo.h"
             line="833">use a sharp (angled) corner, see
cairo_set_miter_limit() (Since 1.0)</doc>
      </member>
      <member name="round"
              value="1"
              c:identifier="CAIRO_LINE_JOIN_ROUND"
              glib:nick="round"
              glib:name="CAIRO_LINE_JOIN_ROUND">
        <doc xml:space="preserve"
             filename="cairo.h"
             line="835">use a rounded join, the center of the circle is the
joint point (Since 1.0)</doc>
      </member>
      <member name="bevel"
              value="2"
              c:identifier="CAIRO_LINE_JOIN_BEVEL"
              glib:nick="bevel"
              glib:name="CAIRO_LINE_JOIN_BEVEL">
        <doc xml:space="preserve"
             filename="cairo.h"
             line="837">use a cut-off join, the join is cut off at half
the line width from the joint point (Since 1.0)</doc>
      </member>
    </enumeration>
    <constant name="MIME_TYPE_CCITT_FAX"
              value="image/g3fax"
              c:type="CAIRO_MIME_TYPE_CCITT_FAX"
              version="1.16">
      <doc xml:space="preserve"
           filename="cairo-surface.c"
           line="1276">Group 3 or Group 4 CCITT facsimile encoding (International
Telecommunication Union, Recommendations T.4 and T.6.)</doc>
      <source-position filename="cairo.h" line="2616"/>
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="MIME_TYPE_CCITT_FAX_PARAMS"
              value="application/x-cairo.ccitt.params"
              c:type="CAIRO_MIME_TYPE_CCITT_FAX_PARAMS"
              version="1.16">
      <doc xml:space="preserve"
           filename="cairo-surface.c"
           line="1285">Decode parameters for Group 3 or Group 4 CCITT facsimile encoding.
See [CCITT Fax Images][ccitt].</doc>
      <source-position filename="cairo.h" line="2617"/>
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="MIME_TYPE_EPS"
              value="application/postscript"
              c:type="CAIRO_MIME_TYPE_EPS"
              version="1.16">
      <doc xml:space="preserve"
           filename="cairo-surface.c"
           line="1294">Encapsulated PostScript file.
[Encapsulated PostScript File Format Specification](http://wwwimages.adobe.com/content/dam/Adobe/endevnet/postscript/pdfs/5002.EPSF_Spec.pdf)</doc>
      <source-position filename="cairo.h" line="2618"/>
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="MIME_TYPE_EPS_PARAMS"
              value="application/x-cairo.eps.params"
              c:type="CAIRO_MIME_TYPE_EPS_PARAMS"
              version="1.16">
      <doc xml:space="preserve"
           filename="cairo-surface.c"
           line="1303">Embedding parameters Encapsulated PostScript data.
See [Embedding EPS files][eps].</doc>
      <source-position filename="cairo.h" line="2619"/>
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="MIME_TYPE_JBIG2"
              value="application/x-cairo.jbig2"
              c:type="CAIRO_MIME_TYPE_JBIG2"
              version="1.14">
      <doc xml:space="preserve"
           filename="cairo-surface.c"
           line="1312">Joint Bi-level Image Experts Group image coding standard (ISO/IEC 11544).</doc>
      <source-position filename="cairo.h" line="2613"/>
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="MIME_TYPE_JBIG2_GLOBAL"
              value="application/x-cairo.jbig2-global"
              c:type="CAIRO_MIME_TYPE_JBIG2_GLOBAL"
              version="1.14">
      <doc xml:space="preserve"
           filename="cairo-surface.c"
           line="1320">Joint Bi-level Image Experts Group image coding standard (ISO/IEC 11544) global segment.</doc>
      <source-position filename="cairo.h" line="2614"/>
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="MIME_TYPE_JBIG2_GLOBAL_ID"
              value="application/x-cairo.jbig2-global-id"
              c:type="CAIRO_MIME_TYPE_JBIG2_GLOBAL_ID"
              version="1.14">
      <doc xml:space="preserve"
           filename="cairo-surface.c"
           line="1328">An unique identifier shared by a JBIG2 global segment and all JBIG2 images
that depend on the global segment.</doc>
      <source-position filename="cairo.h" line="2615"/>
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="MIME_TYPE_JP2"
              value="image/jp2"
              c:type="CAIRO_MIME_TYPE_JP2"
              version="1.10">
      <doc xml:space="preserve"
           filename="cairo-surface.c"
           line="1337">The Joint Photographic Experts Group (JPEG) 2000 image coding standard (ISO/IEC 15444-1).</doc>
      <source-position filename="cairo.h" line="2610"/>
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="MIME_TYPE_JPEG"
              value="image/jpeg"
              c:type="CAIRO_MIME_TYPE_JPEG"
              version="1.10">
      <doc xml:space="preserve"
           filename="cairo-surface.c"
           line="1345">The Joint Photographic Experts Group (JPEG) image coding standard (ISO/IEC 10918-1).</doc>
      <source-position filename="cairo.h" line="2608"/>
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="MIME_TYPE_PNG"
              value="image/png"
              c:type="CAIRO_MIME_TYPE_PNG"
              version="1.10">
      <doc xml:space="preserve"
           filename="cairo-surface.c"
           line="1353">The Portable Network Graphics image file format (ISO/IEC 15948).</doc>
      <source-position filename="cairo.h" line="2609"/>
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="MIME_TYPE_UNIQUE_ID"
              value="application/x-cairo.uuid"
              c:type="CAIRO_MIME_TYPE_UNIQUE_ID"
              version="1.12">
      <doc xml:space="preserve"
           filename="cairo-surface.c"
           line="1369">Unique identifier for a surface (cairo specific MIME type). All surfaces with
the same unique identifier will only be embedded once.</doc>
      <source-position filename="cairo.h" line="2612"/>
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="MIME_TYPE_URI"
              value="text/x-uri"
              c:type="CAIRO_MIME_TYPE_URI"
              version="1.10">
      <doc xml:space="preserve"
           filename="cairo-surface.c"
           line="1361">URI for an image file (unofficial MIME type).</doc>
      <source-position filename="cairo.h" line="2611"/>
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <record name="Matrix"
            c:type="cairo_matrix_t"
            version="1.0"
            glib:type-name="cairo_matrix_t"
            glib:get-type="cairo_gobject_matrix_get_type"
            c:symbol-prefix="gobject_matrix">
      <doc xml:space="preserve"
           filename="cairo.h"
           line="182">A #cairo_matrix_t holds an affine transformation, such as a scale,
rotation, shear, or a combination of those. The transformation of
a point (x, y) is given by:
&lt;programlisting&gt;
    x_new = xx * x + xy * y + x0;
    y_new = yx * x + yy * y + y0;
&lt;/programlisting&gt;</doc>
      <source-position filename="cairo.h" line="205"/>
      <field name="xx" writable="1">
        <doc xml:space="preserve"
             filename="cairo.h"
             line="184">xx component of the affine transformation</doc>
        <type name="gdouble" c:type="double"/>
      </field>
      <field name="yx" writable="1">
        <doc xml:space="preserve"
             filename="cairo.h"
             line="185">yx component of the affine transformation</doc>
        <type name="gdouble" c:type="double"/>
      </field>
      <field name="xy" writable="1">
        <doc xml:space="preserve"
             filename="cairo.h"
             line="186">xy component of the affine transformation</doc>
        <type name="gdouble" c:type="double"/>
      </field>
      <field name="yy" writable="1">
        <doc xml:space="preserve"
             filename="cairo.h"
             line="187">yy component of the affine transformation</doc>
        <type name="gdouble" c:type="double"/>
      </field>
      <field name="x0" writable="1">
        <doc xml:space="preserve"
             filename="cairo.h"
             line="188">X translation component of the affine transformation</doc>
        <type name="gdouble" c:type="double"/>
      </field>
      <field name="y0" writable="1">
        <doc xml:space="preserve"
             filename="cairo.h"
             line="189">Y translation component of the affine transformation</doc>
        <type name="gdouble" c:type="double"/>
      </field>
      <method name="init" c:identifier="cairo_matrix_init" version="1.0">
        <doc xml:space="preserve"
             filename="cairo-matrix.c"
             line="89">Sets @matrix to be the affine transformation given by
@xx, @yx, @xy, @yy, @x0, @y0. The transformation is given
by:
&lt;programlisting&gt;
 x_new = xx * x + xy * y + x0;
 y_new = yx * x + yy * y + y0;
&lt;/programlisting&gt;</doc>
        <source-position filename="cairo.h" line="3178"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="matrix" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo-matrix.c"
                 line="91">a #cairo_matrix_t</doc>
            <type name="Matrix" c:type="cairo_matrix_t*"/>
          </instance-parameter>
          <parameter name="xx" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo-matrix.c"
                 line="92">xx component of the affine transformation</doc>
            <type name="gdouble" c:type="double"/>
          </parameter>
          <parameter name="yx" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo-matrix.c"
                 line="93">yx component of the affine transformation</doc>
            <type name="gdouble" c:type="double"/>
          </parameter>
          <parameter name="xy" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo-matrix.c"
                 line="94">xy component of the affine transformation</doc>
            <type name="gdouble" c:type="double"/>
          </parameter>
          <parameter name="yy" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo-matrix.c"
                 line="95">yy component of the affine transformation</doc>
            <type name="gdouble" c:type="double"/>
          </parameter>
          <parameter name="x0" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo-matrix.c"
                 line="96">X translation component of the affine transformation</doc>
            <type name="gdouble" c:type="double"/>
          </parameter>
          <parameter name="y0" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo-matrix.c"
                 line="97">Y translation component of the affine transformation</doc>
            <type name="gdouble" c:type="double"/>
          </parameter>
        </parameters>
      </method>
      <method name="init_identity"
              c:identifier="cairo_matrix_init_identity"
              version="1.0">
        <doc xml:space="preserve"
             filename="cairo-matrix.c"
             line="72">Modifies @matrix to be an identity transformation.</doc>
        <source-position filename="cairo.h" line="3184"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="matrix" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo-matrix.c"
                 line="74">a #cairo_matrix_t</doc>
            <type name="Matrix" c:type="cairo_matrix_t*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="init_rotate"
              c:identifier="cairo_matrix_init_rotate"
              version="1.0">
        <doc xml:space="preserve"
             filename="cairo-matrix.c"
             line="246">Initialized @matrix to a transformation that rotates by @radians.</doc>
        <source-position filename="cairo.h" line="3195"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="matrix" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo-matrix.c"
                 line="248">a #cairo_matrix_t</doc>
            <type name="Matrix" c:type="cairo_matrix_t*"/>
          </instance-parameter>
          <parameter name="radians" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo-matrix.c"
                 line="249">angle of rotation, in radians. The direction of rotation
is defined such that positive angles rotate in the direction from
the positive X axis toward the positive Y axis. With the default
axis orientation of cairo, positive angles rotate in a clockwise
direction.</doc>
            <type name="gdouble" c:type="double"/>
          </parameter>
        </parameters>
      </method>
      <method name="init_scale"
              c:identifier="cairo_matrix_init_scale"
              version="1.0">
        <doc xml:space="preserve"
             filename="cairo-matrix.c"
             line="203">Initializes @matrix to a transformation that scales by @sx and @sy
in the X and Y dimensions, respectively.</doc>
        <source-position filename="cairo.h" line="3191"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="matrix" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo-matrix.c"
                 line="205">a #cairo_matrix_t</doc>
            <type name="Matrix" c:type="cairo_matrix_t*"/>
          </instance-parameter>
          <parameter name="sx" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo-matrix.c"
                 line="206">scale factor in the X direction</doc>
            <type name="gdouble" c:type="double"/>
          </parameter>
          <parameter name="sy" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo-matrix.c"
                 line="207">scale factor in the Y direction</doc>
            <type name="gdouble" c:type="double"/>
          </parameter>
        </parameters>
      </method>
      <method name="init_translate"
              c:identifier="cairo_matrix_init_translate"
              version="1.0">
        <doc xml:space="preserve"
             filename="cairo-matrix.c"
             line="159">Initializes @matrix to a transformation that translates by @tx and
@ty in the X and Y dimensions, respectively.</doc>
        <source-position filename="cairo.h" line="3187"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="matrix" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo-matrix.c"
                 line="161">a #cairo_matrix_t</doc>
            <type name="Matrix" c:type="cairo_matrix_t*"/>
          </instance-parameter>
          <parameter name="tx" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo-matrix.c"
                 line="162">amount to translate in the X direction</doc>
            <type name="gdouble" c:type="double"/>
          </parameter>
          <parameter name="ty" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo-matrix.c"
                 line="163">amount to translate in the Y direction</doc>
            <type name="gdouble" c:type="double"/>
          </parameter>
        </parameters>
      </method>
      <method name="invert" c:identifier="cairo_matrix_invert" version="1.0">
        <doc xml:space="preserve"
             filename="cairo-matrix.c"
             line="555">Changes @matrix to be the inverse of its original value. Not
all transformation matrices have inverses; if the matrix
collapses points together (it is &lt;firstterm&gt;degenerate&lt;/firstterm&gt;),
then it has no inverse and this function will fail.</doc>
        <source-position filename="cairo.h" line="3208"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cairo-matrix.c"
               line="564">If @matrix has an inverse, modifies @matrix to
 be the inverse matrix and returns %CAIRO_STATUS_SUCCESS. Otherwise,
 returns %CAIRO_STATUS_INVALID_MATRIX.</doc>
          <type name="Status" c:type="cairo_status_t"/>
        </return-value>
        <parameters>
          <instance-parameter name="matrix" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo-matrix.c"
                 line="557">a #cairo_matrix_t</doc>
            <type name="Matrix" c:type="cairo_matrix_t*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="multiply"
              c:identifier="cairo_matrix_multiply"
              version="1.0">
        <doc xml:space="preserve"
             filename="cairo-matrix.c"
             line="301">Multiplies the affine transformations in @a and @b together
and stores the result in @result. The effect of the resulting
transformation is to first apply the transformation in @a to the
coordinates and then apply the transformation in @b to the
coordinates.

It is allowable for @result to be identical to either @a or @b.</doc>
        <source-position filename="cairo.h" line="3211"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="result" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo-matrix.c"
                 line="303">a #cairo_matrix_t in which to store the result</doc>
            <type name="Matrix" c:type="cairo_matrix_t*"/>
          </instance-parameter>
          <parameter name="a" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo-matrix.c"
                 line="304">a #cairo_matrix_t</doc>
            <type name="Matrix" c:type="const cairo_matrix_t*"/>
          </parameter>
          <parameter name="b" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo-matrix.c"
                 line="305">a #cairo_matrix_t</doc>
            <type name="Matrix" c:type="const cairo_matrix_t*"/>
          </parameter>
        </parameters>
      </method>
      <method name="rotate" c:identifier="cairo_matrix_rotate" version="1.0">
        <doc xml:space="preserve"
             filename="cairo-matrix.c"
             line="275">Applies rotation by @radians to the transformation in
@matrix. The effect of the new transformation is to first rotate the
coordinates by @radians, then apply the original transformation
to the coordinates.</doc>
        <source-position filename="cairo.h" line="3205"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="matrix" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo-matrix.c"
                 line="277">a #cairo_matrix_t</doc>
            <type name="Matrix" c:type="cairo_matrix_t*"/>
          </instance-parameter>
          <parameter name="radians" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo-matrix.c"
                 line="278">angle of rotation, in radians. The direction of rotation
is defined such that positive angles rotate in the direction from
the positive X axis toward the positive Y axis. With the default
axis orientation of cairo, positive angles rotate in a clockwise
direction.</doc>
            <type name="gdouble" c:type="double"/>
          </parameter>
        </parameters>
      </method>
      <method name="scale" c:identifier="cairo_matrix_scale" version="1.0">
        <doc xml:space="preserve"
             filename="cairo-matrix.c"
             line="224">Applies scaling by @sx, @sy to the transformation in @matrix. The
effect of the new transformation is to first scale the coordinates
by @sx and @sy, then apply the original transformation to the coordinates.</doc>
        <source-position filename="cairo.h" line="3202"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="matrix" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo-matrix.c"
                 line="226">a #cairo_matrix_t</doc>
            <type name="Matrix" c:type="cairo_matrix_t*"/>
          </instance-parameter>
          <parameter name="sx" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo-matrix.c"
                 line="227">scale factor in the X direction</doc>
            <type name="gdouble" c:type="double"/>
          </parameter>
          <parameter name="sy" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo-matrix.c"
                 line="228">scale factor in the Y direction</doc>
            <type name="gdouble" c:type="double"/>
          </parameter>
        </parameters>
      </method>
      <method name="transform_distance"
              c:identifier="cairo_matrix_transform_distance"
              version="1.0">
        <doc xml:space="preserve"
             filename="cairo-matrix.c"
             line="355">Transforms the distance vector (@dx,@dy) by @matrix. This is
similar to cairo_matrix_transform_point() except that the translation
components of the transformation are ignored. The calculation of
the returned vector is as follows:

&lt;programlisting&gt;
dx_new = xx * dx + xy * dy;
dy_new = yx * dx + yy * dy;
&lt;/programlisting&gt;</doc>
        <source-position filename="cairo.h" line="3216"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="matrix" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo-matrix.c"
                 line="357">a #cairo_matrix_t</doc>
            <type name="Matrix" c:type="const cairo_matrix_t*"/>
          </instance-parameter>
          <parameter name="dx" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo-matrix.c"
                 line="358">X component of a distance vector. An in/out parameter</doc>
            <type name="gdouble" c:type="double*"/>
          </parameter>
          <parameter name="dy" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo-matrix.c"
                 line="359">Y component of a distance vector. An in/out parameter</doc>
            <type name="gdouble" c:type="double*"/>
          </parameter>
        </parameters>
      </method>
      <method name="transform_point"
              c:identifier="cairo_matrix_transform_point"
              version="1.0">
        <doc xml:space="preserve"
             filename="cairo-matrix.c"
             line="385">Transforms the point (@x, @y) by @matrix.</doc>
        <source-position filename="cairo.h" line="3220"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="matrix" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo-matrix.c"
                 line="387">a #cairo_matrix_t</doc>
            <type name="Matrix" c:type="const cairo_matrix_t*"/>
          </instance-parameter>
          <parameter name="x" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo-matrix.c"
                 line="388">X position. An in/out parameter</doc>
            <type name="gdouble" c:type="double*"/>
          </parameter>
          <parameter name="y" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo-matrix.c"
                 line="389">Y position. An in/out parameter</doc>
            <type name="gdouble" c:type="double*"/>
          </parameter>
        </parameters>
      </method>
      <method name="translate"
              c:identifier="cairo_matrix_translate"
              version="1.0">
        <doc xml:space="preserve"
             filename="cairo-matrix.c"
             line="180">Applies a translation by @tx, @ty to the transformation in
@matrix. The effect of the new transformation is to first translate
the coordinates by @tx and @ty, then apply the original transformation
to the coordinates.</doc>
        <source-position filename="cairo.h" line="3199"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="matrix" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo-matrix.c"
                 line="182">a #cairo_matrix_t</doc>
            <type name="Matrix" c:type="cairo_matrix_t*"/>
          </instance-parameter>
          <parameter name="tx" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo-matrix.c"
                 line="183">amount to translate in the X direction</doc>
            <type name="gdouble" c:type="double"/>
          </parameter>
          <parameter name="ty" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo-matrix.c"
                 line="184">amount to translate in the Y direction</doc>
            <type name="gdouble" c:type="double"/>
          </parameter>
        </parameters>
      </method>
    </record>
    <enumeration name="Operator"
                 version="1.0"
                 glib:type-name="cairo_operator_t"
                 glib:get-type="cairo_gobject_operator_get_type"
                 c:type="cairo_operator_t">
      <doc xml:space="preserve"
           filename="cairo.h"
           line="581">#cairo_operator_t is used to set the compositing operator for all cairo
drawing operations.

The default operator is %CAIRO_OPERATOR_OVER.

The operators marked as &lt;firstterm&gt;unbounded&lt;/firstterm&gt; modify their
destination even outside of the mask layer (that is, their effect is not
bound by the mask layer).  However, their effect can still be limited by
way of clipping.

To keep things simple, the operator descriptions here
document the behavior for when both source and destination are either fully
transparent or fully opaque.  The actual implementation works for
translucent layers too.
For a more detailed explanation of the effects of each operator, including
the mathematical definitions, see
&lt;ulink url="https://cairographics.org/operators/"&gt;https://cairographics.org/operators/&lt;/ulink&gt;.</doc>
      <member name="clear"
              value="0"
              c:identifier="CAIRO_OPERATOR_CLEAR"
              glib:nick="clear"
              glib:name="CAIRO_OPERATOR_CLEAR">
        <doc xml:space="preserve"
             filename="cairo.h"
             line="583">clear destination layer (bounded) (Since 1.0)</doc>
      </member>
      <member name="source"
              value="1"
              c:identifier="CAIRO_OPERATOR_SOURCE"
              glib:nick="source"
              glib:name="CAIRO_OPERATOR_SOURCE">
        <doc xml:space="preserve"
             filename="cairo.h"
             line="584">replace destination layer (bounded) (Since 1.0)</doc>
      </member>
      <member name="over"
              value="2"
              c:identifier="CAIRO_OPERATOR_OVER"
              glib:nick="over"
              glib:name="CAIRO_OPERATOR_OVER">
        <doc xml:space="preserve"
             filename="cairo.h"
             line="585">draw source layer on top of destination layer
(bounded) (Since 1.0)</doc>
      </member>
      <member name="in"
              value="3"
              c:identifier="CAIRO_OPERATOR_IN"
              glib:nick="in"
              glib:name="CAIRO_OPERATOR_IN">
        <doc xml:space="preserve"
             filename="cairo.h"
             line="587">draw source where there was destination content
(unbounded) (Since 1.0)</doc>
      </member>
      <member name="out"
              value="4"
              c:identifier="CAIRO_OPERATOR_OUT"
              glib:nick="out"
              glib:name="CAIRO_OPERATOR_OUT">
        <doc xml:space="preserve"
             filename="cairo.h"
             line="589">draw source where there was no destination
content (unbounded) (Since 1.0)</doc>
      </member>
      <member name="atop"
              value="5"
              c:identifier="CAIRO_OPERATOR_ATOP"
              glib:nick="atop"
              glib:name="CAIRO_OPERATOR_ATOP">
        <doc xml:space="preserve"
             filename="cairo.h"
             line="591">draw source on top of destination content and
only there (Since 1.0)</doc>
      </member>
      <member name="dest"
              value="6"
              c:identifier="CAIRO_OPERATOR_DEST"
              glib:nick="dest"
              glib:name="CAIRO_OPERATOR_DEST">
        <doc xml:space="preserve"
             filename="cairo.h"
             line="593">ignore the source (Since 1.0)</doc>
      </member>
      <member name="dest_over"
              value="7"
              c:identifier="CAIRO_OPERATOR_DEST_OVER"
              glib:nick="dest-over"
              glib:name="CAIRO_OPERATOR_DEST_OVER">
        <doc xml:space="preserve"
             filename="cairo.h"
             line="594">draw destination on top of source (Since 1.0)</doc>
      </member>
      <member name="dest_in"
              value="8"
              c:identifier="CAIRO_OPERATOR_DEST_IN"
              glib:nick="dest-in"
              glib:name="CAIRO_OPERATOR_DEST_IN">
        <doc xml:space="preserve"
             filename="cairo.h"
             line="595">leave destination only where there was
source content (unbounded) (Since 1.0)</doc>
      </member>
      <member name="dest_out"
              value="9"
              c:identifier="CAIRO_OPERATOR_DEST_OUT"
              glib:nick="dest-out"
              glib:name="CAIRO_OPERATOR_DEST_OUT">
        <doc xml:space="preserve"
             filename="cairo.h"
             line="597">leave destination only where there was no
source content (Since 1.0)</doc>
      </member>
      <member name="dest_atop"
              value="10"
              c:identifier="CAIRO_OPERATOR_DEST_ATOP"
              glib:nick="dest-atop"
              glib:name="CAIRO_OPERATOR_DEST_ATOP">
        <doc xml:space="preserve"
             filename="cairo.h"
             line="599">leave destination on top of source content
and only there (unbounded) (Since 1.0)</doc>
      </member>
      <member name="xor"
              value="11"
              c:identifier="CAIRO_OPERATOR_XOR"
              glib:nick="xor"
              glib:name="CAIRO_OPERATOR_XOR">
        <doc xml:space="preserve"
             filename="cairo.h"
             line="601">source and destination are shown where there is only
one of them (Since 1.0)</doc>
      </member>
      <member name="add"
              value="12"
              c:identifier="CAIRO_OPERATOR_ADD"
              glib:nick="add"
              glib:name="CAIRO_OPERATOR_ADD">
        <doc xml:space="preserve"
             filename="cairo.h"
             line="603">source and destination layers are accumulated (Since 1.0)</doc>
      </member>
      <member name="saturate"
              value="13"
              c:identifier="CAIRO_OPERATOR_SATURATE"
              glib:nick="saturate"
              glib:name="CAIRO_OPERATOR_SATURATE">
        <doc xml:space="preserve"
             filename="cairo.h"
             line="604">like over, but assuming source and dest are
disjoint geometries (Since 1.0)</doc>
      </member>
      <member name="multiply"
              value="14"
              c:identifier="CAIRO_OPERATOR_MULTIPLY"
              glib:nick="multiply"
              glib:name="CAIRO_OPERATOR_MULTIPLY">
        <doc xml:space="preserve"
             filename="cairo.h"
             line="606">source and destination layers are multiplied.
This causes the result to be at least as dark as the darker inputs. (Since 1.10)</doc>
      </member>
      <member name="screen"
              value="15"
              c:identifier="CAIRO_OPERATOR_SCREEN"
              glib:nick="screen"
              glib:name="CAIRO_OPERATOR_SCREEN">
        <doc xml:space="preserve"
             filename="cairo.h"
             line="608">source and destination are complemented and
multiplied. This causes the result to be at least as light as the lighter
inputs. (Since 1.10)</doc>
      </member>
      <member name="overlay"
              value="16"
              c:identifier="CAIRO_OPERATOR_OVERLAY"
              glib:nick="overlay"
              glib:name="CAIRO_OPERATOR_OVERLAY">
        <doc xml:space="preserve"
             filename="cairo.h"
             line="611">multiplies or screens, depending on the
lightness of the destination color. (Since 1.10)</doc>
      </member>
      <member name="darken"
              value="17"
              c:identifier="CAIRO_OPERATOR_DARKEN"
              glib:nick="darken"
              glib:name="CAIRO_OPERATOR_DARKEN">
        <doc xml:space="preserve"
             filename="cairo.h"
             line="613">replaces the destination with the source if it
is darker, otherwise keeps the source. (Since 1.10)</doc>
      </member>
      <member name="lighten"
              value="18"
              c:identifier="CAIRO_OPERATOR_LIGHTEN"
              glib:nick="lighten"
              glib:name="CAIRO_OPERATOR_LIGHTEN">
        <doc xml:space="preserve"
             filename="cairo.h"
             line="615">replaces the destination with the source if it
is lighter, otherwise keeps the source. (Since 1.10)</doc>
      </member>
      <member name="color_dodge"
              value="19"
              c:identifier="CAIRO_OPERATOR_COLOR_DODGE"
              glib:nick="color-dodge"
              glib:name="CAIRO_OPERATOR_COLOR_DODGE">
        <doc xml:space="preserve"
             filename="cairo.h"
             line="617">brightens the destination color to reflect
the source color. (Since 1.10)</doc>
      </member>
      <member name="color_burn"
              value="20"
              c:identifier="CAIRO_OPERATOR_COLOR_BURN"
              glib:nick="color-burn"
              glib:name="CAIRO_OPERATOR_COLOR_BURN">
        <doc xml:space="preserve"
             filename="cairo.h"
             line="619">darkens the destination color to reflect
the source color. (Since 1.10)</doc>
      </member>
      <member name="hard_light"
              value="21"
              c:identifier="CAIRO_OPERATOR_HARD_LIGHT"
              glib:nick="hard-light"
              glib:name="CAIRO_OPERATOR_HARD_LIGHT">
        <doc xml:space="preserve"
             filename="cairo.h"
             line="621">Multiplies or screens, dependent on source
color. (Since 1.10)</doc>
      </member>
      <member name="soft_light"
              value="22"
              c:identifier="CAIRO_OPERATOR_SOFT_LIGHT"
              glib:nick="soft-light"
              glib:name="CAIRO_OPERATOR_SOFT_LIGHT">
        <doc xml:space="preserve"
             filename="cairo.h"
             line="623">Darkens or lightens, dependent on source
color. (Since 1.10)</doc>
      </member>
      <member name="difference"
              value="23"
              c:identifier="CAIRO_OPERATOR_DIFFERENCE"
              glib:nick="difference"
              glib:name="CAIRO_OPERATOR_DIFFERENCE">
        <doc xml:space="preserve"
             filename="cairo.h"
             line="625">Takes the difference of the source and
destination color. (Since 1.10)</doc>
      </member>
      <member name="exclusion"
              value="24"
              c:identifier="CAIRO_OPERATOR_EXCLUSION"
              glib:nick="exclusion"
              glib:name="CAIRO_OPERATOR_EXCLUSION">
        <doc xml:space="preserve"
             filename="cairo.h"
             line="627">Produces an effect similar to difference, but
with lower contrast. (Since 1.10)</doc>
      </member>
      <member name="hsl_hue"
              value="25"
              c:identifier="CAIRO_OPERATOR_HSL_HUE"
              glib:nick="hsl-hue"
              glib:name="CAIRO_OPERATOR_HSL_HUE">
        <doc xml:space="preserve"
             filename="cairo.h"
             line="629">Creates a color with the hue of the source
and the saturation and luminosity of the target. (Since 1.10)</doc>
      </member>
      <member name="hsl_saturation"
              value="26"
              c:identifier="CAIRO_OPERATOR_HSL_SATURATION"
              glib:nick="hsl-saturation"
              glib:name="CAIRO_OPERATOR_HSL_SATURATION">
        <doc xml:space="preserve"
             filename="cairo.h"
             line="631">Creates a color with the saturation
of the source and the hue and luminosity of the target. Painting with
this mode onto a gray area produces no change. (Since 1.10)</doc>
      </member>
      <member name="hsl_color"
              value="27"
              c:identifier="CAIRO_OPERATOR_HSL_COLOR"
              glib:nick="hsl-color"
              glib:name="CAIRO_OPERATOR_HSL_COLOR">
        <doc xml:space="preserve"
             filename="cairo.h"
             line="634">Creates a color with the hue and saturation
of the source and the luminosity of the target. This preserves the gray
levels of the target and is useful for coloring monochrome images or
tinting color images. (Since 1.10)</doc>
      </member>
      <member name="hsl_luminosity"
              value="28"
              c:identifier="CAIRO_OPERATOR_HSL_LUMINOSITY"
              glib:nick="hsl-luminosity"
              glib:name="CAIRO_OPERATOR_HSL_LUMINOSITY">
        <doc xml:space="preserve"
             filename="cairo.h"
             line="638">Creates a color with the luminosity of
the source and the hue and saturation of the target. This produces an
inverse effect to @CAIRO_OPERATOR_HSL_COLOR. (Since 1.10)</doc>
      </member>
    </enumeration>
    <constant name="PDF_OUTLINE_ROOT"
              value="0"
              c:type="CAIRO_PDF_OUTLINE_ROOT"
              version="1.16">
      <doc xml:space="preserve"
           filename="cairo-pdf-surface.c"
           line="845">The root outline item in cairo_pdf_surface_add_outline().</doc>
      <source-position filename="cairo-pdf.h" line="111"/>
      <type name="gint" c:type="gint"/>
    </constant>
    <record name="Path"
            c:type="cairo_path_t"
            version="1.0"
            glib:type-name="cairo_path_t"
            glib:get-type="cairo_gobject_path_get_type"
            c:symbol-prefix="gobject_path">
      <doc xml:space="preserve"
           filename="cairo.h"
           line="2218">A data structure for holding a path. This data structure serves as
the return value for cairo_copy_path() and
cairo_copy_path_flat() as well the input value for
cairo_append_path().

See #cairo_path_data_t for hints on how to iterate over the
actual data within the path.

The num_data member gives the number of elements in the data
array. This number is larger than the number of independent path
portions (defined in #cairo_path_data_type_t), since the data
includes both headers and coordinates for each portion.</doc>
      <source-position filename="cairo.h" line="2243"/>
      <field name="status" writable="1">
        <doc xml:space="preserve"
             filename="cairo.h"
             line="2220">the current error status</doc>
        <type name="Status" c:type="cairo_status_t"/>
      </field>
      <field name="data" writable="1">
        <doc xml:space="preserve"
             filename="cairo.h"
             line="2221">the elements in the path</doc>
        <type name="PathData" c:type="cairo_path_data_t*"/>
      </field>
      <field name="num_data" writable="1">
        <doc xml:space="preserve"
             filename="cairo.h"
             line="2222">the number of elements in the data array</doc>
        <type name="gint" c:type="int"/>
      </field>
      <method name="destroy"
              c:identifier="cairo_path_destroy"
              version="1.0"
              introspectable="0">
        <doc xml:space="preserve"
             filename="cairo-path.c"
             line="349">Immediately releases all memory associated with @path. After a call
to cairo_path_destroy() the @path pointer is no longer valid and
should not be used further.

Note: cairo_path_destroy() should only be called with a
pointer to a #cairo_path_t returned by a cairo function. Any path
that is created manually (ie. outside of cairo) should be destroyed
manually as well.</doc>
        <source-position filename="cairo.h" line="2256"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="path" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo-path.c"
                 line="351">a path previously returned by either cairo_copy_path() or
cairo_copy_path_flat().</doc>
            <type name="Path" c:type="cairo_path_t*"/>
          </instance-parameter>
        </parameters>
      </method>
    </record>
    <union name="PathData" c:type="cairo_path_data_t" version="1.0">
      <doc xml:space="preserve"
           filename="cairo.h"
           line="2139">#cairo_path_data_t is used to represent the path data inside a
#cairo_path_t.

The data structure is designed to try to balance the demands of
efficiency and ease-of-use. A path is represented as an array of
#cairo_path_data_t, which is a union of headers and points.

Each portion of the path is represented by one or more elements in
the array, (one header followed by 0 or more points). The length
value of the header is the number of array elements for the current
portion including the header, (ie. length == 1 + # of points), and
where the number of points for each element type is as follows:

&lt;programlisting&gt;
    %CAIRO_PATH_MOVE_TO:     1 point
    %CAIRO_PATH_LINE_TO:     1 point
    %CAIRO_PATH_CURVE_TO:    3 points
    %CAIRO_PATH_CLOSE_PATH:  0 points
&lt;/programlisting&gt;

The semantics and ordering of the coordinate values are consistent
with cairo_move_to(), cairo_line_to(), cairo_curve_to(), and
cairo_close_path().

Here is sample code for iterating through a #cairo_path_t:

&lt;informalexample&gt;&lt;programlisting&gt;
     int i;
     cairo_path_t *path;
     cairo_path_data_t *data;
&amp;nbsp;
     path = cairo_copy_path (cr);
&amp;nbsp;
     for (i=0; i &lt; path-&gt;num_data; i += path-&gt;data[i].header.length) {
         data = &amp;amp;path-&gt;data[i];
         switch (data-&gt;header.type) {
         case CAIRO_PATH_MOVE_TO:
             do_move_to_things (data[1].point.x, data[1].point.y);
             break;
         case CAIRO_PATH_LINE_TO:
             do_line_to_things (data[1].point.x, data[1].point.y);
             break;
         case CAIRO_PATH_CURVE_TO:
             do_curve_to_things (data[1].point.x, data[1].point.y,
                                 data[2].point.x, data[2].point.y,
                                 data[3].point.x, data[3].point.y);
             break;
         case CAIRO_PATH_CLOSE_PATH:
             do_close_path_things ();
             break;
         }
     }
     cairo_path_destroy (path);
&lt;/programlisting&gt;&lt;/informalexample&gt;

As of cairo 1.4, cairo does not mind if there are more elements in
a portion of the path than needed.  Such elements can be used by
users of the cairo API to hold extra values in the path data
structure.  For this reason, it is recommended that applications
always use &lt;literal&gt;data-&gt;header.length&lt;/literal&gt; to
iterate over the path data, instead of hardcoding the number of
elements for each element type.</doc>
      <source-position filename="cairo.h" line="2216"/>
      <record name="header" c:type="header">
        <source-position filename="cairo.h" line="2212"/>
        <field name="type" writable="1">
          <type name="PathDataType" c:type="cairo_path_data_type_t"/>
        </field>
        <field name="length" writable="1">
          <type name="gint" c:type="int"/>
        </field>
      </record>
      <record name="point" c:type="point">
        <source-position filename="cairo.h" line="2215"/>
        <field name="x" writable="1">
          <type name="gdouble" c:type="double"/>
        </field>
        <field name="y" writable="1">
          <type name="gdouble" c:type="double"/>
        </field>
      </record>
    </union>
    <enumeration name="PathDataType"
                 version="1.0"
                 glib:type-name="cairo_path_data_type_t"
                 glib:get-type="cairo_gobject_path_data_type_get_type"
                 c:type="cairo_path_data_type_t">
      <doc xml:space="preserve"
           filename="cairo.h"
           line="2119">#cairo_path_data_t is used to describe the type of one portion
of a path when represented as a #cairo_path_t.
See #cairo_path_data_t for details.</doc>
      <member name="move_to"
              value="0"
              c:identifier="CAIRO_PATH_MOVE_TO"
              glib:nick="move-to"
              glib:name="CAIRO_PATH_MOVE_TO">
        <doc xml:space="preserve"
             filename="cairo.h"
             line="2121">A move-to operation, since 1.0</doc>
      </member>
      <member name="line_to"
              value="1"
              c:identifier="CAIRO_PATH_LINE_TO"
              glib:nick="line-to"
              glib:name="CAIRO_PATH_LINE_TO">
        <doc xml:space="preserve"
             filename="cairo.h"
             line="2122">A line-to operation, since 1.0</doc>
      </member>
      <member name="curve_to"
              value="2"
              c:identifier="CAIRO_PATH_CURVE_TO"
              glib:nick="curve-to"
              glib:name="CAIRO_PATH_CURVE_TO">
        <doc xml:space="preserve"
             filename="cairo.h"
             line="2123">A curve-to operation, since 1.0</doc>
      </member>
      <member name="close_path"
              value="3"
              c:identifier="CAIRO_PATH_CLOSE_PATH"
              glib:nick="close-path"
              glib:name="CAIRO_PATH_CLOSE_PATH">
        <doc xml:space="preserve"
             filename="cairo.h"
             line="2124">A close-path operation, since 1.0</doc>
      </member>
    </enumeration>
    <record name="Pattern"
            c:type="cairo_pattern_t"
            opaque="1"
            version="1.0"
            glib:type-name="cairo_pattern_t"
            glib:get-type="cairo_gobject_pattern_get_type"
            c:symbol-prefix="gobject_pattern">
      <doc xml:space="preserve"
           filename="cairo.h"
           line="207">A #cairo_pattern_t represents a source when drawing onto a
surface. There are different subtypes of #cairo_pattern_t,
for different types of sources; for example,
cairo_pattern_create_rgb() creates a pattern for a solid
opaque color.

Other than various
&lt;function&gt;cairo_pattern_create_&lt;emphasis&gt;type&lt;/emphasis&gt;()&lt;/function&gt;
functions, some of the pattern types can be implicitly created using various
&lt;function&gt;cairo_set_source_&lt;emphasis&gt;type&lt;/emphasis&gt;()&lt;/function&gt; functions;
for example cairo_set_source_rgb().

The type of a pattern can be queried with cairo_pattern_get_type().

Memory management of #cairo_pattern_t is done with
cairo_pattern_reference() and cairo_pattern_destroy().</doc>
      <source-position filename="cairo.h" line="229"/>
      <method name="add_color_stop_rgb"
              c:identifier="cairo_pattern_add_color_stop_rgb"
              version="1.0">
        <doc xml:space="preserve"
             filename="cairo-pattern.c"
             line="1892">Adds an opaque color stop to a gradient pattern. The offset
specifies the location along the gradient's control vector. For
example, a linear gradient's control vector is from (x0,y0) to
(x1,y1) while a radial gradient's control vector is from any point
on the start circle to the corresponding point on the end circle.

The color is specified in the same way as in cairo_set_source_rgb().

If two (or more) stops are specified with identical offset values,
they will be sorted according to the order in which the stops are
added, (stops added earlier will compare less than stops added
later). This can be useful for reliably making sharp color
transitions instead of the typical blend.


Note: If the pattern is not a gradient pattern, (eg. a linear or
radial pattern), then the pattern will be put into an error status
with a status of %CAIRO_STATUS_PATTERN_TYPE_MISMATCH.</doc>
        <source-position filename="cairo.h" line="2997"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="pattern" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo-pattern.c"
                 line="1894">a #cairo_pattern_t</doc>
            <type name="Pattern" c:type="cairo_pattern_t*"/>
          </instance-parameter>
          <parameter name="offset" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo-pattern.c"
                 line="1895">an offset in the range [0.0 .. 1.0]</doc>
            <type name="gdouble" c:type="double"/>
          </parameter>
          <parameter name="red" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo-pattern.c"
                 line="1896">red component of color</doc>
            <type name="gdouble" c:type="double"/>
          </parameter>
          <parameter name="green" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo-pattern.c"
                 line="1897">green component of color</doc>
            <type name="gdouble" c:type="double"/>
          </parameter>
          <parameter name="blue" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo-pattern.c"
                 line="1898">blue component of color</doc>
            <type name="gdouble" c:type="double"/>
          </parameter>
        </parameters>
      </method>
      <method name="add_color_stop_rgba"
              c:identifier="cairo_pattern_add_color_stop_rgba"
              version="1.0">
        <doc xml:space="preserve"
             filename="cairo-pattern.c"
             line="1931">Adds a translucent color stop to a gradient pattern. The offset
specifies the location along the gradient's control vector. For
example, a linear gradient's control vector is from (x0,y0) to
(x1,y1) while a radial gradient's control vector is from any point
on the start circle to the corresponding point on the end circle.

The color is specified in the same way as in cairo_set_source_rgba().

If two (or more) stops are specified with identical offset values,
they will be sorted according to the order in which the stops are
added, (stops added earlier will compare less than stops added
later). This can be useful for reliably making sharp color
transitions instead of the typical blend.

Note: If the pattern is not a gradient pattern, (eg. a linear or
radial pattern), then the pattern will be put into an error status
with a status of %CAIRO_STATUS_PATTERN_TYPE_MISMATCH.</doc>
        <source-position filename="cairo.h" line="3002"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="pattern" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo-pattern.c"
                 line="1933">a #cairo_pattern_t</doc>
            <type name="Pattern" c:type="cairo_pattern_t*"/>
          </instance-parameter>
          <parameter name="offset" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo-pattern.c"
                 line="1934">an offset in the range [0.0 .. 1.0]</doc>
            <type name="gdouble" c:type="double"/>
          </parameter>
          <parameter name="red" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo-pattern.c"
                 line="1935">red component of color</doc>
            <type name="gdouble" c:type="double"/>
          </parameter>
          <parameter name="green" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo-pattern.c"
                 line="1936">green component of color</doc>
            <type name="gdouble" c:type="double"/>
          </parameter>
          <parameter name="blue" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo-pattern.c"
                 line="1937">blue component of color</doc>
            <type name="gdouble" c:type="double"/>
          </parameter>
          <parameter name="alpha" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo-pattern.c"
                 line="1938">alpha component of color</doc>
            <type name="gdouble" c:type="double"/>
          </parameter>
        </parameters>
      </method>
      <method name="destroy"
              c:identifier="cairo_pattern_destroy"
              version="1.0"
              introspectable="0">
        <doc xml:space="preserve"
             filename="cairo-pattern.c"
             line="1136">Decreases the reference count on @pattern by one. If the result is
zero, then @pattern and all associated resources are freed.  See
cairo_pattern_reference().</doc>
        <source-position filename="cairo.h" line="2934"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="pattern" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo-pattern.c"
                 line="1138">a #cairo_pattern_t</doc>
            <type name="Pattern" c:type="cairo_pattern_t*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_color_stop_count"
              c:identifier="cairo_pattern_get_color_stop_count"
              version="1.4">
        <doc xml:space="preserve"
             filename="cairo-pattern.c"
             line="4340">Gets the number of color stops specified in the given gradient
pattern.</doc>
        <source-position filename="cairo.h" line="3141"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cairo-pattern.c"
               line="4348">%CAIRO_STATUS_SUCCESS, or
%CAIRO_STATUS_PATTERN_TYPE_MISMATCH if @pattern is not a gradient
pattern.</doc>
          <type name="Status" c:type="cairo_status_t"/>
        </return-value>
        <parameters>
          <instance-parameter name="pattern" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo-pattern.c"
                 line="4342">a #cairo_pattern_t</doc>
            <type name="Pattern" c:type="cairo_pattern_t*"/>
          </instance-parameter>
          <parameter name="count" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo-pattern.c"
                 line="4343">return value for the number of color stops, or %NULL</doc>
            <type name="gint" c:type="int*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_color_stop_rgba"
              c:identifier="cairo_pattern_get_color_stop_rgba"
              version="1.4">
        <doc xml:space="preserve"
             filename="cairo-pattern.c"
             line="4284">Gets the color and offset information at the given @index for a
gradient pattern.  Values of @index range from 0 to n-1
where n is the number returned
by cairo_pattern_get_color_stop_count().

Note that the color and alpha values are not premultiplied.</doc>
        <source-position filename="cairo.h" line="3135"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cairo-pattern.c"
               line="4301">%CAIRO_STATUS_SUCCESS, or %CAIRO_STATUS_INVALID_INDEX
if @index is not valid for the given pattern.  If the pattern is
not a gradient pattern, %CAIRO_STATUS_PATTERN_TYPE_MISMATCH is
returned.</doc>
          <type name="Status" c:type="cairo_status_t"/>
        </return-value>
        <parameters>
          <instance-parameter name="pattern" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo-pattern.c"
                 line="4286">a #cairo_pattern_t</doc>
            <type name="Pattern" c:type="cairo_pattern_t*"/>
          </instance-parameter>
          <parameter name="index" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo-pattern.c"
                 line="4287">index of the stop to return data for</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="offset" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo-pattern.c"
                 line="4288">return value for the offset of the stop, or %NULL</doc>
            <type name="gdouble" c:type="double*"/>
          </parameter>
          <parameter name="red" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo-pattern.c"
                 line="4289">return value for red component of color, or %NULL</doc>
            <type name="gdouble" c:type="double*"/>
          </parameter>
          <parameter name="green" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo-pattern.c"
                 line="4290">return value for green component of color, or %NULL</doc>
            <type name="gdouble" c:type="double*"/>
          </parameter>
          <parameter name="blue" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo-pattern.c"
                 line="4291">return value for blue component of color, or %NULL</doc>
            <type name="gdouble" c:type="double*"/>
          </parameter>
          <parameter name="alpha" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo-pattern.c"
                 line="4292">return value for alpha component of color, or %NULL</doc>
            <type name="gdouble" c:type="double*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_dither"
              c:identifier="cairo_pattern_get_dither"
              version="1.18">
        <doc xml:space="preserve"
             filename="cairo-pattern.c"
             line="2108">Gets the current dithering mode, as set by
cairo_pattern_set_dither().</doc>
        <source-position filename="cairo.h" line="474"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cairo-pattern.c"
               line="2115">the current dithering mode.</doc>
          <type name="Dither" c:type="cairo_dither_t"/>
        </return-value>
        <parameters>
          <instance-parameter name="pattern" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo-pattern.c"
                 line="2110">a #cairo_pattern_t</doc>
            <type name="Pattern" c:type="cairo_pattern_t*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_extend"
              c:identifier="cairo_pattern_get_extend"
              version="1.0">
        <doc xml:space="preserve"
             filename="cairo-pattern.c"
             line="2172">Gets the current extend mode for a pattern.  See #cairo_extend_t
for details on the semantics of each extend strategy.</doc>
        <source-position filename="cairo.h" line="3087"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cairo-pattern.c"
               line="2179">the current extend strategy used for drawing the
pattern.</doc>
          <type name="Extend" c:type="cairo_extend_t"/>
        </return-value>
        <parameters>
          <instance-parameter name="pattern" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo-pattern.c"
                 line="2174">a #cairo_pattern_t</doc>
            <type name="Pattern" c:type="cairo_pattern_t*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_filter"
              c:identifier="cairo_pattern_get_filter"
              version="1.0">
        <doc xml:space="preserve"
             filename="cairo-pattern.c"
             line="2091">Gets the current filter for a pattern.  See #cairo_filter_t
for details on each filter.</doc>
        <source-position filename="cairo.h" line="3122"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cairo-pattern.c"
               line="2098">the current filter used for resizing the pattern.</doc>
          <type name="Filter" c:type="cairo_filter_t"/>
        </return-value>
        <parameters>
          <instance-parameter name="pattern" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo-pattern.c"
                 line="2093">a #cairo_pattern_t</doc>
            <type name="Pattern" c:type="cairo_pattern_t*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_linear_points"
              c:identifier="cairo_pattern_get_linear_points"
              version="1.4">
        <doc xml:space="preserve"
             filename="cairo-pattern.c"
             line="4373">Gets the gradient endpoints for a linear gradient.</doc>
        <source-position filename="cairo.h" line="3145"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cairo-pattern.c"
               line="4383">%CAIRO_STATUS_SUCCESS, or
%CAIRO_STATUS_PATTERN_TYPE_MISMATCH if @pattern is not a linear
gradient pattern.</doc>
          <type name="Status" c:type="cairo_status_t"/>
        </return-value>
        <parameters>
          <instance-parameter name="pattern" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo-pattern.c"
                 line="4375">a #cairo_pattern_t</doc>
            <type name="Pattern" c:type="cairo_pattern_t*"/>
          </instance-parameter>
          <parameter name="x0" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo-pattern.c"
                 line="4376">return value for the x coordinate of the first point, or %NULL</doc>
            <type name="gdouble" c:type="double*"/>
          </parameter>
          <parameter name="y0" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo-pattern.c"
                 line="4377">return value for the y coordinate of the first point, or %NULL</doc>
            <type name="gdouble" c:type="double*"/>
          </parameter>
          <parameter name="x1" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo-pattern.c"
                 line="4378">return value for the x coordinate of the second point, or %NULL</doc>
            <type name="gdouble" c:type="double*"/>
          </parameter>
          <parameter name="y1" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo-pattern.c"
                 line="4379">return value for the y coordinate of the second point, or %NULL</doc>
            <type name="gdouble" c:type="double*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_matrix"
              c:identifier="cairo_pattern_get_matrix"
              version="1.0">
        <doc xml:space="preserve"
             filename="cairo-pattern.c"
             line="2044">Stores the pattern's transformation matrix into @matrix.</doc>
        <source-position filename="cairo.h" line="3048"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="pattern" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo-pattern.c"
                 line="2046">a #cairo_pattern_t</doc>
            <type name="Pattern" c:type="cairo_pattern_t*"/>
          </instance-parameter>
          <parameter name="matrix" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo-pattern.c"
                 line="2047">return value for the matrix</doc>
            <type name="Matrix" c:type="cairo_matrix_t*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_radial_circles"
              c:identifier="cairo_pattern_get_radial_circles"
              version="1.4">
        <doc xml:space="preserve"
             filename="cairo-pattern.c"
             line="4414">Gets the gradient endpoint circles for a radial gradient, each
specified as a center coordinate and a radius.</doc>
        <source-position filename="cairo.h" line="3150"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cairo-pattern.c"
               line="4427">%CAIRO_STATUS_SUCCESS, or
%CAIRO_STATUS_PATTERN_TYPE_MISMATCH if @pattern is not a radial
gradient pattern.</doc>
          <type name="Status" c:type="cairo_status_t"/>
        </return-value>
        <parameters>
          <instance-parameter name="pattern" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo-pattern.c"
                 line="4416">a #cairo_pattern_t</doc>
            <type name="Pattern" c:type="cairo_pattern_t*"/>
          </instance-parameter>
          <parameter name="x0" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo-pattern.c"
                 line="4417">return value for the x coordinate of the center of the first circle, or %NULL</doc>
            <type name="gdouble" c:type="double*"/>
          </parameter>
          <parameter name="y0" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo-pattern.c"
                 line="4418">return value for the y coordinate of the center of the first circle, or %NULL</doc>
            <type name="gdouble" c:type="double*"/>
          </parameter>
          <parameter name="r0" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo-pattern.c"
                 line="4419">return value for the radius of the first circle, or %NULL</doc>
            <type name="gdouble" c:type="double*"/>
          </parameter>
          <parameter name="x1" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo-pattern.c"
                 line="4420">return value for the x coordinate of the center of the second circle, or %NULL</doc>
            <type name="gdouble" c:type="double*"/>
          </parameter>
          <parameter name="y1" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo-pattern.c"
                 line="4421">return value for the y coordinate of the center of the second circle, or %NULL</doc>
            <type name="gdouble" c:type="double*"/>
          </parameter>
          <parameter name="r1" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo-pattern.c"
                 line="4422">return value for the radius of the second circle, or %NULL</doc>
            <type name="gdouble" c:type="double*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_reference_count"
              c:identifier="cairo_pattern_get_reference_count"
              version="1.4"
              introspectable="0">
        <doc xml:space="preserve"
             filename="cairo-pattern.c"
             line="1170">Returns the current reference count of @pattern.</doc>
        <source-position filename="cairo.h" line="2937"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cairo-pattern.c"
               line="1176">the current reference count of @pattern.  If the
object is a nil object, 0 will be returned.</doc>
          <type name="guint" c:type="unsigned int"/>
        </return-value>
        <parameters>
          <instance-parameter name="pattern" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo-pattern.c"
                 line="1172">a #cairo_pattern_t</doc>
            <type name="Pattern" c:type="cairo_pattern_t*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_rgba"
              c:identifier="cairo_pattern_get_rgba"
              version="1.4">
        <doc xml:space="preserve"
             filename="cairo-pattern.c"
             line="4205">Gets the solid color for a solid color pattern.

Note that the color and alpha values are not premultiplied.</doc>
        <source-position filename="cairo.h" line="3125"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cairo-pattern.c"
               line="4217">%CAIRO_STATUS_SUCCESS, or
%CAIRO_STATUS_PATTERN_TYPE_MISMATCH if the pattern is not a solid
color pattern.</doc>
          <type name="Status" c:type="cairo_status_t"/>
        </return-value>
        <parameters>
          <instance-parameter name="pattern" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo-pattern.c"
                 line="4207">a #cairo_pattern_t</doc>
            <type name="Pattern" c:type="cairo_pattern_t*"/>
          </instance-parameter>
          <parameter name="red" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo-pattern.c"
                 line="4208">return value for red component of color, or %NULL</doc>
            <type name="gdouble" c:type="double*"/>
          </parameter>
          <parameter name="green" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo-pattern.c"
                 line="4209">return value for green component of color, or %NULL</doc>
            <type name="gdouble" c:type="double*"/>
          </parameter>
          <parameter name="blue" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo-pattern.c"
                 line="4210">return value for blue component of color, or %NULL</doc>
            <type name="gdouble" c:type="double*"/>
          </parameter>
          <parameter name="alpha" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo-pattern.c"
                 line="4211">return value for alpha component of color, or %NULL</doc>
            <type name="gdouble" c:type="double*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_surface"
              c:identifier="cairo_pattern_get_surface"
              version="1.4">
        <doc xml:space="preserve"
             filename="cairo-pattern.c"
             line="4251">Gets the surface of a surface pattern.  The reference returned in
@surface is owned by the pattern; the caller should call
cairo_surface_reference() if the surface is to be retained.</doc>
        <source-position filename="cairo.h" line="3130"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cairo-pattern.c"
               line="4260">%CAIRO_STATUS_SUCCESS, or
%CAIRO_STATUS_PATTERN_TYPE_MISMATCH if the pattern is not a surface
pattern.</doc>
          <type name="Status" c:type="cairo_status_t"/>
        </return-value>
        <parameters>
          <instance-parameter name="pattern" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo-pattern.c"
                 line="4253">a #cairo_pattern_t</doc>
            <type name="Pattern" c:type="cairo_pattern_t*"/>
          </instance-parameter>
          <parameter name="surface" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo-pattern.c"
                 line="4254">return value for surface of pattern, or %NULL</doc>
            <type name="Surface" c:type="cairo_surface_t**"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_type"
              c:identifier="cairo_pattern_get_type"
              version="1.2">
        <doc xml:space="preserve"
             filename="cairo-pattern.c"
             line="1100">Get the pattern's type.  See #cairo_pattern_type_t for available
types.</doc>
        <source-position filename="cairo.h" line="2994"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cairo-pattern.c"
               line="1107">The type of @pattern.</doc>
          <type name="PatternType" c:type="cairo_pattern_type_t"/>
        </return-value>
        <parameters>
          <instance-parameter name="pattern" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo-pattern.c"
                 line="1102">a #cairo_pattern_t</doc>
            <type name="Pattern" c:type="cairo_pattern_t*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_user_data"
              c:identifier="cairo_pattern_get_user_data"
              version="1.4">
        <doc xml:space="preserve"
             filename="cairo-pattern.c"
             line="1191">Return user data previously attached to @pattern using the
specified key.  If no user data has been attached with the given
key this function returns %NULL.</doc>
        <source-position filename="cairo.h" line="2943"/>
        <return-value transfer-ownership="none" nullable="1">
          <doc xml:space="preserve"
               filename="cairo-pattern.c"
               line="1201">the user data previously attached or %NULL.</doc>
          <type name="gpointer" c:type="void*"/>
        </return-value>
        <parameters>
          <instance-parameter name="pattern" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo-pattern.c"
                 line="1193">a #cairo_pattern_t</doc>
            <type name="Pattern" c:type="cairo_pattern_t*"/>
          </instance-parameter>
          <parameter name="key" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo-pattern.c"
                 line="1194">the address of the #cairo_user_data_key_t the user data was
attached to</doc>
            <type name="UserDataKey" c:type="const cairo_user_data_key_t*"/>
          </parameter>
        </parameters>
      </method>
      <method name="reference"
              c:identifier="cairo_pattern_reference"
              version="1.0"
              introspectable="0">
        <doc xml:space="preserve"
             filename="cairo-pattern.c"
             line="1071">Increases the reference count on @pattern by one. This prevents
@pattern from being destroyed until a matching call to
cairo_pattern_destroy() is made.

Use cairo_pattern_get_reference_count() to get the number of
references to a #cairo_pattern_t.</doc>
        <source-position filename="cairo.h" line="2931"/>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve"
               filename="cairo-pattern.c"
               line="1082">the referenced #cairo_pattern_t.</doc>
          <type name="Pattern" c:type="cairo_pattern_t*"/>
        </return-value>
        <parameters>
          <instance-parameter name="pattern" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo-pattern.c"
                 line="1073">a #cairo_pattern_t</doc>
            <type name="Pattern" c:type="cairo_pattern_t*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="set_dither"
              c:identifier="cairo_pattern_set_dither"
              version="1.18">
        <doc xml:space="preserve"
             filename="cairo-pattern.c"
             line="2125">Set the dithering mode of the rasterizer used for drawing shapes.
This value is a hint, and a particular backend may or may not support
a particular value.  At the current time, only pixman is supported.</doc>
        <source-position filename="cairo.h" line="471"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="pattern" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo-pattern.c"
                 line="2127">a #cairo_pattern_t</doc>
            <type name="Pattern" c:type="cairo_pattern_t*"/>
          </instance-parameter>
          <parameter name="dither" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo-pattern.c"
                 line="2128">a #cairo_dither_t describing the new dithering mode</doc>
            <type name="Dither" c:type="cairo_dither_t"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_extend"
              c:identifier="cairo_pattern_set_extend"
              version="1.0">
        <doc xml:space="preserve"
             filename="cairo-pattern.c"
             line="2147">Sets the mode to be used for drawing outside the area of a pattern.
See #cairo_extend_t for details on the semantics of each extend
strategy.

The default extend mode is %CAIRO_EXTEND_NONE for surface patterns
and %CAIRO_EXTEND_PAD for gradient patterns.</doc>
        <source-position filename="cairo.h" line="3084"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="pattern" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo-pattern.c"
                 line="2149">a #cairo_pattern_t</doc>
            <type name="Pattern" c:type="cairo_pattern_t*"/>
          </instance-parameter>
          <parameter name="extend" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo-pattern.c"
                 line="2150">a #cairo_extend_t describing how the area outside of the
pattern will be drawn</doc>
            <type name="Extend" c:type="cairo_extend_t"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_filter"
              c:identifier="cairo_pattern_set_filter"
              version="1.0">
        <doc xml:space="preserve"
             filename="cairo-pattern.c"
             line="2059">Sets the filter to be used for resizing when using this pattern.
See #cairo_filter_t for details on each filter.

* Note that you might want to control filtering even when you do not
have an explicit #cairo_pattern_t object, (for example when using
cairo_set_source_surface()). In these cases, it is convenient to
use cairo_get_source() to get access to the pattern that cairo
creates implicitly. For example:

&lt;informalexample&gt;&lt;programlisting&gt;
cairo_set_source_surface (cr, image, x, y);
cairo_pattern_set_filter (cairo_get_source (cr), CAIRO_FILTER_NEAREST);
&lt;/programlisting&gt;&lt;/informalexample&gt;</doc>
        <source-position filename="cairo.h" line="3119"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="pattern" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo-pattern.c"
                 line="2061">a #cairo_pattern_t</doc>
            <type name="Pattern" c:type="cairo_pattern_t*"/>
          </instance-parameter>
          <parameter name="filter" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo-pattern.c"
                 line="2062">a #cairo_filter_t describing the filter to use for resizing
the pattern</doc>
            <type name="Filter" c:type="cairo_filter_t"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_matrix"
              c:identifier="cairo_pattern_set_matrix"
              version="1.0">
        <doc xml:space="preserve"
             filename="cairo-pattern.c"
             line="1988">Sets the pattern's transformation matrix to @matrix. This matrix is
a transformation from user space to pattern space.

When a pattern is first created it always has the identity matrix
for its transformation matrix, which means that pattern space is
initially identical to user space.

Important: Please note that the direction of this transformation
matrix is from user space to pattern space. This means that if you
imagine the flow from a pattern to user space (and on to device
space), then coordinates in that flow will be transformed by the
inverse of the pattern matrix.

For example, if you want to make a pattern appear twice as large as
it does by default the correct code to use is:

&lt;informalexample&gt;&lt;programlisting&gt;
cairo_matrix_init_scale (&amp;amp;matrix, 0.5, 0.5);
cairo_pattern_set_matrix (pattern, &amp;amp;matrix);
&lt;/programlisting&gt;&lt;/informalexample&gt;

Meanwhile, using values of 2.0 rather than 0.5 in the code above
would cause the pattern to appear at half of its default size.

Also, please note the discussion of the user-space locking
semantics of cairo_set_source().</doc>
        <source-position filename="cairo.h" line="3044"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="pattern" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo-pattern.c"
                 line="1990">a #cairo_pattern_t</doc>
            <type name="Pattern" c:type="cairo_pattern_t*"/>
          </instance-parameter>
          <parameter name="matrix" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo-pattern.c"
                 line="1991">a #cairo_matrix_t</doc>
            <type name="Matrix" c:type="const cairo_matrix_t*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_user_data"
              c:identifier="cairo_pattern_set_user_data"
              version="1.4"
              introspectable="0">
        <doc xml:space="preserve"
             filename="cairo-pattern.c"
             line="1213">Attach user data to @pattern.  To remove user data from a surface,
call this function with the key that was used to set it and %NULL
for @data.</doc>
        <source-position filename="cairo.h" line="2947"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cairo-pattern.c"
               line="1226">%CAIRO_STATUS_SUCCESS or %CAIRO_STATUS_NO_MEMORY if a
slot could not be allocated for the user data.</doc>
          <type name="Status" c:type="cairo_status_t"/>
        </return-value>
        <parameters>
          <instance-parameter name="pattern" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo-pattern.c"
                 line="1215">a #cairo_pattern_t</doc>
            <type name="Pattern" c:type="cairo_pattern_t*"/>
          </instance-parameter>
          <parameter name="key" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo-pattern.c"
                 line="1216">the address of a #cairo_user_data_key_t to attach the user data to</doc>
            <type name="UserDataKey" c:type="const cairo_user_data_key_t*"/>
          </parameter>
          <parameter name="user_data"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve"
                 filename="cairo-pattern.c"
                 line="1217">the user data to attach to the #cairo_pattern_t</doc>
            <type name="gpointer" c:type="void*"/>
          </parameter>
          <parameter name="destroy" transfer-ownership="none" scope="async">
            <doc xml:space="preserve"
                 filename="cairo-pattern.c"
                 line="1218">a #cairo_destroy_func_t which will be called when the
#cairo_t is destroyed or when new user data is attached using the
same key.</doc>
            <type name="DestroyFunc" c:type="cairo_destroy_func_t"/>
          </parameter>
        </parameters>
      </method>
      <method name="status" c:identifier="cairo_pattern_status" version="1.0">
        <doc xml:space="preserve"
             filename="cairo-pattern.c"
             line="1117">Checks whether an error has previously occurred for this
pattern.</doc>
        <source-position filename="cairo.h" line="2940"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cairo-pattern.c"
               line="1124">%CAIRO_STATUS_SUCCESS, %CAIRO_STATUS_NO_MEMORY,
%CAIRO_STATUS_INVALID_MATRIX, %CAIRO_STATUS_PATTERN_TYPE_MISMATCH,
or %CAIRO_STATUS_INVALID_MESH_CONSTRUCTION.</doc>
          <type name="Status" c:type="cairo_status_t"/>
        </return-value>
        <parameters>
          <instance-parameter name="pattern" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo-pattern.c"
                 line="1119">a #cairo_pattern_t</doc>
            <type name="Pattern" c:type="cairo_pattern_t*"/>
          </instance-parameter>
        </parameters>
      </method>
    </record>
    <enumeration name="PatternType"
                 version="1.2"
                 glib:type-name="cairo_pattern_type_t"
                 glib:get-type="cairo_gobject_pattern_type_get_type"
                 c:type="cairo_pattern_type_t">
      <doc xml:space="preserve"
           filename="cairo.h"
           line="2952">#cairo_pattern_type_t is used to describe the type of a given pattern.

The type of a pattern is determined by the function used to create
it. The cairo_pattern_create_rgb() and cairo_pattern_create_rgba()
functions create SOLID patterns. The remaining
cairo_pattern_create&lt;!-- --&gt; functions map to pattern types in obvious
ways.

The pattern type can be queried with cairo_pattern_get_type()

Most #cairo_pattern_t functions can be called with a pattern of any
type, (though trying to change the extend or filter for a solid
pattern will have no effect). A notable exception is
cairo_pattern_add_color_stop_rgb() and
cairo_pattern_add_color_stop_rgba() which must only be called with
gradient patterns (either LINEAR or RADIAL). Otherwise the pattern
will be shutdown and put into an error state.

New entries may be added in future versions.</doc>
      <member name="solid"
              value="0"
              c:identifier="CAIRO_PATTERN_TYPE_SOLID"
              glib:nick="solid"
              glib:name="CAIRO_PATTERN_TYPE_SOLID">
        <doc xml:space="preserve"
             filename="cairo.h"
             line="2954">The pattern is a solid (uniform)
color. It may be opaque or translucent, since 1.2.</doc>
      </member>
      <member name="surface"
              value="1"
              c:identifier="CAIRO_PATTERN_TYPE_SURFACE"
              glib:nick="surface"
              glib:name="CAIRO_PATTERN_TYPE_SURFACE">
        <doc xml:space="preserve"
             filename="cairo.h"
             line="2956">The pattern is a based on a surface (an image), since 1.2.</doc>
      </member>
      <member name="linear"
              value="2"
              c:identifier="CAIRO_PATTERN_TYPE_LINEAR"
              glib:nick="linear"
              glib:name="CAIRO_PATTERN_TYPE_LINEAR">
        <doc xml:space="preserve"
             filename="cairo.h"
             line="2957">The pattern is a linear gradient, since 1.2.</doc>
      </member>
      <member name="radial"
              value="3"
              c:identifier="CAIRO_PATTERN_TYPE_RADIAL"
              glib:nick="radial"
              glib:name="CAIRO_PATTERN_TYPE_RADIAL">
        <doc xml:space="preserve"
             filename="cairo.h"
             line="2958">The pattern is a radial gradient, since 1.2.</doc>
      </member>
      <member name="mesh"
              value="4"
              c:identifier="CAIRO_PATTERN_TYPE_MESH"
              glib:nick="mesh"
              glib:name="CAIRO_PATTERN_TYPE_MESH">
        <doc xml:space="preserve"
             filename="cairo.h"
             line="2959">The pattern is a mesh, since 1.12.</doc>
      </member>
    </enumeration>
    <enumeration name="PdfMetadata"
                 version="1.16"
                 c:type="cairo_pdf_metadata_t">
      <doc xml:space="preserve"
           filename="cairo-pdf.h"
           line="120">#cairo_pdf_metadata_t is used by the
cairo_pdf_surface_set_metadata() function specify the metadata to set.</doc>
      <source-position filename="cairo-pdf.h" line="143"/>
      <member name="title" value="0" c:identifier="CAIRO_PDF_METADATA_TITLE">
        <doc xml:space="preserve"
             filename="cairo-pdf.h"
             line="122">The document title (Since 1.16)</doc>
      </member>
      <member name="author" value="1" c:identifier="CAIRO_PDF_METADATA_AUTHOR">
        <doc xml:space="preserve"
             filename="cairo-pdf.h"
             line="123">The document author (Since 1.16)</doc>
      </member>
      <member name="subject"
              value="2"
              c:identifier="CAIRO_PDF_METADATA_SUBJECT">
        <doc xml:space="preserve"
             filename="cairo-pdf.h"
             line="124">The document subject (Since 1.16)</doc>
      </member>
      <member name="keywords"
              value="3"
              c:identifier="CAIRO_PDF_METADATA_KEYWORDS">
        <doc xml:space="preserve"
             filename="cairo-pdf.h"
             line="125">The document keywords (Since 1.16)</doc>
      </member>
      <member name="creator"
              value="4"
              c:identifier="CAIRO_PDF_METADATA_CREATOR">
        <doc xml:space="preserve"
             filename="cairo-pdf.h"
             line="126">The document creator (Since 1.16)</doc>
      </member>
      <member name="create_date"
              value="5"
              c:identifier="CAIRO_PDF_METADATA_CREATE_DATE">
        <doc xml:space="preserve"
             filename="cairo-pdf.h"
             line="127">The document creation date (Since 1.16)</doc>
      </member>
      <member name="mod_date"
              value="6"
              c:identifier="CAIRO_PDF_METADATA_MOD_DATE">
        <doc xml:space="preserve"
             filename="cairo-pdf.h"
             line="128">The document modification date (Since 1.16)</doc>
      </member>
    </enumeration>
    <enumeration name="PdfOutlineFlags"
                 version="1.16"
                 c:type="cairo_pdf_outline_flags_t">
      <doc xml:space="preserve"
           filename="cairo-pdf.h"
           line="92">#cairo_pdf_outline_flags_t is used by the
cairo_pdf_surface_add_outline() function specify the attributes of
an outline item. These flags may be bitwise-or'd to produce any
combination of flags.</doc>
      <source-position filename="cairo-pdf.h" line="109"/>
      <member name="open" value="1" c:identifier="CAIRO_PDF_OUTLINE_FLAG_OPEN">
        <doc xml:space="preserve"
             filename="cairo-pdf.h"
             line="94">The outline item defaults to open in the PDF viewer (Since 1.16)</doc>
      </member>
      <member name="bold" value="2" c:identifier="CAIRO_PDF_OUTLINE_FLAG_BOLD">
        <doc xml:space="preserve"
             filename="cairo-pdf.h"
             line="95">The outline item is displayed by the viewer in bold text (Since 1.16)</doc>
      </member>
      <member name="italic"
              value="4"
              c:identifier="CAIRO_PDF_OUTLINE_FLAG_ITALIC">
        <doc xml:space="preserve"
             filename="cairo-pdf.h"
             line="96">The outline item is displayed by the viewer in italic text (Since 1.16)</doc>
      </member>
    </enumeration>
    <enumeration name="PdfVersion" version="1.10" c:type="cairo_pdf_version_t">
      <doc xml:space="preserve"
           filename="cairo-pdf.h"
           line="46">#cairo_pdf_version_t is used to describe the version number of the PDF
specification that a generated PDF file will conform to.</doc>
      <source-position filename="cairo-pdf.h" line="63"/>
      <member name="4" value="0" c:identifier="CAIRO_PDF_VERSION_1_4">
        <doc xml:space="preserve"
             filename="cairo-pdf.h"
             line="48">The version 1.4 of the PDF specification. (Since 1.10)</doc>
      </member>
      <member name="5" value="1" c:identifier="CAIRO_PDF_VERSION_1_5">
        <doc xml:space="preserve"
             filename="cairo-pdf.h"
             line="49">The version 1.5 of the PDF specification. (Since 1.10)</doc>
      </member>
      <member name="6" value="2" c:identifier="CAIRO_PDF_VERSION_1_6">
        <doc xml:space="preserve"
             filename="cairo-pdf.h"
             line="50">The version 1.6 of the PDF specification. (Since 1.18)</doc>
      </member>
      <member name="7" value="3" c:identifier="CAIRO_PDF_VERSION_1_7">
        <doc xml:space="preserve"
             filename="cairo-pdf.h"
             line="51">The version 1.7 of the PDF specification. (Since 1.18)</doc>
      </member>
    </enumeration>
    <enumeration name="PsLevel" version="1.6" c:type="cairo_ps_level_t">
      <doc xml:space="preserve"
           filename="cairo-ps.h"
           line="50">#cairo_ps_level_t is used to describe the language level of the
PostScript Language Reference that a generated PostScript file will
conform to.</doc>
      <source-position filename="cairo-ps.h" line="64"/>
      <member name="2" value="0" c:identifier="CAIRO_PS_LEVEL_2">
        <doc xml:space="preserve"
             filename="cairo-ps.h"
             line="52">The language level 2 of the PostScript specification. (Since 1.6)</doc>
      </member>
      <member name="3" value="1" c:identifier="CAIRO_PS_LEVEL_3">
        <doc xml:space="preserve"
             filename="cairo-ps.h"
             line="53">The language level 3 of the PostScript specification. (Since 1.6)</doc>
      </member>
    </enumeration>
    <callback name="RasterSourceAcquireFunc"
              c:type="cairo_raster_source_acquire_func_t"
              version="1.12">
      <doc xml:space="preserve"
           filename="cairo.h"
           line="2764">#cairo_raster_source_acquire_func_t is the type of function which is
called when a pattern is being rendered from. It should create a surface
that provides the pixel data for the region of interest as defined by
extents, though the surface itself does not have to be limited to that
area. For convenience the surface should probably be of image type,
created with cairo_surface_create_similar_image() for the target (which
enables the number of copies to be reduced during transfer to the
device). Another option, might be to return a similar surface to the
target for explicit handling by the application of a set of cached sources
on the device. The region of sample data provided should be defined using
cairo_surface_set_device_offset() to specify the top-left corner of the
sample data (along with width and height of the surface).</doc>
      <source-position filename="cairo.h" line="2789"/>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve"
             filename="cairo.h"
             line="2784">a #cairo_surface_t</doc>
        <type name="Surface" c:type="cairo_surface_t*"/>
      </return-value>
      <parameters>
        <parameter name="pattern" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cairo.h"
               line="2766">the pattern being rendered from</doc>
          <type name="Pattern" c:type="cairo_pattern_t*"/>
        </parameter>
        <parameter name="callback_data"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1">
          <doc xml:space="preserve"
               filename="cairo.h"
               line="2767">the user data supplied during creation</doc>
          <type name="gpointer" c:type="void*"/>
        </parameter>
        <parameter name="target" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cairo.h"
               line="2768">the rendering target surface</doc>
          <type name="Surface" c:type="cairo_surface_t*"/>
        </parameter>
        <parameter name="extents" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cairo.h"
               line="2769">rectangular region of interest in pixels in sample space</doc>
          <type name="RectangleInt" c:type="const cairo_rectangle_int_t*"/>
        </parameter>
      </parameters>
    </callback>
    <callback name="RasterSourceCopyFunc"
              c:type="cairo_raster_source_copy_func_t"
              version="1.12">
      <doc xml:space="preserve"
           filename="cairo.h"
           line="2832">#cairo_raster_source_copy_func_t is the type of function which is
called when the pattern gets copied as a normal part of rendering.</doc>
      <source-position filename="cairo.h" line="2847"/>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve"
             filename="cairo.h"
             line="2841">CAIRO_STATUS_SUCCESS on success, or one of the
#cairo_status_t error codes for failure.</doc>
        <type name="Status" c:type="cairo_status_t"/>
      </return-value>
      <parameters>
        <parameter name="pattern" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cairo.h"
               line="2834">the #cairo_pattern_t that was copied to</doc>
          <type name="Pattern" c:type="cairo_pattern_t*"/>
        </parameter>
        <parameter name="callback_data"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1">
          <doc xml:space="preserve"
               filename="cairo.h"
               line="2835">the user data supplied during creation</doc>
          <type name="gpointer" c:type="void*"/>
        </parameter>
        <parameter name="other" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cairo.h"
               line="2836">the #cairo_pattern_t being used as the source for the copy</doc>
          <type name="Pattern" c:type="const cairo_pattern_t*"/>
        </parameter>
      </parameters>
    </callback>
    <callback name="RasterSourceFinishFunc"
              c:type="cairo_raster_source_finish_func_t"
              version="1.12">
      <doc xml:space="preserve"
           filename="cairo.h"
           line="2851">#cairo_raster_source_finish_func_t is the type of function which is
called when the pattern (or a copy thereof) is no longer required.</doc>
      <source-position filename="cairo.h" line="2862"/>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="pattern" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cairo.h"
               line="2853">the pattern being rendered from</doc>
          <type name="Pattern" c:type="cairo_pattern_t*"/>
        </parameter>
        <parameter name="callback_data"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1">
          <doc xml:space="preserve"
               filename="cairo.h"
               line="2854">the user data supplied during creation</doc>
          <type name="gpointer" c:type="void*"/>
        </parameter>
      </parameters>
    </callback>
    <callback name="RasterSourceReleaseFunc"
              c:type="cairo_raster_source_release_func_t"
              version="1.12">
      <doc xml:space="preserve"
           filename="cairo.h"
           line="2794">#cairo_raster_source_release_func_t is the type of function which is
called when the pixel data is no longer being access by the pattern
for the rendering operation. Typically this function will simply
destroy the surface created during acquire.</doc>
      <source-position filename="cairo.h" line="2808"/>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="pattern" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cairo.h"
               line="2796">the pattern being rendered from</doc>
          <type name="Pattern" c:type="cairo_pattern_t*"/>
        </parameter>
        <parameter name="callback_data"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1">
          <doc xml:space="preserve"
               filename="cairo.h"
               line="2797">the user data supplied during creation</doc>
          <type name="gpointer" c:type="void*"/>
        </parameter>
        <parameter name="surface" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cairo.h"
               line="2798">the surface created during acquire</doc>
          <type name="Surface" c:type="cairo_surface_t*"/>
        </parameter>
      </parameters>
    </callback>
    <callback name="RasterSourceSnapshotFunc"
              c:type="cairo_raster_source_snapshot_func_t"
              version="1.12">
      <doc xml:space="preserve"
           filename="cairo.h"
           line="2812">#cairo_raster_source_snapshot_func_t is the type of function which is
called when the pixel data needs to be preserved for later use
during printing. This pattern will be accessed again later, and it
is expected to provide the pixel data that was current at the time
of snapshotting.</doc>
      <source-position filename="cairo.h" line="2829"/>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve"
             filename="cairo.h"
             line="2823">CAIRO_STATUS_SUCCESS on success, or one of the
#cairo_status_t error codes for failure.</doc>
        <type name="Status" c:type="cairo_status_t"/>
      </return-value>
      <parameters>
        <parameter name="pattern" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cairo.h"
               line="2814">the pattern being rendered from</doc>
          <type name="Pattern" c:type="cairo_pattern_t*"/>
        </parameter>
        <parameter name="callback_data"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1">
          <doc xml:space="preserve"
               filename="cairo.h"
               line="2815">the user data supplied during creation</doc>
          <type name="gpointer" c:type="void*"/>
        </parameter>
      </parameters>
    </callback>
    <callback name="ReadFunc" c:type="cairo_read_func_t" version="1.0">
      <doc xml:space="preserve"
           filename="cairo.h"
           line="498">#cairo_read_func_t is the type of function which is called when a
backend needs to read data from an input stream.  It is passed the
closure which was specified by the user at the time the read
function was registered, the buffer to read the data into and the
length of the data in bytes.  The read function should return
%CAIRO_STATUS_SUCCESS if all the data was successfully read,
%CAIRO_STATUS_READ_ERROR otherwise.</doc>
      <source-position filename="cairo.h" line="516"/>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve"
             filename="cairo.h"
             line="512">the status code of the read operation</doc>
        <type name="Status" c:type="cairo_status_t"/>
      </return-value>
      <parameters>
        <parameter name="closure"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1">
          <doc xml:space="preserve"
               filename="cairo.h"
               line="500">the input closure</doc>
          <type name="gpointer" c:type="void*"/>
        </parameter>
        <parameter name="data" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cairo.h"
               line="501">the buffer into which to read the data</doc>
          <type name="guint8" c:type="unsigned char*"/>
        </parameter>
        <parameter name="length" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cairo.h"
               line="502">the amount of data to read</doc>
          <type name="guint" c:type="unsigned int"/>
        </parameter>
      </parameters>
    </callback>
    <record name="Rectangle"
            c:type="cairo_rectangle_t"
            version="1.4"
            glib:type-name="cairo_rectangle_t"
            glib:get-type="cairo_gobject_rectangle_get_type"
            c:symbol-prefix="gobject_rectangle">
      <doc xml:space="preserve"
           filename="cairo.h"
           line="1037">A data structure for holding a rectangle.</doc>
      <source-position filename="cairo.h" line="1050"/>
      <field name="x" writable="1">
        <doc xml:space="preserve"
             filename="cairo.h"
             line="1039">X coordinate of the left side of the rectangle</doc>
        <type name="gdouble" c:type="double"/>
      </field>
      <field name="y" writable="1">
        <doc xml:space="preserve"
             filename="cairo.h"
             line="1040">Y coordinate of the top side of the rectangle</doc>
        <type name="gdouble" c:type="double"/>
      </field>
      <field name="width" writable="1">
        <doc xml:space="preserve"
             filename="cairo.h"
             line="1041">width of the rectangle</doc>
        <type name="gdouble" c:type="double"/>
      </field>
      <field name="height" writable="1">
        <doc xml:space="preserve"
             filename="cairo.h"
             line="1042">height of the rectangle</doc>
        <type name="gdouble" c:type="double"/>
      </field>
    </record>
    <record name="RectangleInt"
            c:type="cairo_rectangle_int_t"
            version="1.10"
            glib:type-name="cairo_rectangle_int_t"
            glib:get-type="cairo_gobject_rectangle_int_get_type"
            c:symbol-prefix="gobject_rectangle_int">
      <doc xml:space="preserve"
           filename="cairo.h"
           line="520">A data structure for holding a rectangle with integer coordinates.</doc>
      <source-position filename="cairo.h" line="535"/>
      <field name="x" writable="1">
        <doc xml:space="preserve"
             filename="cairo.h"
             line="522">X coordinate of the left side of the rectangle</doc>
        <type name="gint" c:type="int"/>
      </field>
      <field name="y" writable="1">
        <doc xml:space="preserve"
             filename="cairo.h"
             line="523">Y coordinate of the top side of the rectangle</doc>
        <type name="gint" c:type="int"/>
      </field>
      <field name="width" writable="1">
        <doc xml:space="preserve"
             filename="cairo.h"
             line="524">width of the rectangle</doc>
        <type name="gint" c:type="int"/>
      </field>
      <field name="height" writable="1">
        <doc xml:space="preserve"
             filename="cairo.h"
             line="525">height of the rectangle</doc>
        <type name="gint" c:type="int"/>
      </field>
    </record>
    <record name="RectangleList"
            c:type="cairo_rectangle_list_t"
            version="1.4"
            glib:type-name="cairo_rectangle_list_t"
            glib:get-type="cairo_gobject_rectangle_list_get_type"
            c:symbol-prefix="gobject_rectangle_list">
      <doc xml:space="preserve"
           filename="cairo.h"
           line="1052">A data structure for holding a dynamically allocated
array of rectangles.</doc>
      <source-position filename="cairo.h" line="1067"/>
      <field name="status" writable="1">
        <doc xml:space="preserve"
             filename="cairo.h"
             line="1054">Error status of the rectangle list</doc>
        <type name="Status" c:type="cairo_status_t"/>
      </field>
      <field name="rectangles" writable="1">
        <doc xml:space="preserve"
             filename="cairo.h"
             line="1055">Array containing the rectangles</doc>
        <type name="Rectangle" c:type="cairo_rectangle_t*"/>
      </field>
      <field name="num_rectangles" writable="1">
        <doc xml:space="preserve"
             filename="cairo.h"
             line="1056">Number of rectangles in this list</doc>
        <type name="gint" c:type="int"/>
      </field>
      <method name="destroy"
              c:identifier="cairo_rectangle_list_destroy"
              version="1.4"
              introspectable="0">
        <doc xml:space="preserve"
             filename="cairo-clip.c"
             line="812">Unconditionally frees @rectangle_list and all associated
references. After this call, the @rectangle_list pointer must not
be dereferenced.</doc>
        <source-position filename="cairo.h" line="1073"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="rectangle_list" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo-clip.c"
                 line="814">a rectangle list, as obtained from cairo_copy_clip_rectangle_list()</doc>
            <type name="RectangleList" c:type="cairo_rectangle_list_t*"/>
          </instance-parameter>
        </parameters>
      </method>
    </record>
    <record name="Region"
            c:type="cairo_region_t"
            opaque="1"
            version="1.10"
            glib:type-name="cairo_region_t"
            glib:get-type="cairo_gobject_region_get_type"
            c:symbol-prefix="gobject_region">
      <doc xml:space="preserve"
           filename="cairo.h"
           line="3225">A #cairo_region_t represents a set of integer-aligned rectangles.

It allows set-theoretical operations like cairo_region_union() and
cairo_region_intersect() to be performed on them.

Memory management of #cairo_region_t is done with
cairo_region_reference() and cairo_region_destroy().</doc>
      <source-position filename="cairo.h" line="3238"/>
      <method name="contains_point"
              c:identifier="cairo_region_contains_point"
              version="1.10">
        <doc xml:space="preserve"
             filename="cairo-region.c"
             line="870">Checks whether (@x, @y) is contained in @region.</doc>
        <source-position filename="cairo.h" line="3302"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cairo-region.c"
               line="878">%TRUE if (@x, @y) is contained in @region, %FALSE if it is not.</doc>
          <type name="Bool" c:type="cairo_bool_t"/>
        </return-value>
        <parameters>
          <instance-parameter name="region" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo-region.c"
                 line="872">a #cairo_region_t</doc>
            <type name="Region" c:type="const cairo_region_t*"/>
          </instance-parameter>
          <parameter name="x" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo-region.c"
                 line="873">the x coordinate of a point</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="y" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo-region.c"
                 line="874">the y coordinate of a point</doc>
            <type name="gint" c:type="int"/>
          </parameter>
        </parameters>
      </method>
      <method name="contains_rectangle"
              c:identifier="cairo_region_contains_rectangle"
              version="1.10">
        <doc xml:space="preserve"
             filename="cairo-region.c"
             line="830">Checks whether @rectangle is inside, outside or partially contained
in @region</doc>
        <source-position filename="cairo.h" line="3298"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cairo-region.c"
               line="838">%CAIRO_REGION_OVERLAP_IN if @rectangle is entirely inside @region,
  %CAIRO_REGION_OVERLAP_OUT if @rectangle is entirely outside @region, or
  %CAIRO_REGION_OVERLAP_PART if @rectangle is partially inside and partially outside @region.</doc>
          <type name="RegionOverlap" c:type="cairo_region_overlap_t"/>
        </return-value>
        <parameters>
          <instance-parameter name="region" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo-region.c"
                 line="832">a #cairo_region_t</doc>
            <type name="Region" c:type="const cairo_region_t*"/>
          </instance-parameter>
          <parameter name="rectangle" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo-region.c"
                 line="833">a #cairo_rectangle_int_t</doc>
            <type name="RectangleInt" c:type="const cairo_rectangle_int_t*"/>
          </parameter>
        </parameters>
      </method>
      <method name="copy" c:identifier="cairo_region_copy" version="1.10">
        <doc xml:space="preserve"
             filename="cairo-region.c"
             line="349">Allocates a new region object copying the area from @original.</doc>
        <source-position filename="cairo.h" line="3268"/>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve"
               filename="cairo-region.c"
               line="355">A newly allocated #cairo_region_t. Free with
  cairo_region_destroy(). This function always returns a
  valid pointer; if memory cannot be allocated, then a special
  error object is returned where all operations on the object do nothing.
  You can check for this with cairo_region_status().</doc>
          <type name="Region" c:type="cairo_region_t*"/>
        </return-value>
        <parameters>
          <instance-parameter name="original" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo-region.c"
                 line="351">a #cairo_region_t</doc>
            <type name="Region" c:type="const cairo_region_t*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="destroy"
              c:identifier="cairo_region_destroy"
              version="1.10"
              introspectable="0">
        <doc xml:space="preserve"
             filename="cairo-region.c"
             line="409">Destroys a #cairo_region_t object created with
cairo_region_create(), cairo_region_copy(), or
or cairo_region_create_rectangle().</doc>
        <source-position filename="cairo.h" line="3274"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="region" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo-region.c"
                 line="411">a #cairo_region_t</doc>
            <type name="Region" c:type="cairo_region_t*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="equal" c:identifier="cairo_region_equal" version="1.10">
        <doc xml:space="preserve"
             filename="cairo-region.c"
             line="894">Compares whether region_a is equivalent to region_b. %NULL as an argument
is equal to itself, but not to any non-%NULL region.</doc>
        <source-position filename="cairo.h" line="3277"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cairo-region.c"
               line="902">%TRUE if both regions contained the same coverage,
%FALSE if it is not or any region is in an error status.</doc>
          <type name="Bool" c:type="cairo_bool_t"/>
        </return-value>
        <parameters>
          <instance-parameter name="a" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo-region.c"
                 line="896">a #cairo_region_t or %NULL</doc>
            <type name="Region" c:type="const cairo_region_t*"/>
          </instance-parameter>
          <parameter name="b" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo-region.c"
                 line="897">a #cairo_region_t or %NULL</doc>
            <type name="Region" c:type="const cairo_region_t*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_extents"
              c:identifier="cairo_region_get_extents"
              version="1.10">
        <doc xml:space="preserve"
             filename="cairo-region.c"
             line="484">Gets the bounding rectangle of @region as a #cairo_rectangle_int_t</doc>
        <source-position filename="cairo.h" line="3283"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="region" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo-region.c"
                 line="486">a #cairo_region_t</doc>
            <type name="Region" c:type="const cairo_region_t*"/>
          </instance-parameter>
          <parameter name="extents" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo-region.c"
                 line="487">rectangle into which to store the extents</doc>
            <type name="RectangleInt" c:type="cairo_rectangle_int_t*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_rectangle"
              c:identifier="cairo_region_get_rectangle"
              version="1.10">
        <doc xml:space="preserve"
             filename="cairo-region.c"
             line="453">Stores the @nth rectangle from the region in @rectangle.</doc>
        <source-position filename="cairo.h" line="3290"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="region" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo-region.c"
                 line="455">a #cairo_region_t</doc>
            <type name="Region" c:type="const cairo_region_t*"/>
          </instance-parameter>
          <parameter name="nth" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo-region.c"
                 line="456">a number indicating which rectangle should be returned</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="rectangle" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo-region.c"
                 line="457">return location for a #cairo_rectangle_int_t</doc>
            <type name="RectangleInt" c:type="cairo_rectangle_int_t*"/>
          </parameter>
        </parameters>
      </method>
      <method name="intersect"
              c:identifier="cairo_region_intersect"
              version="1.10">
        <doc xml:space="preserve"
             filename="cairo-region.c"
             line="593">Computes the intersection of @dst with @other and places the result in @dst</doc>
        <source-position filename="cairo.h" line="3315"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cairo-region.c"
               line="600">%CAIRO_STATUS_SUCCESS or %CAIRO_STATUS_NO_MEMORY</doc>
          <type name="Status" c:type="cairo_status_t"/>
        </return-value>
        <parameters>
          <instance-parameter name="dst" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo-region.c"
                 line="595">a #cairo_region_t</doc>
            <type name="Region" c:type="cairo_region_t*"/>
          </instance-parameter>
          <parameter name="other" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo-region.c"
                 line="596">another #cairo_region_t</doc>
            <type name="Region" c:type="const cairo_region_t*"/>
          </parameter>
        </parameters>
      </method>
      <method name="intersect_rectangle"
              c:identifier="cairo_region_intersect_rectangle"
              version="1.10">
        <doc xml:space="preserve"
             filename="cairo-region.c"
             line="619">Computes the intersection of @dst with @rectangle and places the
result in @dst</doc>
        <source-position filename="cairo.h" line="3318"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cairo-region.c"
               line="627">%CAIRO_STATUS_SUCCESS or %CAIRO_STATUS_NO_MEMORY</doc>
          <type name="Status" c:type="cairo_status_t"/>
        </return-value>
        <parameters>
          <instance-parameter name="dst" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo-region.c"
                 line="621">a #cairo_region_t</doc>
            <type name="Region" c:type="cairo_region_t*"/>
          </instance-parameter>
          <parameter name="rectangle" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo-region.c"
                 line="622">a #cairo_rectangle_int_t</doc>
            <type name="RectangleInt" c:type="const cairo_rectangle_int_t*"/>
          </parameter>
        </parameters>
      </method>
      <method name="is_empty"
              c:identifier="cairo_region_is_empty"
              version="1.10">
        <doc xml:space="preserve"
             filename="cairo-region.c"
             line="791">Checks whether @region is empty.</doc>
        <source-position filename="cairo.h" line="3295"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cairo-region.c"
               line="797">%TRUE if @region is empty, %FALSE if it isn't.</doc>
          <type name="Bool" c:type="cairo_bool_t"/>
        </return-value>
        <parameters>
          <instance-parameter name="region" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo-region.c"
                 line="793">a #cairo_region_t</doc>
            <type name="Region" c:type="const cairo_region_t*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="num_rectangles"
              c:identifier="cairo_region_num_rectangles"
              version="1.10">
        <doc xml:space="preserve"
             filename="cairo-region.c"
             line="434">Returns the number of rectangles contained in @region.</doc>
        <source-position filename="cairo.h" line="3287"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cairo-region.c"
               line="440">The number of rectangles contained in @region.</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="region" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo-region.c"
                 line="436">a #cairo_region_t</doc>
            <type name="Region" c:type="const cairo_region_t*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="reference"
              c:identifier="cairo_region_reference"
              version="1.10"
              introspectable="0">
        <doc xml:space="preserve"
             filename="cairo-region.c"
             line="385">Increases the reference count on @region by one. This prevents
@region from being destroyed until a matching call to
cairo_region_destroy() is made.</doc>
        <source-position filename="cairo.h" line="3271"/>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve"
               filename="cairo-region.c"
               line="393">the referenced #cairo_region_t.</doc>
          <type name="Region" c:type="cairo_region_t*"/>
        </return-value>
        <parameters>
          <instance-parameter name="region" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo-region.c"
                 line="387">a #cairo_region_t</doc>
            <type name="Region" c:type="cairo_region_t*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="status" c:identifier="cairo_region_status" version="1.10">
        <doc xml:space="preserve"
             filename="cairo-region.c"
             line="513">Checks whether an error has previous occurred for this
region object.</doc>
        <source-position filename="cairo.h" line="3280"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cairo-region.c"
               line="520">%CAIRO_STATUS_SUCCESS or %CAIRO_STATUS_NO_MEMORY</doc>
          <type name="Status" c:type="cairo_status_t"/>
        </return-value>
        <parameters>
          <instance-parameter name="region" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo-region.c"
                 line="515">a #cairo_region_t</doc>
            <type name="Region" c:type="const cairo_region_t*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="subtract"
              c:identifier="cairo_region_subtract"
              version="1.10">
        <doc xml:space="preserve"
             filename="cairo-region.c"
             line="530">Subtracts @other from @dst and places the result in @dst</doc>
        <source-position filename="cairo.h" line="3308"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cairo-region.c"
               line="537">%CAIRO_STATUS_SUCCESS or %CAIRO_STATUS_NO_MEMORY</doc>
          <type name="Status" c:type="cairo_status_t"/>
        </return-value>
        <parameters>
          <instance-parameter name="dst" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo-region.c"
                 line="532">a #cairo_region_t</doc>
            <type name="Region" c:type="cairo_region_t*"/>
          </instance-parameter>
          <parameter name="other" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo-region.c"
                 line="533">another #cairo_region_t</doc>
            <type name="Region" c:type="const cairo_region_t*"/>
          </parameter>
        </parameters>
      </method>
      <method name="subtract_rectangle"
              c:identifier="cairo_region_subtract_rectangle"
              version="1.10">
        <doc xml:space="preserve"
             filename="cairo-region.c"
             line="560">Subtracts @rectangle from @dst and places the result in @dst</doc>
        <source-position filename="cairo.h" line="3311"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cairo-region.c"
               line="567">%CAIRO_STATUS_SUCCESS or %CAIRO_STATUS_NO_MEMORY</doc>
          <type name="Status" c:type="cairo_status_t"/>
        </return-value>
        <parameters>
          <instance-parameter name="dst" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo-region.c"
                 line="562">a #cairo_region_t</doc>
            <type name="Region" c:type="cairo_region_t*"/>
          </instance-parameter>
          <parameter name="rectangle" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo-region.c"
                 line="563">a #cairo_rectangle_int_t</doc>
            <type name="RectangleInt" c:type="const cairo_rectangle_int_t*"/>
          </parameter>
        </parameters>
      </method>
      <method name="translate"
              c:identifier="cairo_region_translate"
              version="1.10">
        <doc xml:space="preserve"
             filename="cairo-region.c"
             line="810">Translates @region by (@dx, @dy).</doc>
        <source-position filename="cairo.h" line="3305"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="region" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo-region.c"
                 line="812">a #cairo_region_t</doc>
            <type name="Region" c:type="cairo_region_t*"/>
          </instance-parameter>
          <parameter name="dx" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo-region.c"
                 line="813">Amount to translate in the x direction</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="dy" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo-region.c"
                 line="814">Amount to translate in the y direction</doc>
            <type name="gint" c:type="int"/>
          </parameter>
        </parameters>
      </method>
      <method name="union" c:identifier="cairo_region_union" version="1.10">
        <doc xml:space="preserve"
             filename="cairo-region.c"
             line="653">Computes the union of @dst with @other and places the result in @dst</doc>
        <source-position filename="cairo.h" line="3322"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cairo-region.c"
               line="660">%CAIRO_STATUS_SUCCESS or %CAIRO_STATUS_NO_MEMORY</doc>
          <type name="Status" c:type="cairo_status_t"/>
        </return-value>
        <parameters>
          <instance-parameter name="dst" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo-region.c"
                 line="655">a #cairo_region_t</doc>
            <type name="Region" c:type="cairo_region_t*"/>
          </instance-parameter>
          <parameter name="other" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo-region.c"
                 line="656">another #cairo_region_t</doc>
            <type name="Region" c:type="const cairo_region_t*"/>
          </parameter>
        </parameters>
      </method>
      <method name="union_rectangle"
              c:identifier="cairo_region_union_rectangle"
              version="1.10">
        <doc xml:space="preserve"
             filename="cairo-region.c"
             line="680">Computes the union of @dst with @rectangle and places the result in @dst.</doc>
        <source-position filename="cairo.h" line="3325"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cairo-region.c"
               line="687">%CAIRO_STATUS_SUCCESS or %CAIRO_STATUS_NO_MEMORY</doc>
          <type name="Status" c:type="cairo_status_t"/>
        </return-value>
        <parameters>
          <instance-parameter name="dst" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo-region.c"
                 line="682">a #cairo_region_t</doc>
            <type name="Region" c:type="cairo_region_t*"/>
          </instance-parameter>
          <parameter name="rectangle" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo-region.c"
                 line="683">a #cairo_rectangle_int_t</doc>
            <type name="RectangleInt" c:type="const cairo_rectangle_int_t*"/>
          </parameter>
        </parameters>
      </method>
      <method name="xor" c:identifier="cairo_region_xor" version="1.10">
        <doc xml:space="preserve"
             filename="cairo-region.c"
             line="713">Computes the exclusive difference of @dst with @other and places the
result in @dst. That is, @dst will be set to contain all areas that
are either in @dst or in @other, but not in both.</doc>
        <source-position filename="cairo.h" line="3329"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cairo-region.c"
               line="722">%CAIRO_STATUS_SUCCESS or %CAIRO_STATUS_NO_MEMORY</doc>
          <type name="Status" c:type="cairo_status_t"/>
        </return-value>
        <parameters>
          <instance-parameter name="dst" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo-region.c"
                 line="715">a #cairo_region_t</doc>
            <type name="Region" c:type="cairo_region_t*"/>
          </instance-parameter>
          <parameter name="other" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo-region.c"
                 line="716">another #cairo_region_t</doc>
            <type name="Region" c:type="const cairo_region_t*"/>
          </parameter>
        </parameters>
      </method>
      <method name="xor_rectangle"
              c:identifier="cairo_region_xor_rectangle"
              version="1.10">
        <doc xml:space="preserve"
             filename="cairo-region.c"
             line="751">Computes the exclusive difference of @dst with @rectangle and places the
result in @dst. That is, @dst will be set to contain all areas that are
either in @dst or in @rectangle, but not in both.</doc>
        <source-position filename="cairo.h" line="3332"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cairo-region.c"
               line="760">%CAIRO_STATUS_SUCCESS or %CAIRO_STATUS_NO_MEMORY</doc>
          <type name="Status" c:type="cairo_status_t"/>
        </return-value>
        <parameters>
          <instance-parameter name="dst" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo-region.c"
                 line="753">a #cairo_region_t</doc>
            <type name="Region" c:type="cairo_region_t*"/>
          </instance-parameter>
          <parameter name="rectangle" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo-region.c"
                 line="754">a #cairo_rectangle_int_t</doc>
            <type name="RectangleInt" c:type="const cairo_rectangle_int_t*"/>
          </parameter>
        </parameters>
      </method>
    </record>
    <enumeration name="RegionOverlap"
                 version="1.10"
                 glib:type-name="cairo_region_overlap_t"
                 glib:get-type="cairo_gobject_region_overlap_get_type"
                 c:type="cairo_region_overlap_t">
      <doc xml:space="preserve"
           filename="cairo.h"
           line="3240">Used as the return value for cairo_region_contains_rectangle().</doc>
      <member name="in"
              value="0"
              c:identifier="CAIRO_REGION_OVERLAP_IN"
              glib:nick="in"
              glib:name="CAIRO_REGION_OVERLAP_IN">
        <doc xml:space="preserve"
             filename="cairo.h"
             line="3242">The contents are entirely inside the region. (Since 1.10)</doc>
      </member>
      <member name="out"
              value="1"
              c:identifier="CAIRO_REGION_OVERLAP_OUT"
              glib:nick="out"
              glib:name="CAIRO_REGION_OVERLAP_OUT">
        <doc xml:space="preserve"
             filename="cairo.h"
             line="3243">The contents are entirely outside the region. (Since 1.10)</doc>
      </member>
      <member name="part"
              value="2"
              c:identifier="CAIRO_REGION_OVERLAP_PART"
              glib:nick="part"
              glib:name="CAIRO_REGION_OVERLAP_PART">
        <doc xml:space="preserve"
             filename="cairo.h"
             line="3244">The contents are partially inside and
    partially outside the region. (Since 1.10)</doc>
      </member>
    </enumeration>
    <record name="ScaledFont"
            c:type="cairo_scaled_font_t"
            opaque="1"
            version="1.0"
            glib:type-name="cairo_scaled_font_t"
            glib:get-type="cairo_gobject_scaled_font_get_type"
            c:symbol-prefix="gobject_scaled_font">
      <doc xml:space="preserve"
           filename="cairo.h"
           line="1090">A #cairo_scaled_font_t is a font scaled to a particular size and device
resolution. A #cairo_scaled_font_t is most useful for low-level font
usage where a library or application wants to cache a reference
to a scaled font to speed up the computation of metrics.

There are various types of scaled fonts, depending on the
&lt;firstterm&gt;font backend&lt;/firstterm&gt; they use. The type of a
scaled font can be queried using cairo_scaled_font_get_type().

Memory management of #cairo_scaled_font_t is done with
cairo_scaled_font_reference() and cairo_scaled_font_destroy().</doc>
      <source-position filename="cairo.h" line="1107"/>
      <method name="destroy"
              c:identifier="cairo_scaled_font_destroy"
              version="1.0"
              introspectable="0">
        <doc xml:space="preserve"
             filename="cairo-scaled-font.c"
             line="1335">Decreases the reference count on @font by one. If the result
is zero, then @font and all associated resources are freed.
See cairo_scaled_font_reference().</doc>
        <source-position filename="cairo.h" line="1706"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="scaled_font" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo-scaled-font.c"
                 line="1337">a #cairo_scaled_font_t</doc>
            <type name="ScaledFont" c:type="cairo_scaled_font_t*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="extents"
              c:identifier="cairo_scaled_font_extents"
              version="1.0">
        <doc xml:space="preserve"
             filename="cairo-scaled-font.c"
             line="1494">Gets the metrics for a #cairo_scaled_font_t.</doc>
        <source-position filename="cairo.h" line="1728"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="scaled_font" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo-scaled-font.c"
                 line="1496">a #cairo_scaled_font_t</doc>
            <type name="ScaledFont" c:type="cairo_scaled_font_t*"/>
          </instance-parameter>
          <parameter name="extents" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo-scaled-font.c"
                 line="1497">a #cairo_font_extents_t which to store the retrieved extents.</doc>
            <type name="FontExtents" c:type="cairo_font_extents_t*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_ctm"
              c:identifier="cairo_scaled_font_get_ctm"
              version="1.2">
        <doc xml:space="preserve"
             filename="cairo-scaled-font.c"
             line="3041">Stores the CTM with which @scaled_font was created into @ctm.
Note that the translation offsets (x0, y0) of the CTM are ignored
by cairo_scaled_font_create().  So, the matrix this
function returns always has 0,0 as x0,y0.</doc>
        <source-position filename="cairo.h" line="1762"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="scaled_font" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo-scaled-font.c"
                 line="3043">a #cairo_scaled_font_t</doc>
            <type name="ScaledFont" c:type="cairo_scaled_font_t*"/>
          </instance-parameter>
          <parameter name="ctm" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo-scaled-font.c"
                 line="3044">return value for the CTM</doc>
            <type name="Matrix" c:type="cairo_matrix_t*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_font_face"
              c:identifier="cairo_scaled_font_get_font_face"
              version="1.2">
        <doc xml:space="preserve"
             filename="cairo-scaled-font.c"
             line="2993">Gets the font face that this scaled font uses.  This might be the
font face passed to cairo_scaled_font_create(), but this does not
hold true for all possible cases.</doc>
        <source-position filename="cairo.h" line="1755"/>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve"
               filename="cairo-scaled-font.c"
               line="3001">The #cairo_font_face_t with which @scaled_font was
created.  This object is owned by cairo. To keep a reference to it,
you must call cairo_scaled_font_reference().</doc>
          <type name="FontFace" c:type="cairo_font_face_t*"/>
        </return-value>
        <parameters>
          <instance-parameter name="scaled_font" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo-scaled-font.c"
                 line="2995">a #cairo_scaled_font_t</doc>
            <type name="ScaledFont" c:type="cairo_scaled_font_t*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_font_matrix"
              c:identifier="cairo_scaled_font_get_font_matrix"
              version="1.2">
        <doc xml:space="preserve"
             filename="cairo-scaled-font.c"
             line="3019">Stores the font matrix with which @scaled_font was created into
@matrix.</doc>
        <source-position filename="cairo.h" line="1758"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="scaled_font" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo-scaled-font.c"
                 line="3021">a #cairo_scaled_font_t</doc>
            <type name="ScaledFont" c:type="cairo_scaled_font_t*"/>
          </instance-parameter>
          <parameter name="font_matrix" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo-scaled-font.c"
                 line="3022">return value for the matrix</doc>
            <type name="Matrix" c:type="cairo_matrix_t*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_font_options"
              c:identifier="cairo_scaled_font_get_font_options"
              version="1.2">
        <doc xml:space="preserve"
             filename="cairo-scaled-font.c"
             line="3089">Stores the font options with which @scaled_font was created into
@options.</doc>
        <source-position filename="cairo.h" line="1770"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="scaled_font" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo-scaled-font.c"
                 line="3091">a #cairo_scaled_font_t</doc>
            <type name="ScaledFont" c:type="cairo_scaled_font_t*"/>
          </instance-parameter>
          <parameter name="options" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo-scaled-font.c"
                 line="3092">return value for the font options</doc>
            <type name="FontOptions" c:type="cairo_font_options_t*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_reference_count"
              c:identifier="cairo_scaled_font_get_reference_count"
              version="1.4"
              introspectable="0">
        <doc xml:space="preserve"
             filename="cairo-scaled-font.c"
             line="1418">Returns the current reference count of @scaled_font.</doc>
        <source-position filename="cairo.h" line="1709"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cairo-scaled-font.c"
               line="1424">the current reference count of @scaled_font.  If the
object is a nil object, 0 will be returned.</doc>
          <type name="guint" c:type="unsigned int"/>
        </return-value>
        <parameters>
          <instance-parameter name="scaled_font" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo-scaled-font.c"
                 line="1420">a #cairo_scaled_font_t</doc>
            <type name="ScaledFont" c:type="cairo_scaled_font_t*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_scale_matrix"
              c:identifier="cairo_scaled_font_get_scale_matrix"
              version="1.8">
        <doc xml:space="preserve"
             filename="cairo-scaled-font.c"
             line="3065">Stores the scale matrix of @scaled_font into @matrix.
The scale matrix is product of the font matrix and the ctm
associated with the scaled font, and hence is the matrix mapping from
font space to device space.</doc>
        <source-position filename="cairo.h" line="1766"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="scaled_font" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo-scaled-font.c"
                 line="3067">a #cairo_scaled_font_t</doc>
            <type name="ScaledFont" c:type="cairo_scaled_font_t*"/>
          </instance-parameter>
          <parameter name="scale_matrix" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo-scaled-font.c"
                 line="3068">return value for the matrix</doc>
            <type name="Matrix" c:type="cairo_matrix_t*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_type"
              c:identifier="cairo_scaled_font_get_type"
              version="1.2">
        <doc xml:space="preserve"
             filename="cairo-scaled-font.c"
             line="301">This function returns the type of the backend used to create
a scaled font. See #cairo_font_type_t for available types.
However, this function never returns %CAIRO_FONT_TYPE_TOY.</doc>
        <source-position filename="cairo.h" line="1715"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cairo-scaled-font.c"
               line="309">The type of @scaled_font.</doc>
          <type name="FontType" c:type="cairo_font_type_t"/>
        </return-value>
        <parameters>
          <instance-parameter name="scaled_font" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo-scaled-font.c"
                 line="303">a #cairo_scaled_font_t</doc>
            <type name="ScaledFont" c:type="cairo_scaled_font_t*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_user_data"
              c:identifier="cairo_scaled_font_get_user_data"
              version="1.4">
        <doc xml:space="preserve"
             filename="cairo-scaled-font.c"
             line="1439">Return user data previously attached to @scaled_font using the
specified key.  If no user data has been attached with the given
key this function returns %NULL.</doc>
        <source-position filename="cairo.h" line="1718"/>
        <return-value transfer-ownership="none" nullable="1">
          <doc xml:space="preserve"
               filename="cairo-scaled-font.c"
               line="1449">the user data previously attached or %NULL.</doc>
          <type name="gpointer" c:type="void*"/>
        </return-value>
        <parameters>
          <instance-parameter name="scaled_font" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo-scaled-font.c"
                 line="1441">a #cairo_scaled_font_t</doc>
            <type name="ScaledFont" c:type="cairo_scaled_font_t*"/>
          </instance-parameter>
          <parameter name="key" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo-scaled-font.c"
                 line="1442">the address of the #cairo_user_data_key_t the user data was
attached to</doc>
            <type name="UserDataKey" c:type="const cairo_user_data_key_t*"/>
          </parameter>
        </parameters>
      </method>
      <method name="glyph_extents"
              c:identifier="cairo_scaled_font_glyph_extents"
              version="1.0">
        <doc xml:space="preserve"
             filename="cairo-scaled-font.c"
             line="1581">Gets the extents for an array of glyphs. The extents describe a
user-space rectangle that encloses the "inked" portion of the
glyphs, (as they would be drawn by cairo_show_glyphs() if the cairo
graphics state were set to the same font_face, font_matrix, ctm,
and font_options as @scaled_font).  Additionally, the x_advance and
y_advance values indicate the amount by which the current point
would be advanced by cairo_show_glyphs().

Note that whitespace glyphs do not contribute to the size of the
rectangle (extents.width and extents.height).</doc>
        <source-position filename="cairo.h" line="1737"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="scaled_font" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo-scaled-font.c"
                 line="1583">a #cairo_scaled_font_t</doc>
            <type name="ScaledFont" c:type="cairo_scaled_font_t*"/>
          </instance-parameter>
          <parameter name="glyphs" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo-scaled-font.c"
                 line="1584">an array of glyph IDs with X and Y offsets.</doc>
            <type name="Glyph" c:type="const cairo_glyph_t*"/>
          </parameter>
          <parameter name="num_glyphs" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo-scaled-font.c"
                 line="1585">the number of glyphs in the @glyphs array</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="extents" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo-scaled-font.c"
                 line="1586">a #cairo_text_extents_t which to store the retrieved extents.</doc>
            <type name="TextExtents" c:type="cairo_text_extents_t*"/>
          </parameter>
        </parameters>
      </method>
      <method name="reference"
              c:identifier="cairo_scaled_font_reference"
              version="1.0"
              introspectable="0">
        <doc xml:space="preserve"
             filename="cairo-scaled-font.c"
             line="1305">Increases the reference count on @scaled_font by one. This prevents
@scaled_font from being destroyed until a matching call to
cairo_scaled_font_destroy() is made.

Use cairo_scaled_font_get_reference_count() to get the number of
references to a #cairo_scaled_font_t.</doc>
        <source-position filename="cairo.h" line="1703"/>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve"
               filename="cairo-scaled-font.c"
               line="1317">the referenced #cairo_scaled_font_t</doc>
          <type name="ScaledFont" c:type="cairo_scaled_font_t*"/>
        </return-value>
        <parameters>
          <instance-parameter name="scaled_font" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo-scaled-font.c"
                 line="1307">a #cairo_scaled_font_t, (may be %NULL in which case
this function does nothing)</doc>
            <type name="ScaledFont" c:type="cairo_scaled_font_t*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="set_user_data"
              c:identifier="cairo_scaled_font_set_user_data"
              version="1.4"
              introspectable="0">
        <doc xml:space="preserve"
             filename="cairo-scaled-font.c"
             line="1461">Attach user data to @scaled_font.  To remove user data from a surface,
call this function with the key that was used to set it and %NULL
for @data.</doc>
        <source-position filename="cairo.h" line="1722"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cairo-scaled-font.c"
               line="1474">%CAIRO_STATUS_SUCCESS or %CAIRO_STATUS_NO_MEMORY if a
slot could not be allocated for the user data.</doc>
          <type name="Status" c:type="cairo_status_t"/>
        </return-value>
        <parameters>
          <instance-parameter name="scaled_font" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo-scaled-font.c"
                 line="1463">a #cairo_scaled_font_t</doc>
            <type name="ScaledFont" c:type="cairo_scaled_font_t*"/>
          </instance-parameter>
          <parameter name="key" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo-scaled-font.c"
                 line="1464">the address of a #cairo_user_data_key_t to attach the user data to</doc>
            <type name="UserDataKey" c:type="const cairo_user_data_key_t*"/>
          </parameter>
          <parameter name="user_data"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve"
                 filename="cairo-scaled-font.c"
                 line="1465">the user data to attach to the #cairo_scaled_font_t</doc>
            <type name="gpointer" c:type="void*"/>
          </parameter>
          <parameter name="destroy" transfer-ownership="none" scope="async">
            <doc xml:space="preserve"
                 filename="cairo-scaled-font.c"
                 line="1466">a #cairo_destroy_func_t which will be called when the
#cairo_t is destroyed or when new user data is attached using the
same key.</doc>
            <type name="DestroyFunc" c:type="cairo_destroy_func_t"/>
          </parameter>
        </parameters>
      </method>
      <method name="status"
              c:identifier="cairo_scaled_font_status"
              version="1.0">
        <doc xml:space="preserve"
             filename="cairo-scaled-font.c"
             line="322">Checks whether an error has previously occurred for this
scaled_font.</doc>
        <source-position filename="cairo.h" line="1712"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cairo-scaled-font.c"
               line="329">%CAIRO_STATUS_SUCCESS or another error such as
  %CAIRO_STATUS_NO_MEMORY.</doc>
          <type name="Status" c:type="cairo_status_t"/>
        </return-value>
        <parameters>
          <instance-parameter name="scaled_font" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo-scaled-font.c"
                 line="324">a #cairo_scaled_font_t</doc>
            <type name="ScaledFont" c:type="cairo_scaled_font_t*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="text_extents"
              c:identifier="cairo_scaled_font_text_extents"
              version="1.2">
        <doc xml:space="preserve"
             filename="cairo-scaled-font.c"
             line="1519">Gets the extents for a string of text. The extents describe a
user-space rectangle that encloses the "inked" portion of the text
drawn at the origin (0,0) (as it would be drawn by cairo_show_text()
if the cairo graphics state were set to the same font_face,
font_matrix, ctm, and font_options as @scaled_font).  Additionally,
the x_advance and y_advance values indicate the amount by which the
current point would be advanced by cairo_show_text().

Note that whitespace characters do not directly contribute to the
size of the rectangle (extents.width and extents.height). They do
contribute indirectly by changing the position of non-whitespace
characters. In particular, trailing whitespace characters are
likely to not affect the size of the rectangle, though they will
affect the x_advance and y_advance values.</doc>
        <source-position filename="cairo.h" line="1732"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="scaled_font" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo-scaled-font.c"
                 line="1521">a #cairo_scaled_font_t</doc>
            <type name="ScaledFont" c:type="cairo_scaled_font_t*"/>
          </instance-parameter>
          <parameter name="utf8" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo-scaled-font.c"
                 line="1522">a NUL-terminated string of text, encoded in UTF-8</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter name="extents" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo-scaled-font.c"
                 line="1523">a #cairo_text_extents_t which to store the retrieved extents.</doc>
            <type name="TextExtents" c:type="cairo_text_extents_t*"/>
          </parameter>
        </parameters>
      </method>
      <method name="text_to_glyphs"
              c:identifier="cairo_scaled_font_text_to_glyphs"
              version="1.8">
        <doc xml:space="preserve"
             filename="cairo-scaled-font.c"
             line="1848">Converts UTF-8 text to an array of glyphs, optionally with cluster
mapping, that can be used to render later using @scaled_font.

If @glyphs initially points to a non-%NULL value, that array is used
as a glyph buffer, and @num_glyphs should point to the number of glyph
entries available there.  If the provided glyph array is too short for
the conversion, a new glyph array is allocated using cairo_glyph_allocate()
and placed in @glyphs.  Upon return, @num_glyphs always contains the
number of generated glyphs.  If the value @glyphs points to has changed
after the call, the user is responsible for freeing the allocated glyph
array using cairo_glyph_free().  This may happen even if the provided
array was large enough.

If @clusters is not %NULL, @num_clusters and @cluster_flags should not be %NULL,
and cluster mapping will be computed.
The semantics of how cluster array allocation works is similar to the glyph
array.  That is,
if @clusters initially points to a non-%NULL value, that array is used
as a cluster buffer, and @num_clusters should point to the number of cluster
entries available there.  If the provided cluster array is too short for
the conversion, a new cluster array is allocated using cairo_text_cluster_allocate()
and placed in @clusters.  Upon return, @num_clusters always contains the
number of generated clusters.  If the value @clusters points at has changed
after the call, the user is responsible for freeing the allocated cluster
array using cairo_text_cluster_free().  This may happen even if the provided
array was large enough.

In the simplest case, @glyphs and @clusters can point to %NULL initially
and a suitable array will be allocated.  In code:
&lt;informalexample&gt;&lt;programlisting&gt;
cairo_status_t status;

cairo_glyph_t *glyphs = NULL;
int num_glyphs;
cairo_text_cluster_t *clusters = NULL;
int num_clusters;
cairo_text_cluster_flags_t cluster_flags;

status = cairo_scaled_font_text_to_glyphs (scaled_font,
                                           x, y,
                                           utf8, utf8_len,
                                           &amp;amp;glyphs, &amp;amp;num_glyphs,
                                           &amp;amp;clusters, &amp;amp;num_clusters, &amp;amp;cluster_flags);

if (status == CAIRO_STATUS_SUCCESS) {
    cairo_show_text_glyphs (cr,
                            utf8, utf8_len,
                            glyphs, num_glyphs,
                            clusters, num_clusters, cluster_flags);

    cairo_glyph_free (glyphs);
    cairo_text_cluster_free (clusters);
}
&lt;/programlisting&gt;&lt;/informalexample&gt;

If no cluster mapping is needed:
&lt;informalexample&gt;&lt;programlisting&gt;
cairo_status_t status;

cairo_glyph_t *glyphs = NULL;
int num_glyphs;

status = cairo_scaled_font_text_to_glyphs (scaled_font,
                                           x, y,
                                           utf8, utf8_len,
                                           &amp;amp;glyphs, &amp;amp;num_glyphs,
                                           NULL, NULL,
                                           NULL);

if (status == CAIRO_STATUS_SUCCESS) {
    cairo_show_glyphs (cr, glyphs, num_glyphs);
    cairo_glyph_free (glyphs);
}
&lt;/programlisting&gt;&lt;/informalexample&gt;

If stack-based glyph and cluster arrays are to be used for small
arrays:
&lt;informalexample&gt;&lt;programlisting&gt;
cairo_status_t status;

cairo_glyph_t stack_glyphs[40];
cairo_glyph_t *glyphs = stack_glyphs;
int num_glyphs = sizeof (stack_glyphs) / sizeof (stack_glyphs[0]);
cairo_text_cluster_t stack_clusters[40];
cairo_text_cluster_t *clusters = stack_clusters;
int num_clusters = sizeof (stack_clusters) / sizeof (stack_clusters[0]);
cairo_text_cluster_flags_t cluster_flags;

status = cairo_scaled_font_text_to_glyphs (scaled_font,
                                           x, y,
                                           utf8, utf8_len,
                                           &amp;amp;glyphs, &amp;amp;num_glyphs,
                                           &amp;amp;clusters, &amp;amp;num_clusters, &amp;amp;cluster_flags);

if (status == CAIRO_STATUS_SUCCESS) {
    cairo_show_text_glyphs (cr,
                            utf8, utf8_len,
                            glyphs, num_glyphs,
                            clusters, num_clusters, cluster_flags);

    if (glyphs != stack_glyphs)
        cairo_glyph_free (glyphs);
    if (clusters != stack_clusters)
        cairo_text_cluster_free (clusters);
}
&lt;/programlisting&gt;&lt;/informalexample&gt;

For details of how @clusters, @num_clusters, and @cluster_flags map input
UTF-8 text to the output glyphs see cairo_show_text_glyphs().

The output values can be readily passed to cairo_show_text_glyphs()
cairo_show_glyphs(), or related functions, assuming that the exact
same @scaled_font is used for the operation.</doc>
        <source-position filename="cairo.h" line="1743"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cairo-scaled-font.c"
               line="1976">%CAIRO_STATUS_SUCCESS upon success, or an error status
if the input values are wrong or if conversion failed.  If the input
values are correct but the conversion failed, the error status is also
set on @scaled_font.</doc>
          <type name="Status" c:type="cairo_status_t"/>
        </return-value>
        <parameters>
          <instance-parameter name="scaled_font" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo-scaled-font.c"
                 line="1850">a #cairo_scaled_font_t</doc>
            <type name="ScaledFont" c:type="cairo_scaled_font_t*"/>
          </instance-parameter>
          <parameter name="x" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo-scaled-font.c"
                 line="1851">X position to place first glyph</doc>
            <type name="gdouble" c:type="double"/>
          </parameter>
          <parameter name="y" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo-scaled-font.c"
                 line="1852">Y position to place first glyph</doc>
            <type name="gdouble" c:type="double"/>
          </parameter>
          <parameter name="utf8" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo-scaled-font.c"
                 line="1853">a string of text encoded in UTF-8</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter name="utf8_len" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo-scaled-font.c"
                 line="1854">length of @utf8 in bytes, or -1 if it is NUL-terminated</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="glyphs" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo-scaled-font.c"
                 line="1855">pointer to array of glyphs to fill</doc>
            <type name="Glyph" c:type="cairo_glyph_t**"/>
          </parameter>
          <parameter name="num_glyphs" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo-scaled-font.c"
                 line="1856">pointer to number of glyphs</doc>
            <type name="gint" c:type="int*"/>
          </parameter>
          <parameter name="clusters" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo-scaled-font.c"
                 line="1857">pointer to array of cluster mapping information to fill, or %NULL</doc>
            <type name="TextCluster" c:type="cairo_text_cluster_t**"/>
          </parameter>
          <parameter name="num_clusters" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo-scaled-font.c"
                 line="1858">pointer to number of clusters, or %NULL</doc>
            <type name="gint" c:type="int*"/>
          </parameter>
          <parameter name="cluster_flags" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo-scaled-font.c"
                 line="1859">pointer to location to store cluster flags corresponding to the
                output @clusters, or %NULL</doc>
            <type name="TextClusterFlags"
                  c:type="cairo_text_cluster_flags_t*"/>
          </parameter>
        </parameters>
      </method>
    </record>
    <enumeration name="ScriptMode" version="1.12" c:type="cairo_script_mode_t">
      <doc xml:space="preserve"
           filename="cairo-script.h"
           line="45">A set of script output variants.</doc>
      <source-position filename="cairo-script.h" line="57"/>
      <member name="ascii" value="0" c:identifier="CAIRO_SCRIPT_MODE_ASCII">
        <doc xml:space="preserve"
             filename="cairo-script.h"
             line="47">the output will be in readable text (default). (Since 1.12)</doc>
      </member>
      <member name="binary" value="1" c:identifier="CAIRO_SCRIPT_MODE_BINARY">
        <doc xml:space="preserve"
             filename="cairo-script.h"
             line="48">the output will use byte codes. (Since 1.12)</doc>
      </member>
    </enumeration>
    <enumeration name="Status"
                 version="1.0"
                 glib:type-name="cairo_status_t"
                 glib:get-type="cairo_gobject_status_get_type"
                 c:type="cairo_status_t">
      <doc xml:space="preserve"
           filename="cairo.h"
           line="259">#cairo_status_t is used to indicate errors that can occur when
using Cairo. In some cases it is returned directly by functions.
but when using #cairo_t, the last error, if any, is stored in
the context and can be retrieved with cairo_status().

New entries may be added in future versions.  Use cairo_status_to_string()
to get a human-readable representation of an error message.</doc>
      <member name="success"
              value="0"
              c:identifier="CAIRO_STATUS_SUCCESS"
              glib:nick="success"
              glib:name="CAIRO_STATUS_SUCCESS">
        <doc xml:space="preserve"
             filename="cairo.h"
             line="261">no error has occurred (Since 1.0)</doc>
      </member>
      <member name="no_memory"
              value="1"
              c:identifier="CAIRO_STATUS_NO_MEMORY"
              glib:nick="no-memory"
              glib:name="CAIRO_STATUS_NO_MEMORY">
        <doc xml:space="preserve"
             filename="cairo.h"
             line="262">out of memory (Since 1.0)</doc>
      </member>
      <member name="invalid_restore"
              value="2"
              c:identifier="CAIRO_STATUS_INVALID_RESTORE"
              glib:nick="invalid-restore"
              glib:name="CAIRO_STATUS_INVALID_RESTORE">
        <doc xml:space="preserve"
             filename="cairo.h"
             line="263">cairo_restore() called without matching cairo_save() (Since 1.0)</doc>
      </member>
      <member name="invalid_pop_group"
              value="3"
              c:identifier="CAIRO_STATUS_INVALID_POP_GROUP"
              glib:nick="invalid-pop-group"
              glib:name="CAIRO_STATUS_INVALID_POP_GROUP">
        <doc xml:space="preserve"
             filename="cairo.h"
             line="264">no saved group to pop, i.e. cairo_pop_group() without matching cairo_push_group() (Since 1.0)</doc>
      </member>
      <member name="no_current_point"
              value="4"
              c:identifier="CAIRO_STATUS_NO_CURRENT_POINT"
              glib:nick="no-current-point"
              glib:name="CAIRO_STATUS_NO_CURRENT_POINT">
        <doc xml:space="preserve"
             filename="cairo.h"
             line="265">no current point defined (Since 1.0)</doc>
      </member>
      <member name="invalid_matrix"
              value="5"
              c:identifier="CAIRO_STATUS_INVALID_MATRIX"
              glib:nick="invalid-matrix"
              glib:name="CAIRO_STATUS_INVALID_MATRIX">
        <doc xml:space="preserve"
             filename="cairo.h"
             line="266">invalid matrix (not invertible) (Since 1.0)</doc>
      </member>
      <member name="invalid_status"
              value="6"
              c:identifier="CAIRO_STATUS_INVALID_STATUS"
              glib:nick="invalid-status"
              glib:name="CAIRO_STATUS_INVALID_STATUS">
        <doc xml:space="preserve"
             filename="cairo.h"
             line="267">invalid value for an input #cairo_status_t (Since 1.0)</doc>
      </member>
      <member name="null_pointer"
              value="7"
              c:identifier="CAIRO_STATUS_NULL_POINTER"
              glib:nick="null-pointer"
              glib:name="CAIRO_STATUS_NULL_POINTER">
        <doc xml:space="preserve"
             filename="cairo.h"
             line="268">%NULL pointer (Since 1.0)</doc>
      </member>
      <member name="invalid_string"
              value="8"
              c:identifier="CAIRO_STATUS_INVALID_STRING"
              glib:nick="invalid-string"
              glib:name="CAIRO_STATUS_INVALID_STRING">
        <doc xml:space="preserve"
             filename="cairo.h"
             line="269">input string not valid UTF-8 (Since 1.0)</doc>
      </member>
      <member name="invalid_path_data"
              value="9"
              c:identifier="CAIRO_STATUS_INVALID_PATH_DATA"
              glib:nick="invalid-path-data"
              glib:name="CAIRO_STATUS_INVALID_PATH_DATA">
        <doc xml:space="preserve"
             filename="cairo.h"
             line="270">input path data not valid (Since 1.0)</doc>
      </member>
      <member name="read_error"
              value="10"
              c:identifier="CAIRO_STATUS_READ_ERROR"
              glib:nick="read-error"
              glib:name="CAIRO_STATUS_READ_ERROR">
        <doc xml:space="preserve"
             filename="cairo.h"
             line="271">error while reading from input stream (Since 1.0)</doc>
      </member>
      <member name="write_error"
              value="11"
              c:identifier="CAIRO_STATUS_WRITE_ERROR"
              glib:nick="write-error"
              glib:name="CAIRO_STATUS_WRITE_ERROR">
        <doc xml:space="preserve"
             filename="cairo.h"
             line="272">error while writing to output stream (Since 1.0)</doc>
      </member>
      <member name="surface_finished"
              value="12"
              c:identifier="CAIRO_STATUS_SURFACE_FINISHED"
              glib:nick="surface-finished"
              glib:name="CAIRO_STATUS_SURFACE_FINISHED">
        <doc xml:space="preserve"
             filename="cairo.h"
             line="273">target surface has been finished (Since 1.0)</doc>
      </member>
      <member name="surface_type_mismatch"
              value="13"
              c:identifier="CAIRO_STATUS_SURFACE_TYPE_MISMATCH"
              glib:nick="surface-type-mismatch"
              glib:name="CAIRO_STATUS_SURFACE_TYPE_MISMATCH">
        <doc xml:space="preserve"
             filename="cairo.h"
             line="274">the surface type is not appropriate for the operation (Since 1.0)</doc>
      </member>
      <member name="pattern_type_mismatch"
              value="14"
              c:identifier="CAIRO_STATUS_PATTERN_TYPE_MISMATCH"
              glib:nick="pattern-type-mismatch"
              glib:name="CAIRO_STATUS_PATTERN_TYPE_MISMATCH">
        <doc xml:space="preserve"
             filename="cairo.h"
             line="275">the pattern type is not appropriate for the operation (Since 1.0)</doc>
      </member>
      <member name="invalid_content"
              value="15"
              c:identifier="CAIRO_STATUS_INVALID_CONTENT"
              glib:nick="invalid-content"
              glib:name="CAIRO_STATUS_INVALID_CONTENT">
        <doc xml:space="preserve"
             filename="cairo.h"
             line="276">invalid value for an input #cairo_content_t (Since 1.0)</doc>
      </member>
      <member name="invalid_format"
              value="16"
              c:identifier="CAIRO_STATUS_INVALID_FORMAT"
              glib:nick="invalid-format"
              glib:name="CAIRO_STATUS_INVALID_FORMAT">
        <doc xml:space="preserve"
             filename="cairo.h"
             line="277">invalid value for an input #cairo_format_t (Since 1.0)</doc>
      </member>
      <member name="invalid_visual"
              value="17"
              c:identifier="CAIRO_STATUS_INVALID_VISUAL"
              glib:nick="invalid-visual"
              glib:name="CAIRO_STATUS_INVALID_VISUAL">
        <doc xml:space="preserve"
             filename="cairo.h"
             line="278">invalid value for an input Visual* (Since 1.0)</doc>
      </member>
      <member name="file_not_found"
              value="18"
              c:identifier="CAIRO_STATUS_FILE_NOT_FOUND"
              glib:nick="file-not-found"
              glib:name="CAIRO_STATUS_FILE_NOT_FOUND">
        <doc xml:space="preserve"
             filename="cairo.h"
             line="279">file not found (Since 1.0)</doc>
      </member>
      <member name="invalid_dash"
              value="19"
              c:identifier="CAIRO_STATUS_INVALID_DASH"
              glib:nick="invalid-dash"
              glib:name="CAIRO_STATUS_INVALID_DASH">
        <doc xml:space="preserve"
             filename="cairo.h"
             line="280">invalid value for a dash setting (Since 1.0)</doc>
      </member>
      <member name="invalid_dsc_comment"
              value="20"
              c:identifier="CAIRO_STATUS_INVALID_DSC_COMMENT"
              glib:nick="invalid-dsc-comment"
              glib:name="CAIRO_STATUS_INVALID_DSC_COMMENT">
        <doc xml:space="preserve"
             filename="cairo.h"
             line="281">invalid value for a DSC comment (Since 1.2)</doc>
      </member>
      <member name="invalid_index"
              value="21"
              c:identifier="CAIRO_STATUS_INVALID_INDEX"
              glib:nick="invalid-index"
              glib:name="CAIRO_STATUS_INVALID_INDEX">
        <doc xml:space="preserve"
             filename="cairo.h"
             line="282">invalid index passed to getter (Since 1.4)</doc>
      </member>
      <member name="clip_not_representable"
              value="22"
              c:identifier="CAIRO_STATUS_CLIP_NOT_REPRESENTABLE"
              glib:nick="clip-not-representable"
              glib:name="CAIRO_STATUS_CLIP_NOT_REPRESENTABLE">
        <doc xml:space="preserve"
             filename="cairo.h"
             line="283">clip region not representable in desired format (Since 1.4)</doc>
      </member>
      <member name="temp_file_error"
              value="23"
              c:identifier="CAIRO_STATUS_TEMP_FILE_ERROR"
              glib:nick="temp-file-error"
              glib:name="CAIRO_STATUS_TEMP_FILE_ERROR">
        <doc xml:space="preserve"
             filename="cairo.h"
             line="284">error creating or writing to a temporary file (Since 1.6)</doc>
      </member>
      <member name="invalid_stride"
              value="24"
              c:identifier="CAIRO_STATUS_INVALID_STRIDE"
              glib:nick="invalid-stride"
              glib:name="CAIRO_STATUS_INVALID_STRIDE">
        <doc xml:space="preserve"
             filename="cairo.h"
             line="285">invalid value for stride (Since 1.6)</doc>
      </member>
      <member name="font_type_mismatch"
              value="25"
              c:identifier="CAIRO_STATUS_FONT_TYPE_MISMATCH"
              glib:nick="font-type-mismatch"
              glib:name="CAIRO_STATUS_FONT_TYPE_MISMATCH">
        <doc xml:space="preserve"
             filename="cairo.h"
             line="286">the font type is not appropriate for the operation (Since 1.8)</doc>
      </member>
      <member name="user_font_immutable"
              value="26"
              c:identifier="CAIRO_STATUS_USER_FONT_IMMUTABLE"
              glib:nick="user-font-immutable"
              glib:name="CAIRO_STATUS_USER_FONT_IMMUTABLE">
        <doc xml:space="preserve"
             filename="cairo.h"
             line="287">the user-font is immutable (Since 1.8)</doc>
      </member>
      <member name="user_font_error"
              value="27"
              c:identifier="CAIRO_STATUS_USER_FONT_ERROR"
              glib:nick="user-font-error"
              glib:name="CAIRO_STATUS_USER_FONT_ERROR">
        <doc xml:space="preserve"
             filename="cairo.h"
             line="288">error occurred in a user-font callback function (Since 1.8)</doc>
      </member>
      <member name="negative_count"
              value="28"
              c:identifier="CAIRO_STATUS_NEGATIVE_COUNT"
              glib:nick="negative-count"
              glib:name="CAIRO_STATUS_NEGATIVE_COUNT">
        <doc xml:space="preserve"
             filename="cairo.h"
             line="289">negative number used where it is not allowed (Since 1.8)</doc>
      </member>
      <member name="invalid_clusters"
              value="29"
              c:identifier="CAIRO_STATUS_INVALID_CLUSTERS"
              glib:nick="invalid-clusters"
              glib:name="CAIRO_STATUS_INVALID_CLUSTERS">
        <doc xml:space="preserve"
             filename="cairo.h"
             line="290">input clusters do not represent the accompanying text and glyph array (Since 1.8)</doc>
      </member>
      <member name="invalid_slant"
              value="30"
              c:identifier="CAIRO_STATUS_INVALID_SLANT"
              glib:nick="invalid-slant"
              glib:name="CAIRO_STATUS_INVALID_SLANT">
        <doc xml:space="preserve"
             filename="cairo.h"
             line="291">invalid value for an input #cairo_font_slant_t (Since 1.8)</doc>
      </member>
      <member name="invalid_weight"
              value="31"
              c:identifier="CAIRO_STATUS_INVALID_WEIGHT"
              glib:nick="invalid-weight"
              glib:name="CAIRO_STATUS_INVALID_WEIGHT">
        <doc xml:space="preserve"
             filename="cairo.h"
             line="292">invalid value for an input #cairo_font_weight_t (Since 1.8)</doc>
      </member>
      <member name="invalid_size"
              value="32"
              c:identifier="CAIRO_STATUS_INVALID_SIZE"
              glib:nick="invalid-size"
              glib:name="CAIRO_STATUS_INVALID_SIZE">
        <doc xml:space="preserve"
             filename="cairo.h"
             line="293">invalid value (typically too big) for the size of the input (surface, pattern, etc.) (Since 1.10)</doc>
      </member>
      <member name="user_font_not_implemented"
              value="33"
              c:identifier="CAIRO_STATUS_USER_FONT_NOT_IMPLEMENTED"
              glib:nick="user-font-not-implemented"
              glib:name="CAIRO_STATUS_USER_FONT_NOT_IMPLEMENTED">
        <doc xml:space="preserve"
             filename="cairo.h"
             line="294">user-font method not implemented (Since 1.10)</doc>
      </member>
      <member name="device_type_mismatch"
              value="34"
              c:identifier="CAIRO_STATUS_DEVICE_TYPE_MISMATCH"
              glib:nick="device-type-mismatch"
              glib:name="CAIRO_STATUS_DEVICE_TYPE_MISMATCH">
        <doc xml:space="preserve"
             filename="cairo.h"
             line="295">the device type is not appropriate for the operation (Since 1.10)</doc>
      </member>
      <member name="device_error"
              value="35"
              c:identifier="CAIRO_STATUS_DEVICE_ERROR"
              glib:nick="device-error"
              glib:name="CAIRO_STATUS_DEVICE_ERROR">
        <doc xml:space="preserve"
             filename="cairo.h"
             line="296">an operation to the device caused an unspecified error (Since 1.10)</doc>
      </member>
      <member name="invalid_mesh_construction"
              value="36"
              c:identifier="CAIRO_STATUS_INVALID_MESH_CONSTRUCTION"
              glib:nick="invalid-mesh-construction"
              glib:name="CAIRO_STATUS_INVALID_MESH_CONSTRUCTION">
        <doc xml:space="preserve"
             filename="cairo.h"
             line="297">a mesh pattern
  construction operation was used outside of a
  cairo_mesh_pattern_begin_patch()/cairo_mesh_pattern_end_patch()
  pair (Since 1.12)</doc>
      </member>
      <member name="device_finished"
              value="37"
              c:identifier="CAIRO_STATUS_DEVICE_FINISHED"
              glib:nick="device-finished"
              glib:name="CAIRO_STATUS_DEVICE_FINISHED">
        <doc xml:space="preserve"
             filename="cairo.h"
             line="301">target device has been finished (Since 1.12)</doc>
      </member>
      <member name="jbig2_global_missing"
              value="38"
              c:identifier="CAIRO_STATUS_JBIG2_GLOBAL_MISSING"
              glib:nick="jbig2-global_missing"
              glib:name="CAIRO_STATUS_JBIG2_GLOBAL_MISSING">
        <doc xml:space="preserve"
             filename="cairo.h"
             line="302">%CAIRO_MIME_TYPE_JBIG2_GLOBAL_ID has been used on at least one image
  but no image provided %CAIRO_MIME_TYPE_JBIG2_GLOBAL (Since 1.14)</doc>
      </member>
      <member name="png_error"
              value="39"
              c:identifier="CAIRO_STATUS_PNG_ERROR"
              glib:nick="png-error"
              glib:name="CAIRO_STATUS_PNG_ERROR">
        <doc xml:space="preserve"
             filename="cairo.h"
             line="304">error occurred in libpng while reading from or writing to a PNG file (Since 1.16)</doc>
      </member>
      <member name="freetype_error"
              value="40"
              c:identifier="CAIRO_STATUS_FREETYPE_ERROR"
              glib:nick="freetype-error"
              glib:name="CAIRO_STATUS_FREETYPE_ERROR">
        <doc xml:space="preserve"
             filename="cairo.h"
             line="305">error occurred in libfreetype (Since 1.16)</doc>
      </member>
      <member name="last_status"
              value="45"
              c:identifier="CAIRO_STATUS_LAST_STATUS"
              glib:nick="last-status"
              glib:name="CAIRO_STATUS_LAST_STATUS">
        <doc xml:space="preserve"
             filename="cairo.h"
             line="310">this is a special value indicating the number of
  status values defined in this enumeration.  When using this value, note
  that the version of cairo at run-time may have additional status values
  defined than the value of this symbol at compile-time. (Since 1.10)</doc>
      </member>
      <member name="win32_gdi_error"
              value="41"
              c:identifier="CAIRO_STATUS_WIN32_GDI_ERROR"
              glib:nick="win32-gdi-error"
              glib:name="CAIRO_STATUS_WIN32_GDI_ERROR">
        <doc xml:space="preserve"
             filename="cairo.h"
             line="306">error occurred in the Windows Graphics Device Interface (Since 1.16)</doc>
      </member>
    </enumeration>
    <enumeration name="SubpixelOrder"
                 version="1.0"
                 glib:type-name="cairo_subpixel_order_t"
                 glib:get-type="cairo_gobject_subpixel_order_get_type"
                 c:type="cairo_subpixel_order_t">
      <doc xml:space="preserve"
           filename="cairo.h"
           line="1331">The subpixel order specifies the order of color elements within
each pixel on the display device when rendering with an
antialiasing mode of %CAIRO_ANTIALIAS_SUBPIXEL.</doc>
      <member name="default"
              value="0"
              c:identifier="CAIRO_SUBPIXEL_ORDER_DEFAULT"
              glib:nick="default"
              glib:name="CAIRO_SUBPIXEL_ORDER_DEFAULT">
        <doc xml:space="preserve"
             filename="cairo.h"
             line="1333">Use the default subpixel order for
  for the target device, since 1.0</doc>
      </member>
      <member name="rgb"
              value="1"
              c:identifier="CAIRO_SUBPIXEL_ORDER_RGB"
              glib:nick="rgb"
              glib:name="CAIRO_SUBPIXEL_ORDER_RGB">
        <doc xml:space="preserve"
             filename="cairo.h"
             line="1335">Subpixel elements are arranged horizontally
  with red at the left, since 1.0</doc>
      </member>
      <member name="bgr"
              value="2"
              c:identifier="CAIRO_SUBPIXEL_ORDER_BGR"
              glib:nick="bgr"
              glib:name="CAIRO_SUBPIXEL_ORDER_BGR">
        <doc xml:space="preserve"
             filename="cairo.h"
             line="1337">Subpixel elements are arranged horizontally
  with blue at the left, since 1.0</doc>
      </member>
      <member name="vrgb"
              value="3"
              c:identifier="CAIRO_SUBPIXEL_ORDER_VRGB"
              glib:nick="vrgb"
              glib:name="CAIRO_SUBPIXEL_ORDER_VRGB">
        <doc xml:space="preserve"
             filename="cairo.h"
             line="1339">Subpixel elements are arranged vertically
  with red at the top, since 1.0</doc>
      </member>
      <member name="vbgr"
              value="4"
              c:identifier="CAIRO_SUBPIXEL_ORDER_VBGR"
              glib:nick="vbgr"
              glib:name="CAIRO_SUBPIXEL_ORDER_VBGR">
        <doc xml:space="preserve"
             filename="cairo.h"
             line="1341">Subpixel elements are arranged vertically
  with blue at the top, since 1.0</doc>
      </member>
    </enumeration>
    <record name="Surface"
            c:type="cairo_surface_t"
            opaque="1"
            version="1.0"
            glib:type-name="cairo_surface_t"
            glib:get-type="cairo_gobject_surface_get_type"
            c:symbol-prefix="gobject_surface">
      <doc xml:space="preserve"
           filename="cairo.h"
           line="137">A #cairo_surface_t represents an image, either as the destination
of a drawing operation or as source when drawing onto another
surface.  To draw to a #cairo_surface_t, create a cairo context
with the surface as the target, using cairo_create().

There are different subtypes of #cairo_surface_t for
different drawing backends; for example, cairo_image_surface_create()
creates a bitmap image in memory.
The type of a surface can be queried with cairo_surface_get_type().

The initial contents of a surface after creation depend upon the manner
of its creation. If cairo creates the surface and backing storage for
the user, it will be initially cleared; for example,
cairo_image_surface_create() and cairo_surface_create_similar().
Alternatively, if the user passes in a reference to some backing storage
and asks cairo to wrap that in a #cairo_surface_t, then the contents are
not modified; for example, cairo_image_surface_create_for_data() and
cairo_xlib_surface_create().

Memory management of #cairo_surface_t is done with
cairo_surface_reference() and cairo_surface_destroy().</doc>
      <source-position filename="cairo.h" line="164"/>
      <method name="copy_page"
              c:identifier="cairo_surface_copy_page"
              version="1.6">
        <doc xml:space="preserve"
             filename="cairo-surface.c"
             line="2466">Emits the current page for backends that support multiple pages,
but doesn't clear it, so that the contents of the current page will
be retained for the next page.  Use cairo_surface_show_page() if you
want to get an empty page after the emission.

There is a convenience function for this that takes a #cairo_t,
namely cairo_copy_page().</doc>
        <source-position filename="cairo.h" line="2693"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="surface" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo-surface.c"
                 line="2468">a #cairo_surface_t</doc>
            <type name="Surface" c:type="cairo_surface_t*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="create_for_rectangle"
              c:identifier="cairo_surface_create_for_rectangle"
              version="1.10">
        <doc xml:space="preserve"
             filename="cairo-surface-subsurface.c"
             line="419">Create a new surface that is a rectangle within the target surface.
All operations drawn to this surface are then clipped and translated
onto the target surface. Nothing drawn via this sub-surface outside of
its bounds is drawn onto the target surface, making this a useful method
for passing constrained child surfaces to library routines that draw
directly onto the parent surface, i.e. with no further backend allocations,
double buffering or copies.

&lt;note&gt;&lt;para&gt;The semantics of subsurfaces have not been finalized yet
unless the rectangle is in full device units, is contained within
the extents of the target surface, and the target or subsurface's
device transforms are not changed.&lt;/para&gt;&lt;/note&gt;</doc>
        <source-position filename="cairo.h" line="2373"/>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve"
               filename="cairo-surface-subsurface.c"
               line="440">a pointer to the newly allocated surface. The caller
owns the surface and should call cairo_surface_destroy() when done
with it.

This function always returns a valid pointer, but it will return a
pointer to a "nil" surface if @other is already in an error state
or any other error occurs.</doc>
          <type name="Surface" c:type="cairo_surface_t*"/>
        </return-value>
        <parameters>
          <instance-parameter name="target" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo-surface-subsurface.c"
                 line="421">an existing surface for which the sub-surface will point to</doc>
            <type name="Surface" c:type="cairo_surface_t*"/>
          </instance-parameter>
          <parameter name="x" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo-surface-subsurface.c"
                 line="422">the x-origin of the sub-surface from the top-left of the target surface (in device-space units)</doc>
            <type name="gdouble" c:type="double"/>
          </parameter>
          <parameter name="y" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo-surface-subsurface.c"
                 line="423">the y-origin of the sub-surface from the top-left of the target surface (in device-space units)</doc>
            <type name="gdouble" c:type="double"/>
          </parameter>
          <parameter name="width" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo-surface-subsurface.c"
                 line="424">width of the sub-surface (in device-space units)</doc>
            <type name="gdouble" c:type="double"/>
          </parameter>
          <parameter name="height" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo-surface-subsurface.c"
                 line="425">height of the sub-surface (in device-space units)</doc>
            <type name="gdouble" c:type="double"/>
          </parameter>
        </parameters>
      </method>
      <method name="create_observer"
              c:identifier="cairo_surface_create_observer"
              version="1.12">
        <doc xml:space="preserve"
             filename="cairo-surface-observer.c"
             line="1385">Create a new surface that exists solely to watch another is doing. In
the process it will log operations and times, which are fast, which are
slow, which are frequent, etc.

The @mode parameter can be set to either %CAIRO_SURFACE_OBSERVER_NORMAL
or %CAIRO_SURFACE_OBSERVER_RECORD_OPERATIONS, to control whether or not
the internal observer should record operations.</doc>
        <source-position filename="cairo.h" line="2394"/>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve"
               filename="cairo-surface-observer.c"
               line="1398">a pointer to the newly allocated surface. The caller
owns the surface and should call cairo_surface_destroy() when done
with it.

This function always returns a valid pointer, but it will return a
pointer to a "nil" surface if @other is already in an error state
or any other error occurs.</doc>
          <type name="Surface" c:type="cairo_surface_t*"/>
        </return-value>
        <parameters>
          <instance-parameter name="target" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo-surface-observer.c"
                 line="1387">an existing surface for which the observer will watch</doc>
            <type name="Surface" c:type="cairo_surface_t*"/>
          </instance-parameter>
          <parameter name="mode" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo-surface-observer.c"
                 line="1388">sets the mode of operation (normal vs. record)</doc>
            <type name="SurfaceObserverMode"
                  c:type="cairo_surface_observer_mode_t"/>
          </parameter>
        </parameters>
      </method>
      <method name="create_similar"
              c:identifier="cairo_surface_create_similar"
              version="1.0">
        <doc xml:space="preserve"
             filename="cairo-surface.c"
             line="470">Create a new surface that is as compatible as possible with an
existing surface. For example the new surface will have the same
device scale, fallback resolution and font options as
@other. Generally, the new surface will also use the same backend
as @other, unless that is not possible for some reason. The type of
the returned surface may be examined with
cairo_surface_get_type().

Initially the surface contents are all 0 (transparent if contents
have transparency, black otherwise.)

Use cairo_surface_create_similar_image() if you need an image surface
which can be painted quickly to the target surface.</doc>
        <source-position filename="cairo.h" line="2353"/>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve"
               filename="cairo-surface.c"
               line="491">a pointer to the newly allocated surface. The caller
owns the surface and should call cairo_surface_destroy() when done
with it.

This function always returns a valid pointer, but it will return a
pointer to a "nil" surface if @other is already in an error state
or any other error occurs.</doc>
          <type name="Surface" c:type="cairo_surface_t*"/>
        </return-value>
        <parameters>
          <instance-parameter name="other" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo-surface.c"
                 line="472">an existing surface used to select the backend of the new surface</doc>
            <type name="Surface" c:type="cairo_surface_t*"/>
          </instance-parameter>
          <parameter name="content" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo-surface.c"
                 line="473">the content for the new surface</doc>
            <type name="Content" c:type="cairo_content_t"/>
          </parameter>
          <parameter name="width" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo-surface.c"
                 line="474">width of the new surface, (in device-space units)</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="height" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo-surface.c"
                 line="475">height of the new surface (in device-space units)</doc>
            <type name="gint" c:type="int"/>
          </parameter>
        </parameters>
      </method>
      <method name="create_similar_image"
              c:identifier="cairo_surface_create_similar_image"
              version="1.12">
        <doc xml:space="preserve"
             filename="cairo-surface.c"
             line="557">Create a new image surface that is as compatible as possible for uploading
to and the use in conjunction with an existing surface. However, this surface
can still be used like any normal image surface. Unlike
cairo_surface_create_similar() the new image surface won't inherit
the device scale from @other.

Initially the surface contents are all 0 (transparent if contents
have transparency, black otherwise.)

Use cairo_surface_create_similar() if you don't need an image surface.</doc>
        <source-position filename="cairo.h" line="2359"/>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve"
               filename="cairo-surface.c"
               line="575">a pointer to the newly allocated image surface. The caller
owns the surface and should call cairo_surface_destroy() when done
with it.

This function always returns a valid pointer, but it will return a
pointer to a "nil" surface if @other is already in an error state
or any other error occurs.</doc>
          <type name="Surface" c:type="cairo_surface_t*"/>
        </return-value>
        <parameters>
          <instance-parameter name="other" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo-surface.c"
                 line="559">an existing surface used to select the preference of the new surface</doc>
            <type name="Surface" c:type="cairo_surface_t*"/>
          </instance-parameter>
          <parameter name="format" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo-surface.c"
                 line="560">the format for the new surface</doc>
            <type name="Format" c:type="cairo_format_t"/>
          </parameter>
          <parameter name="width" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo-surface.c"
                 line="561">width of the new surface, (in pixels)</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="height" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo-surface.c"
                 line="562">height of the new surface (in pixels)</doc>
            <type name="gint" c:type="int"/>
          </parameter>
        </parameters>
      </method>
      <method name="destroy"
              c:identifier="cairo_surface_destroy"
              version="1.0"
              introspectable="0">
        <doc xml:space="preserve"
             filename="cairo-surface.c"
             line="946">Decreases the reference count on @surface by one. If the result is
zero, then @surface and all associated resources are freed.  See
cairo_surface_reference().</doc>
        <source-position filename="cairo.h" line="2483"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="surface" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo-surface.c"
                 line="948">a #cairo_surface_t</doc>
            <type name="Surface" c:type="cairo_surface_t*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="finish" c:identifier="cairo_surface_finish" version="1.0">
        <doc xml:space="preserve"
             filename="cairo-surface.c"
             line="1054">This function finishes the surface and drops all references to
external resources.  For example, for the Xlib backend it means
that cairo will no longer access the drawable, which can be freed.
After calling cairo_surface_finish() the only valid operations on a
surface are checking status, getting and setting user, referencing
and destroying, and flushing and finishing it.
Further drawing to the surface will not affect the
surface but will instead trigger a %CAIRO_STATUS_SURFACE_FINISHED
error.

When the last call to cairo_surface_destroy() decreases the
reference count to zero, cairo will call cairo_surface_finish() if
it hasn't been called already, before freeing the resources
associated with the surface.</doc>
        <source-position filename="cairo.h" line="2480"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="surface" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo-surface.c"
                 line="1056">the #cairo_surface_t to finish</doc>
            <type name="Surface" c:type="cairo_surface_t*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="flush" c:identifier="cairo_surface_flush" version="1.0">
        <doc xml:space="preserve"
             filename="cairo-surface.c"
             line="1642">Do any pending drawing for the surface and also restore any temporary
modifications cairo has made to the surface's state. This function
must be called before switching from drawing on the surface with
cairo to drawing on it directly with native APIs, or accessing its
memory outside of Cairo. If the surface doesn't support direct
access, then this function does nothing.</doc>
        <source-position filename="cairo.h" line="2650"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="surface" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo-surface.c"
                 line="1644">a #cairo_surface_t</doc>
            <type name="Surface" c:type="cairo_surface_t*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_content"
              c:identifier="cairo_surface_get_content"
              version="1.2">
        <doc xml:space="preserve"
             filename="cairo-surface.c"
             line="232">This function returns the content type of @surface which indicates
whether the surface contains color and/or alpha information. See
#cairo_content_t.</doc>
        <source-position filename="cairo.h" line="2589"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cairo-surface.c"
               line="240">The content type of @surface.</doc>
          <type name="Content" c:type="cairo_content_t"/>
        </return-value>
        <parameters>
          <instance-parameter name="surface" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo-surface.c"
                 line="234">a #cairo_surface_t</doc>
            <type name="Surface" c:type="cairo_surface_t*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_device"
              c:identifier="cairo_surface_get_device"
              version="1.10">
        <doc xml:space="preserve"
             filename="cairo-surface.c"
             line="293">This function returns the device for a @surface.
See #cairo_device_t.</doc>
        <source-position filename="cairo.h" line="2486"/>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve"
               filename="cairo-surface.c"
               line="300">The device for @surface or %NULL if the surface does
              not have an associated device.</doc>
          <type name="Device" c:type="cairo_device_t*"/>
        </return-value>
        <parameters>
          <instance-parameter name="surface" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo-surface.c"
                 line="295">a #cairo_surface_t</doc>
            <type name="Surface" c:type="cairo_surface_t*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_device_offset"
              c:identifier="cairo_surface_get_device_offset"
              version="1.2">
        <doc xml:space="preserve"
             filename="cairo-surface.c"
             line="1903">This function returns the previous device offset set by
cairo_surface_set_device_offset().</doc>
        <source-position filename="cairo.h" line="2678"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="surface" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo-surface.c"
                 line="1905">a #cairo_surface_t</doc>
            <type name="Surface" c:type="cairo_surface_t*"/>
          </instance-parameter>
          <parameter name="x_offset" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo-surface.c"
                 line="1906">the offset in the X direction, in device units</doc>
            <type name="gdouble" c:type="double*"/>
          </parameter>
          <parameter name="y_offset" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo-surface.c"
                 line="1907">the offset in the Y direction, in device units</doc>
            <type name="gdouble" c:type="double*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_device_scale"
              c:identifier="cairo_surface_get_device_scale"
              version="1.14">
        <doc xml:space="preserve"
             filename="cairo-surface.c"
             line="1827">This function returns the previous device scale set by
cairo_surface_set_device_scale().</doc>
        <source-position filename="cairo.h" line="2668"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="surface" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo-surface.c"
                 line="1829">a #cairo_surface_t</doc>
            <type name="Surface" c:type="cairo_surface_t*"/>
          </instance-parameter>
          <parameter name="x_scale" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo-surface.c"
                 line="1830">the scale in the X direction, in device units</doc>
            <type name="gdouble" c:type="double*"/>
          </parameter>
          <parameter name="y_scale" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo-surface.c"
                 line="1831">the scale in the Y direction, in device units</doc>
            <type name="gdouble" c:type="double*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_fallback_resolution"
              c:identifier="cairo_surface_get_fallback_resolution"
              version="1.8">
        <doc xml:space="preserve"
             filename="cairo-surface.c"
             line="1993">This function returns the previous fallback resolution set by
cairo_surface_set_fallback_resolution(), or default fallback
resolution if never set.</doc>
        <source-position filename="cairo.h" line="2688"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="surface" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo-surface.c"
                 line="1995">a #cairo_surface_t</doc>
            <type name="Surface" c:type="cairo_surface_t*"/>
          </instance-parameter>
          <parameter name="x_pixels_per_inch" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo-surface.c"
                 line="1996">horizontal pixels per inch</doc>
            <type name="gdouble" c:type="double*"/>
          </parameter>
          <parameter name="y_pixels_per_inch" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo-surface.c"
                 line="1997">vertical pixels per inch</doc>
            <type name="gdouble" c:type="double*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_font_options"
              c:identifier="cairo_surface_get_font_options"
              version="1.0">
        <doc xml:space="preserve"
             filename="cairo-surface.c"
             line="1591">Retrieves the default font rendering options for the surface.
This allows display surfaces to report the correct subpixel order
for rendering on them, print surfaces to disable hinting of
metrics and so forth. The result can then be used with
cairo_scaled_font_create().</doc>
        <source-position filename="cairo.h" line="2646"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="surface" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo-surface.c"
                 line="1593">a #cairo_surface_t</doc>
            <type name="Surface" c:type="cairo_surface_t*"/>
          </instance-parameter>
          <parameter name="options" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo-surface.c"
                 line="1594">a #cairo_font_options_t object into which to store
  the retrieved options. All existing values are overwritten</doc>
            <type name="FontOptions" c:type="cairo_font_options_t*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_mime_data"
              c:identifier="cairo_surface_get_mime_data"
              version="1.10">
        <doc xml:space="preserve"
             filename="cairo-surface.c"
             line="1177">Return mime data previously attached to @surface using the
specified mime type.  If no data has been attached with the given
mime type, @data is set %NULL.</doc>
        <source-position filename="cairo.h" line="2628"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="surface" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo-surface.c"
                 line="1179">a #cairo_surface_t</doc>
            <type name="Surface" c:type="cairo_surface_t*"/>
          </instance-parameter>
          <parameter name="mime_type" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo-surface.c"
                 line="1180">the mime type of the image data</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter name="data" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo-surface.c"
                 line="1181">the image data to attached to the surface</doc>
            <type name="guint8" c:type="const unsigned char**"/>
          </parameter>
          <parameter name="length" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo-surface.c"
                 line="1182">the length of the image data</doc>
            <type name="gulong" c:type="unsigned long*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_reference_count"
              c:identifier="cairo_surface_get_reference_count"
              version="1.4"
              introspectable="0">
        <doc xml:space="preserve"
             filename="cairo-surface.c"
             line="1004">Returns the current reference count of @surface.</doc>
        <source-position filename="cairo.h" line="2489"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cairo-surface.c"
               line="1010">the current reference count of @surface.  If the
object is a nil object, 0 will be returned.</doc>
          <type name="guint" c:type="unsigned int"/>
        </return-value>
        <parameters>
          <instance-parameter name="surface" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo-surface.c"
                 line="1006">a #cairo_surface_t</doc>
            <type name="Surface" c:type="cairo_surface_t*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_type"
              c:identifier="cairo_surface_get_type"
              version="1.2">
        <doc xml:space="preserve"
             filename="cairo-surface.c"
             line="211">This function returns the type of the backend used to create
a surface. See #cairo_surface_type_t for available types.</doc>
        <source-position filename="cairo.h" line="2586"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cairo-surface.c"
               line="218">The type of @surface.</doc>
          <type name="SurfaceType" c:type="cairo_surface_type_t"/>
        </return-value>
        <parameters>
          <instance-parameter name="surface" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo-surface.c"
                 line="213">a #cairo_surface_t</doc>
            <type name="Surface" c:type="cairo_surface_t*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_user_data"
              c:identifier="cairo_surface_get_user_data"
              version="1.0">
        <doc xml:space="preserve"
             filename="cairo-surface.c"
             line="1118">Return user data previously attached to @surface using the specified
key.  If no user data has been attached with the given key this
function returns %NULL.</doc>
        <source-position filename="cairo.h" line="2605"/>
        <return-value transfer-ownership="none" nullable="1">
          <doc xml:space="preserve"
               filename="cairo-surface.c"
               line="1128">the user data previously attached or %NULL.</doc>
          <type name="gpointer" c:type="void*"/>
        </return-value>
        <parameters>
          <instance-parameter name="surface" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo-surface.c"
                 line="1120">a #cairo_surface_t</doc>
            <type name="Surface" c:type="cairo_surface_t*"/>
          </instance-parameter>
          <parameter name="key" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo-surface.c"
                 line="1121">the address of the #cairo_user_data_key_t the user data was
attached to</doc>
            <type name="UserDataKey" c:type="const cairo_user_data_key_t*"/>
          </parameter>
        </parameters>
      </method>
      <method name="has_show_text_glyphs"
              c:identifier="cairo_surface_has_show_text_glyphs"
              version="1.8">
        <doc xml:space="preserve"
             filename="cairo-surface.c"
             line="2590">Returns whether the surface supports
sophisticated cairo_show_text_glyphs() operations.  That is,
whether it actually uses the provided text and cluster data
to a cairo_show_text_glyphs() call.

Note: Even if this function returns %FALSE, a
cairo_show_text_glyphs() operation targeted at @surface will
still succeed.  It just will
act like a cairo_show_glyphs() operation.  Users can use this
function to avoid computing UTF-8 text and cluster mapping if the
target surface does not use it.</doc>
        <source-position filename="cairo.h" line="2699"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cairo-surface.c"
               line="2606">%TRUE if @surface supports
              cairo_show_text_glyphs(), %FALSE otherwise</doc>
          <type name="Bool" c:type="cairo_bool_t"/>
        </return-value>
        <parameters>
          <instance-parameter name="surface" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo-surface.c"
                 line="2592">a #cairo_surface_t</doc>
            <type name="Surface" c:type="cairo_surface_t*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="map_to_image"
              c:identifier="cairo_surface_map_to_image"
              version="1.12">
        <doc xml:space="preserve"
             filename="cairo-surface.c"
             line="744">Returns an image surface that is the most efficient mechanism for
modifying the backing store of the target surface. The region retrieved
may be limited to the @extents or %NULL for the whole surface

Note, the use of the original surface as a target or source whilst
it is mapped is undefined. The result of mapping the surface
multiple times is undefined. Calling cairo_surface_destroy() or
cairo_surface_finish() on the resulting image surface results in
undefined behavior. Changing the device transform of the image
surface or of @surface before the image surface is unmapped results
in undefined behavior.</doc>
        <source-position filename="cairo.h" line="2365"/>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve"
               filename="cairo-surface.c"
               line="761">a pointer to the newly allocated image surface. The caller
must use cairo_surface_unmap_image() to destroy this image surface.

This function always returns a valid pointer, but it will return a
pointer to a "nil" surface if @other is already in an error state
or any other error occurs. If the returned pointer does not have an
error status, it is guaranteed to be an image surface whose format
is not %CAIRO_FORMAT_INVALID.</doc>
          <type name="Surface" c:type="cairo_surface_t*"/>
        </return-value>
        <parameters>
          <instance-parameter name="surface" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo-surface.c"
                 line="746">an existing surface used to extract the image from</doc>
            <type name="Surface" c:type="cairo_surface_t*"/>
          </instance-parameter>
          <parameter name="extents" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo-surface.c"
                 line="747">limit the extraction to an rectangular region</doc>
            <type name="RectangleInt" c:type="const cairo_rectangle_int_t*"/>
          </parameter>
        </parameters>
      </method>
      <method name="mark_dirty"
              c:identifier="cairo_surface_mark_dirty"
              version="1.0">
        <doc xml:space="preserve"
             filename="cairo-surface.c"
             line="1671">Tells cairo that drawing has been done to surface using means other
than cairo, and that cairo should reread any cached areas. Note
that you must call cairo_surface_flush() before doing such drawing.</doc>
        <source-position filename="cairo.h" line="2653"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="surface" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo-surface.c"
                 line="1673">a #cairo_surface_t</doc>
            <type name="Surface" c:type="cairo_surface_t*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="mark_dirty_rectangle"
              c:identifier="cairo_surface_mark_dirty_rectangle"
              version="1.0">
        <doc xml:space="preserve"
             filename="cairo-surface.c"
             line="1699">Like cairo_surface_mark_dirty(), but drawing has been done only to
the specified rectangle, so that cairo can retain cached contents
for other parts of the surface.

Any cached clip set on the surface will be reset by this function,
to make sure that future cairo calls have the clip set that they
expect.</doc>
        <source-position filename="cairo.h" line="2656"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="surface" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo-surface.c"
                 line="1701">a #cairo_surface_t</doc>
            <type name="Surface" c:type="cairo_surface_t*"/>
          </instance-parameter>
          <parameter name="x" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo-surface.c"
                 line="1702">X coordinate of dirty rectangle</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="y" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo-surface.c"
                 line="1703">Y coordinate of dirty rectangle</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="width" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo-surface.c"
                 line="1704">width of dirty rectangle</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="height" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo-surface.c"
                 line="1705">height of dirty rectangle</doc>
            <type name="gint" c:type="int"/>
          </parameter>
        </parameters>
      </method>
      <method name="observer_add_fill_callback"
              c:identifier="cairo_surface_observer_add_fill_callback"
              version="1.12"
              introspectable="0">
        <doc xml:space="preserve"
             filename="cairo-surface-observer.c"
             line="1510">Adds a callback for fill operations on the observed surface.</doc>
        <source-position filename="cairo.h" line="2422"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cairo-surface-observer.c"
               line="1518">the status of the surface</doc>
          <type name="Status" c:type="cairo_status_t"/>
        </return-value>
        <parameters>
          <instance-parameter name="abstract_surface"
                              transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo-surface-observer.c"
                 line="1512">a #cairo_surface_observer_t</doc>
            <type name="Surface" c:type="cairo_surface_t*"/>
          </instance-parameter>
          <parameter name="func" transfer-ownership="none" closure="1">
            <doc xml:space="preserve"
                 filename="cairo-surface-observer.c"
                 line="1513">callback function for fill operations</doc>
            <type name="SurfaceObserverCallback"
                  c:type="cairo_surface_observer_callback_t"/>
          </parameter>
          <parameter name="data"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve"
                 filename="cairo-surface-observer.c"
                 line="1514">closure to pass to the callback</doc>
            <type name="gpointer" c:type="void*"/>
          </parameter>
        </parameters>
      </method>
      <method name="observer_add_finish_callback"
              c:identifier="cairo_surface_observer_add_finish_callback"
              version="1.10"
              introspectable="0">
        <doc xml:space="preserve"
             filename="cairo-surface-observer.c"
             line="1630">Adds a callback for finish operations on the observed surface.</doc>
        <source-position filename="cairo.h" line="2442"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cairo-surface-observer.c"
               line="1638">the status of the surface</doc>
          <type name="Status" c:type="cairo_status_t"/>
        </return-value>
        <parameters>
          <instance-parameter name="abstract_surface"
                              transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo-surface-observer.c"
                 line="1632">a #cairo_surface_observer_t</doc>
            <type name="Surface" c:type="cairo_surface_t*"/>
          </instance-parameter>
          <parameter name="func" transfer-ownership="none" closure="1">
            <doc xml:space="preserve"
                 filename="cairo-surface-observer.c"
                 line="1633">callback function for the finish operation</doc>
            <type name="SurfaceObserverCallback"
                  c:type="cairo_surface_observer_callback_t"/>
          </parameter>
          <parameter name="data"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve"
                 filename="cairo-surface-observer.c"
                 line="1634">closure to pass to the callback</doc>
            <type name="gpointer" c:type="void*"/>
          </parameter>
        </parameters>
      </method>
      <method name="observer_add_flush_callback"
              c:identifier="cairo_surface_observer_add_flush_callback"
              version="1.10"
              introspectable="0">
        <doc xml:space="preserve"
             filename="cairo-surface-observer.c"
             line="1600">Adds a callback for flush operations on the observed surface.</doc>
        <source-position filename="cairo.h" line="2437"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cairo-surface-observer.c"
               line="1608">the status of the surface</doc>
          <type name="Status" c:type="cairo_status_t"/>
        </return-value>
        <parameters>
          <instance-parameter name="abstract_surface"
                              transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo-surface-observer.c"
                 line="1602">a #cairo_surface_observer_t</doc>
            <type name="Surface" c:type="cairo_surface_t*"/>
          </instance-parameter>
          <parameter name="func" transfer-ownership="none" closure="1">
            <doc xml:space="preserve"
                 filename="cairo-surface-observer.c"
                 line="1603">callback for flush operations</doc>
            <type name="SurfaceObserverCallback"
                  c:type="cairo_surface_observer_callback_t"/>
          </parameter>
          <parameter name="data"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve"
                 filename="cairo-surface-observer.c"
                 line="1604">closure to pass to the callback</doc>
            <type name="gpointer" c:type="void*"/>
          </parameter>
        </parameters>
      </method>
      <method name="observer_add_glyphs_callback"
              c:identifier="cairo_surface_observer_add_glyphs_callback"
              version="1.10"
              introspectable="0">
        <doc xml:space="preserve"
             filename="cairo-surface-observer.c"
             line="1570">Adds a callback for glyph operations on the observed surface.</doc>
        <source-position filename="cairo.h" line="2432"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cairo-surface-observer.c"
               line="1578">the status of the surface</doc>
          <type name="Status" c:type="cairo_status_t"/>
        </return-value>
        <parameters>
          <instance-parameter name="abstract_surface"
                              transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo-surface-observer.c"
                 line="1572">a #cairo_surface_observer_t</doc>
            <type name="Surface" c:type="cairo_surface_t*"/>
          </instance-parameter>
          <parameter name="func" transfer-ownership="none" closure="1">
            <doc xml:space="preserve"
                 filename="cairo-surface-observer.c"
                 line="1573">callback function for glyph operations</doc>
            <type name="SurfaceObserverCallback"
                  c:type="cairo_surface_observer_callback_t"/>
          </parameter>
          <parameter name="data"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve"
                 filename="cairo-surface-observer.c"
                 line="1574">closure to pass to the callback</doc>
            <type name="gpointer" c:type="void*"/>
          </parameter>
        </parameters>
      </method>
      <method name="observer_add_mask_callback"
              c:identifier="cairo_surface_observer_add_mask_callback"
              version="1.12"
              introspectable="0">
        <doc xml:space="preserve"
             filename="cairo-surface-observer.c"
             line="1480">Adds a callback for mask operations on the observed surface.</doc>
        <source-position filename="cairo.h" line="2417"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cairo-surface-observer.c"
               line="1488">the status of the surface</doc>
          <type name="Status" c:type="cairo_status_t"/>
        </return-value>
        <parameters>
          <instance-parameter name="abstract_surface"
                              transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo-surface-observer.c"
                 line="1482">a #cairo_surface_observer_t</doc>
            <type name="Surface" c:type="cairo_surface_t*"/>
          </instance-parameter>
          <parameter name="func" transfer-ownership="none" closure="1">
            <doc xml:space="preserve"
                 filename="cairo-surface-observer.c"
                 line="1483">callback function for mask operations</doc>
            <type name="SurfaceObserverCallback"
                  c:type="cairo_surface_observer_callback_t"/>
          </parameter>
          <parameter name="data"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve"
                 filename="cairo-surface-observer.c"
                 line="1484">closure to pass to the callback</doc>
            <type name="gpointer" c:type="void*"/>
          </parameter>
        </parameters>
      </method>
      <method name="observer_add_paint_callback"
              c:identifier="cairo_surface_observer_add_paint_callback"
              version="1.12"
              introspectable="0">
        <doc xml:space="preserve"
             filename="cairo-surface-observer.c"
             line="1450">Adds a callback for paint operations on the observed surface.</doc>
        <source-position filename="cairo.h" line="2412"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cairo-surface-observer.c"
               line="1458">the status of the surface</doc>
          <type name="Status" c:type="cairo_status_t"/>
        </return-value>
        <parameters>
          <instance-parameter name="abstract_surface"
                              transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo-surface-observer.c"
                 line="1452">a #cairo_surface_observer_t</doc>
            <type name="Surface" c:type="cairo_surface_t*"/>
          </instance-parameter>
          <parameter name="func" transfer-ownership="none" closure="1">
            <doc xml:space="preserve"
                 filename="cairo-surface-observer.c"
                 line="1453">callback function for paint operations</doc>
            <type name="SurfaceObserverCallback"
                  c:type="cairo_surface_observer_callback_t"/>
          </parameter>
          <parameter name="data"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve"
                 filename="cairo-surface-observer.c"
                 line="1454">closure to pass to the callback</doc>
            <type name="gpointer" c:type="void*"/>
          </parameter>
        </parameters>
      </method>
      <method name="observer_add_stroke_callback"
              c:identifier="cairo_surface_observer_add_stroke_callback"
              version="1.12"
              introspectable="0">
        <doc xml:space="preserve"
             filename="cairo-surface-observer.c"
             line="1540">Adds a callback for stroke operations on the observed surface.</doc>
        <source-position filename="cairo.h" line="2427"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cairo-surface-observer.c"
               line="1548">the status of the surface</doc>
          <type name="Status" c:type="cairo_status_t"/>
        </return-value>
        <parameters>
          <instance-parameter name="abstract_surface"
                              transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo-surface-observer.c"
                 line="1542">a #cairo_surface_observer_t</doc>
            <type name="Surface" c:type="cairo_surface_t*"/>
          </instance-parameter>
          <parameter name="func" transfer-ownership="none" closure="1">
            <doc xml:space="preserve"
                 filename="cairo-surface-observer.c"
                 line="1543">callback function for stroke operations</doc>
            <type name="SurfaceObserverCallback"
                  c:type="cairo_surface_observer_callback_t"/>
          </parameter>
          <parameter name="data"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve"
                 filename="cairo-surface-observer.c"
                 line="1544">closure to pass to the callback</doc>
            <type name="gpointer" c:type="void*"/>
          </parameter>
        </parameters>
      </method>
      <method name="observer_elapsed"
              c:identifier="cairo_surface_observer_elapsed"
              version="1.12">
        <doc xml:space="preserve"
             filename="cairo-surface-observer.c"
             line="2095">Returns the total observation time.</doc>
        <source-position filename="cairo.h" line="2451"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cairo-surface-observer.c"
               line="2101">the elapsed time, in nanoseconds</doc>
          <type name="gdouble" c:type="double"/>
        </return-value>
        <parameters>
          <instance-parameter name="abstract_surface"
                              transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo-surface-observer.c"
                 line="2097">a #cairo_surface_observer_t</doc>
            <type name="Surface" c:type="cairo_surface_t*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="observer_print"
              c:identifier="cairo_surface_observer_print"
              version="1.12">
        <doc xml:space="preserve"
             filename="cairo-surface-observer.c"
             line="2062">Prints the observer log using the given callback.</doc>
        <source-position filename="cairo.h" line="2447"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cairo-surface-observer.c"
               line="2070">the status of the print operation</doc>
          <type name="Status" c:type="cairo_status_t"/>
        </return-value>
        <parameters>
          <instance-parameter name="abstract_surface"
                              transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo-surface-observer.c"
                 line="2064">a #cairo_surface_observer_t</doc>
            <type name="Surface" c:type="cairo_surface_t*"/>
          </instance-parameter>
          <parameter name="write_func" transfer-ownership="none" scope="call">
            <doc xml:space="preserve"
                 filename="cairo-surface-observer.c"
                 line="2065">callback for writing on a stream</doc>
            <type name="WriteFunc" c:type="cairo_write_func_t"/>
          </parameter>
          <parameter name="closure"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve"
                 filename="cairo-surface-observer.c"
                 line="2066">data to pass to @write_func</doc>
            <type name="gpointer" c:type="void*"/>
          </parameter>
        </parameters>
      </method>
      <method name="reference"
              c:identifier="cairo_surface_reference"
              version="1.0"
              introspectable="0">
        <doc xml:space="preserve"
             filename="cairo-surface.c"
             line="917">Increases the reference count on @surface by one. This prevents
@surface from being destroyed until a matching call to
cairo_surface_destroy() is made.

Use cairo_surface_get_reference_count() to get the number of
references to a #cairo_surface_t.</doc>
        <source-position filename="cairo.h" line="2477"/>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve"
               filename="cairo-surface.c"
               line="928">the referenced #cairo_surface_t.</doc>
          <type name="Surface" c:type="cairo_surface_t*"/>
        </return-value>
        <parameters>
          <instance-parameter name="surface" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo-surface.c"
                 line="919">a #cairo_surface_t</doc>
            <type name="Surface" c:type="cairo_surface_t*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="set_device_offset"
              c:identifier="cairo_surface_set_device_offset"
              version="1.0">
        <doc xml:space="preserve"
             filename="cairo-surface.c"
             line="1849">Sets an offset that is added to the device coordinates determined
by the CTM when drawing to @surface. One use case for this function
is when we want to create a #cairo_surface_t that redirects drawing
for a portion of an onscreen surface to an offscreen surface in a
way that is completely invisible to the user of the cairo
API. Setting a transformation via cairo_translate() isn't
sufficient to do this, since functions like
cairo_device_to_user() will expose the hidden offset.

Note that the offset affects drawing to the surface as well as
using the surface in a source pattern.</doc>
        <source-position filename="cairo.h" line="2673"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="surface" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo-surface.c"
                 line="1851">a #cairo_surface_t</doc>
            <type name="Surface" c:type="cairo_surface_t*"/>
          </instance-parameter>
          <parameter name="x_offset" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo-surface.c"
                 line="1852">the offset in the X direction, in device units</doc>
            <type name="gdouble" c:type="double"/>
          </parameter>
          <parameter name="y_offset" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo-surface.c"
                 line="1853">the offset in the Y direction, in device units</doc>
            <type name="gdouble" c:type="double"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_device_scale"
              c:identifier="cairo_surface_set_device_scale"
              version="1.14">
        <doc xml:space="preserve"
             filename="cairo-surface.c"
             line="1772">Sets a scale that is multiplied to the device coordinates determined
by the CTM when drawing to @surface. One common use for this is to
render to very high resolution display devices at a scale factor, so
that code that assumes 1 pixel will be a certain size will still work.
Setting a transformation via cairo_scale() isn't
sufficient to do this, since functions like
cairo_device_to_user() will expose the hidden scale.

Note that the scale affects drawing to the surface as well as
using the surface in a source pattern.</doc>
        <source-position filename="cairo.h" line="2663"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="surface" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo-surface.c"
                 line="1774">a #cairo_surface_t</doc>
            <type name="Surface" c:type="cairo_surface_t*"/>
          </instance-parameter>
          <parameter name="x_scale" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo-surface.c"
                 line="1775">a scale factor in the X direction</doc>
            <type name="gdouble" c:type="double"/>
          </parameter>
          <parameter name="y_scale" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo-surface.c"
                 line="1776">a scale factor in the Y direction</doc>
            <type name="gdouble" c:type="double"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_fallback_resolution"
              c:identifier="cairo_surface_set_fallback_resolution"
              version="1.2">
        <doc xml:space="preserve"
             filename="cairo-surface.c"
             line="1925">Set the horizontal and vertical resolution for image fallbacks.

When certain operations aren't supported natively by a backend,
cairo will fallback by rendering operations to an image and then
overlaying that image onto the output. For backends that are
natively vector-oriented, this function can be used to set the
resolution used for these image fallbacks, (larger values will
result in more detailed images, but also larger file sizes).

Some examples of natively vector-oriented backends are the ps, pdf,
and svg backends.

For backends that are natively raster-oriented, image fallbacks are
still possible, but they are always performed at the native
device resolution. So this function has no effect on those
backends.

Note: The fallback resolution only takes effect at the time of
completing a page (with cairo_show_page() or cairo_copy_page()) so
there is currently no way to have more than one fallback resolution
in effect on a single page.

The default fallback resolution is 300 pixels per inch in both
dimensions.</doc>
        <source-position filename="cairo.h" line="2683"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="surface" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo-surface.c"
                 line="1927">a #cairo_surface_t</doc>
            <type name="Surface" c:type="cairo_surface_t*"/>
          </instance-parameter>
          <parameter name="x_pixels_per_inch" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo-surface.c"
                 line="1928">horizontal setting for pixels per inch</doc>
            <type name="gdouble" c:type="double"/>
          </parameter>
          <parameter name="y_pixels_per_inch" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo-surface.c"
                 line="1929">vertical setting for pixels per inch</doc>
            <type name="gdouble" c:type="double"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_mime_data"
              c:identifier="cairo_surface_set_mime_data"
              version="1.10">
        <doc xml:space="preserve"
             filename="cairo-surface.c"
             line="1378">Attach an image in the format @mime_type to @surface. To remove
the data from a surface, call this function with same mime type
and %NULL for @data.

The attached image (or filename) data can later be used by backends
which support it (currently: PDF, PS, SVG and Win32 Printing
surfaces) to emit this data instead of making a snapshot of the
@surface.  This approach tends to be faster and requires less
memory and disk space.

The recognized MIME types are the following: %CAIRO_MIME_TYPE_JPEG,
%CAIRO_MIME_TYPE_PNG, %CAIRO_MIME_TYPE_JP2, %CAIRO_MIME_TYPE_URI,
%CAIRO_MIME_TYPE_UNIQUE_ID, %CAIRO_MIME_TYPE_JBIG2,
%CAIRO_MIME_TYPE_JBIG2_GLOBAL, %CAIRO_MIME_TYPE_JBIG2_GLOBAL_ID,
%CAIRO_MIME_TYPE_CCITT_FAX, %CAIRO_MIME_TYPE_CCITT_FAX_PARAMS.

See corresponding backend surface docs for details about which MIME
types it can handle. Caution: the associated MIME data will be
discarded if you draw on the surface afterwards. Use this function
with care.

Even if a backend supports a MIME type, that does not mean cairo
will always be able to use the attached MIME data. For example, if
the backend does not natively support the compositing operation used
to apply the MIME data to the backend. In that case, the MIME data
will be ignored. Therefore, to apply an image in all cases, it is best
to create an image surface which contains the decoded image data and
then attach the MIME data to that. This ensures the image will always
be used while still allowing the MIME data to be used whenever
possible.</doc>
        <source-position filename="cairo.h" line="2634"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cairo-surface.c"
               line="1420">%CAIRO_STATUS_SUCCESS or %CAIRO_STATUS_NO_MEMORY if a
slot could not be allocated for the user data.</doc>
          <type name="Status" c:type="cairo_status_t"/>
        </return-value>
        <parameters>
          <instance-parameter name="surface" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo-surface.c"
                 line="1380">a #cairo_surface_t</doc>
            <type name="Surface" c:type="cairo_surface_t*"/>
          </instance-parameter>
          <parameter name="mime_type" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo-surface.c"
                 line="1381">the MIME type of the image data</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter name="data" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo-surface.c"
                 line="1382">the image data to attach to the surface</doc>
            <type name="guint8" c:type="const unsigned char*"/>
          </parameter>
          <parameter name="length" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo-surface.c"
                 line="1383">the length of the image data</doc>
            <type name="gulong" c:type="unsigned long"/>
          </parameter>
          <parameter name="destroy" transfer-ownership="none" scope="async">
            <doc xml:space="preserve"
                 filename="cairo-surface.c"
                 line="1384">a #cairo_destroy_func_t which will be called when the
surface is destroyed or when new image data is attached using the
same mime type.</doc>
            <type name="DestroyFunc" c:type="cairo_destroy_func_t"/>
          </parameter>
          <parameter name="closure"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve"
                 filename="cairo-surface.c"
                 line="1387">the data to be passed to the @destroy notifier</doc>
            <type name="gpointer" c:type="void*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_user_data"
              c:identifier="cairo_surface_set_user_data"
              version="1.0"
              introspectable="0">
        <doc xml:space="preserve"
             filename="cairo-surface.c"
             line="1143">Attach user data to @surface.  To remove user data from a surface,
call this function with the key that was used to set it and %NULL
for @data.</doc>
        <source-position filename="cairo.h" line="2609"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cairo-surface.c"
               line="1156">%CAIRO_STATUS_SUCCESS or %CAIRO_STATUS_NO_MEMORY if a
slot could not be allocated for the user data.</doc>
          <type name="Status" c:type="cairo_status_t"/>
        </return-value>
        <parameters>
          <instance-parameter name="surface" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo-surface.c"
                 line="1145">a #cairo_surface_t</doc>
            <type name="Surface" c:type="cairo_surface_t*"/>
          </instance-parameter>
          <parameter name="key" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo-surface.c"
                 line="1146">the address of a #cairo_user_data_key_t to attach the user data to</doc>
            <type name="UserDataKey" c:type="const cairo_user_data_key_t*"/>
          </parameter>
          <parameter name="user_data"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve"
                 filename="cairo-surface.c"
                 line="1147">the user data to attach to the surface</doc>
            <type name="gpointer" c:type="void*"/>
          </parameter>
          <parameter name="destroy" transfer-ownership="none" scope="async">
            <doc xml:space="preserve"
                 filename="cairo-surface.c"
                 line="1148">a #cairo_destroy_func_t which will be called when the
surface is destroyed or when new user data is attached using the
same key.</doc>
            <type name="DestroyFunc" c:type="cairo_destroy_func_t"/>
          </parameter>
        </parameters>
      </method>
      <method name="show_page"
              c:identifier="cairo_surface_show_page"
              version="1.6">
        <doc xml:space="preserve"
             filename="cairo-surface.c"
             line="2500">Emits and clears the current page for backends that support multiple
pages.  Use cairo_surface_copy_page() if you don't want to clear the page.

There is a convenience function for this that takes a #cairo_t,
namely cairo_show_page().</doc>
        <source-position filename="cairo.h" line="2696"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="surface" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo-surface.c"
                 line="2502">a #cairo_Surface_t</doc>
            <type name="Surface" c:type="cairo_surface_t*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="status" c:identifier="cairo_surface_status" version="1.0">
        <doc xml:space="preserve"
             filename="cairo-surface.c"
             line="250">Checks whether an error has previously occurred for this
surface.</doc>
        <source-position filename="cairo.h" line="2492"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cairo-surface.c"
               line="257">%CAIRO_STATUS_SUCCESS, %CAIRO_STATUS_NULL_POINTER,
%CAIRO_STATUS_NO_MEMORY, %CAIRO_STATUS_READ_ERROR,
%CAIRO_STATUS_INVALID_CONTENT, %CAIRO_STATUS_INVALID_FORMAT, or
%CAIRO_STATUS_INVALID_VISUAL.</doc>
          <type name="Status" c:type="cairo_status_t"/>
        </return-value>
        <parameters>
          <instance-parameter name="surface" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo-surface.c"
                 line="252">a #cairo_surface_t</doc>
            <type name="Surface" c:type="cairo_surface_t*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="supports_mime_type"
              c:identifier="cairo_surface_supports_mime_type"
              version="1.12">
        <doc xml:space="preserve"
             filename="cairo-surface.c"
             line="1480">Return whether @surface supports @mime_type.</doc>
        <source-position filename="cairo.h" line="2642"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cairo-surface.c"
               line="1487">%TRUE if @surface supports
              @mime_type, %FALSE otherwise</doc>
          <type name="Bool" c:type="cairo_bool_t"/>
        </return-value>
        <parameters>
          <instance-parameter name="surface" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo-surface.c"
                 line="1482">a #cairo_surface_t</doc>
            <type name="Surface" c:type="cairo_surface_t*"/>
          </instance-parameter>
          <parameter name="mime_type" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo-surface.c"
                 line="1483">the mime type</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </method>
      <method name="unmap_image"
              c:identifier="cairo_surface_unmap_image"
              version="1.12">
        <doc xml:space="preserve"
             filename="cairo-surface.c"
             line="817">Unmaps the image surface as returned from #cairo_surface_map_to_image().

The content of the image will be uploaded to the target surface.
Afterwards, the image is destroyed.

Using an image surface which wasn't returned by cairo_surface_map_to_image()
results in undefined behavior.</doc>
        <source-position filename="cairo.h" line="2369"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="surface" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo-surface.c"
                 line="819">the surface passed to cairo_surface_map_to_image().</doc>
            <type name="Surface" c:type="cairo_surface_t*"/>
          </instance-parameter>
          <parameter name="image" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo-surface.c"
                 line="820">the currently mapped image</doc>
            <type name="Surface" c:type="cairo_surface_t*"/>
          </parameter>
        </parameters>
      </method>
      <method name="write_to_png"
              c:identifier="cairo_surface_write_to_png"
              version="1.0">
        <doc xml:space="preserve"
             filename="cairo-png.c"
             line="462">Writes the contents of @surface to a new file @filename as a PNG
image.</doc>
        <source-position filename="cairo.h" line="2594"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cairo-png.c"
               line="471">%CAIRO_STATUS_SUCCESS if the PNG file was written
successfully. Otherwise, %CAIRO_STATUS_NO_MEMORY if memory could not
be allocated for the operation or
%CAIRO_STATUS_SURFACE_TYPE_MISMATCH if the surface does not have
pixel contents, or %CAIRO_STATUS_WRITE_ERROR if an I/O error occurs
while attempting to write the file, or %CAIRO_STATUS_PNG_ERROR if libpng
returned an error.</doc>
          <type name="Status" c:type="cairo_status_t"/>
        </return-value>
        <parameters>
          <instance-parameter name="surface" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo-png.c"
                 line="464">a #cairo_surface_t with pixel contents</doc>
            <type name="Surface" c:type="cairo_surface_t*"/>
          </instance-parameter>
          <parameter name="filename" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo-png.c"
                 line="465">the name of a file to write to; on Windows this filename
  is encoded in UTF-8.</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </method>
      <method name="write_to_png_stream"
              c:identifier="cairo_surface_write_to_png_stream"
              version="1.0">
        <doc xml:space="preserve"
             filename="cairo-png.c"
             line="537">Writes the image surface to the write function.</doc>
        <source-position filename="cairo.h" line="2598"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cairo-png.c"
               line="545">%CAIRO_STATUS_SUCCESS if the PNG file was written
successfully.  Otherwise, %CAIRO_STATUS_NO_MEMORY is returned if
memory could not be allocated for the operation,
%CAIRO_STATUS_SURFACE_TYPE_MISMATCH if the surface does not have
pixel contents, or %CAIRO_STATUS_PNG_ERROR if libpng
returned an error.</doc>
          <type name="Status" c:type="cairo_status_t"/>
        </return-value>
        <parameters>
          <instance-parameter name="surface" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo-png.c"
                 line="539">a #cairo_surface_t with pixel contents</doc>
            <type name="Surface" c:type="cairo_surface_t*"/>
          </instance-parameter>
          <parameter name="write_func" transfer-ownership="none" scope="call">
            <doc xml:space="preserve"
                 filename="cairo-png.c"
                 line="540">a #cairo_write_func_t</doc>
            <type name="WriteFunc" c:type="cairo_write_func_t"/>
          </parameter>
          <parameter name="closure"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve"
                 filename="cairo-png.c"
                 line="541">closure data for the write function</doc>
            <type name="gpointer" c:type="void*"/>
          </parameter>
        </parameters>
      </method>
    </record>
    <callback name="SurfaceObserverCallback"
              c:type="cairo_surface_observer_callback_t"
              version="1.12">
      <doc xml:space="preserve"
           filename="cairo.h"
           line="2397">A generic callback function for surface operations.</doc>
      <source-position filename="cairo.h" line="2407"/>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="observer" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cairo.h"
               line="2399">the #cairo_surface_observer_t</doc>
          <type name="Surface" c:type="cairo_surface_t*"/>
        </parameter>
        <parameter name="target" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cairo.h"
               line="2400">the observed surface</doc>
          <type name="Surface" c:type="cairo_surface_t*"/>
        </parameter>
        <parameter name="data"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1">
          <doc xml:space="preserve"
               filename="cairo.h"
               line="2401">closure used when adding the callback</doc>
          <type name="gpointer" c:type="void*"/>
        </parameter>
      </parameters>
    </callback>
    <enumeration name="SurfaceObserverMode"
                 version="1.12"
                 c:type="cairo_surface_observer_mode_t">
      <doc xml:space="preserve"
           filename="cairo.h"
           line="2379">Whether operations should be recorded.</doc>
      <source-position filename="cairo.h" line="2391"/>
      <member name="normal"
              value="0"
              c:identifier="CAIRO_SURFACE_OBSERVER_NORMAL">
        <doc xml:space="preserve"
             filename="cairo.h"
             line="2381">no recording is done</doc>
      </member>
      <member name="record_operations"
              value="1"
              c:identifier="CAIRO_SURFACE_OBSERVER_RECORD_OPERATIONS">
        <doc xml:space="preserve"
             filename="cairo.h"
             line="2382">operations are recorded</doc>
      </member>
    </enumeration>
    <enumeration name="SurfaceType"
                 version="1.2"
                 glib:type-name="cairo_surface_type_t"
                 glib:get-type="cairo_gobject_surface_type_get_type"
                 c:type="cairo_surface_type_t">
      <doc xml:space="preserve"
           filename="cairo.h"
           line="2494">#cairo_surface_type_t is used to describe the type of a given
surface. The surface types are also known as "backends" or "surface
backends" within cairo.

The type of a surface is determined by the function used to create
it, which will generally be of the form
&lt;function&gt;cairo_&lt;emphasis&gt;type&lt;/emphasis&gt;_surface_create(&lt;!-- --&gt;)&lt;/function&gt;,
(though see cairo_surface_create_similar() as well).

The surface type can be queried with cairo_surface_get_type()

The various #cairo_surface_t functions can be used with surfaces of
any type, but some backends also provide type-specific functions
that must only be called with a surface of the appropriate
type. These functions have names that begin with
&lt;literal&gt;cairo_&lt;emphasis&gt;type&lt;/emphasis&gt;_surface&lt;/literal&gt; such as cairo_image_surface_get_width().

The behavior of calling a type-specific function with a surface of
the wrong type is undefined.

New entries may be added in future versions.</doc>
      <member name="image"
              value="0"
              c:identifier="CAIRO_SURFACE_TYPE_IMAGE"
              glib:nick="image"
              glib:name="CAIRO_SURFACE_TYPE_IMAGE">
        <doc xml:space="preserve"
             filename="cairo.h"
             line="2496">The surface is of type image, since 1.2</doc>
      </member>
      <member name="pdf"
              value="1"
              c:identifier="CAIRO_SURFACE_TYPE_PDF"
              glib:nick="pdf"
              glib:name="CAIRO_SURFACE_TYPE_PDF">
        <doc xml:space="preserve"
             filename="cairo.h"
             line="2497">The surface is of type pdf, since 1.2</doc>
      </member>
      <member name="ps"
              value="2"
              c:identifier="CAIRO_SURFACE_TYPE_PS"
              glib:nick="ps"
              glib:name="CAIRO_SURFACE_TYPE_PS">
        <doc xml:space="preserve"
             filename="cairo.h"
             line="2498">The surface is of type ps, since 1.2</doc>
      </member>
      <member name="xlib"
              value="3"
              c:identifier="CAIRO_SURFACE_TYPE_XLIB"
              glib:nick="xlib"
              glib:name="CAIRO_SURFACE_TYPE_XLIB">
        <doc xml:space="preserve"
             filename="cairo.h"
             line="2499">The surface is of type xlib, since 1.2</doc>
      </member>
      <member name="xcb"
              value="4"
              c:identifier="CAIRO_SURFACE_TYPE_XCB"
              glib:nick="xcb"
              glib:name="CAIRO_SURFACE_TYPE_XCB">
        <doc xml:space="preserve"
             filename="cairo.h"
             line="2500">The surface is of type xcb, since 1.2</doc>
      </member>
      <member name="glitz"
              value="5"
              c:identifier="CAIRO_SURFACE_TYPE_GLITZ"
              glib:nick="glitz"
              glib:name="CAIRO_SURFACE_TYPE_GLITZ">
        <doc xml:space="preserve"
             filename="cairo.h"
             line="2501">The surface is of type glitz, since 1.2, deprecated 1.18
  (glitz support have been removed, this surface type will never be set by cairo)</doc>
      </member>
      <member name="quartz"
              value="6"
              c:identifier="CAIRO_SURFACE_TYPE_QUARTZ"
              glib:nick="quartz"
              glib:name="CAIRO_SURFACE_TYPE_QUARTZ">
        <doc xml:space="preserve"
             filename="cairo.h"
             line="2503">The surface is of type quartz, since 1.2</doc>
      </member>
      <member name="win32"
              value="7"
              c:identifier="CAIRO_SURFACE_TYPE_WIN32"
              glib:nick="win32"
              glib:name="CAIRO_SURFACE_TYPE_WIN32">
        <doc xml:space="preserve"
             filename="cairo.h"
             line="2504">The surface is of type win32, since 1.2</doc>
      </member>
      <member name="beos"
              value="8"
              c:identifier="CAIRO_SURFACE_TYPE_BEOS"
              glib:nick="beos"
              glib:name="CAIRO_SURFACE_TYPE_BEOS">
        <doc xml:space="preserve"
             filename="cairo.h"
             line="2505">The surface is of type beos, since 1.2, deprecated 1.18
  (beos support have been removed, this surface type will never be set by cairo)</doc>
      </member>
      <member name="directfb"
              value="9"
              c:identifier="CAIRO_SURFACE_TYPE_DIRECTFB"
              glib:nick="directfb"
              glib:name="CAIRO_SURFACE_TYPE_DIRECTFB">
        <doc xml:space="preserve"
             filename="cairo.h"
             line="2507">The surface is of type directfb, since 1.2, deprecated 1.18
  (directfb support have been removed, this surface type will never be set by cairo)</doc>
      </member>
      <member name="svg"
              value="10"
              c:identifier="CAIRO_SURFACE_TYPE_SVG"
              glib:nick="svg"
              glib:name="CAIRO_SURFACE_TYPE_SVG">
        <doc xml:space="preserve"
             filename="cairo.h"
             line="2509">The surface is of type svg, since 1.2</doc>
      </member>
      <member name="os2"
              value="11"
              c:identifier="CAIRO_SURFACE_TYPE_OS2"
              glib:nick="os2"
              glib:name="CAIRO_SURFACE_TYPE_OS2">
        <doc xml:space="preserve"
             filename="cairo.h"
             line="2510">The surface is of type os2, since 1.4, deprecated 1.18
  (os2 support have been removed, this surface type will never be set by cairo)</doc>
      </member>
      <member name="win32_printing"
              value="12"
              c:identifier="CAIRO_SURFACE_TYPE_WIN32_PRINTING"
              glib:nick="win32-printing"
              glib:name="CAIRO_SURFACE_TYPE_WIN32_PRINTING">
        <doc xml:space="preserve"
             filename="cairo.h"
             line="2512">The surface is a win32 printing surface, since 1.6</doc>
      </member>
      <member name="quartz_image"
              value="13"
              c:identifier="CAIRO_SURFACE_TYPE_QUARTZ_IMAGE"
              glib:nick="quartz-image"
              glib:name="CAIRO_SURFACE_TYPE_QUARTZ_IMAGE">
        <doc xml:space="preserve"
             filename="cairo.h"
             line="2513">The surface is of type quartz_image, since 1.6</doc>
      </member>
      <member name="script"
              value="14"
              c:identifier="CAIRO_SURFACE_TYPE_SCRIPT"
              glib:nick="script"
              glib:name="CAIRO_SURFACE_TYPE_SCRIPT">
        <doc xml:space="preserve"
             filename="cairo.h"
             line="2514">The surface is of type script, since 1.10</doc>
      </member>
      <member name="qt"
              value="15"
              c:identifier="CAIRO_SURFACE_TYPE_QT"
              glib:nick="qt"
              glib:name="CAIRO_SURFACE_TYPE_QT">
        <doc xml:space="preserve"
             filename="cairo.h"
             line="2515">The surface is of type Qt, since 1.10, deprecated 1.18
  (Ot support have been removed, this surface type will never be set by cairo)</doc>
      </member>
      <member name="recording"
              value="16"
              c:identifier="CAIRO_SURFACE_TYPE_RECORDING"
              glib:nick="recording"
              glib:name="CAIRO_SURFACE_TYPE_RECORDING">
        <doc xml:space="preserve"
             filename="cairo.h"
             line="2517">The surface is of type recording, since 1.10</doc>
      </member>
      <member name="vg"
              value="17"
              c:identifier="CAIRO_SURFACE_TYPE_VG"
              glib:nick="vg"
              glib:name="CAIRO_SURFACE_TYPE_VG">
        <doc xml:space="preserve"
             filename="cairo.h"
             line="2518">The surface is a OpenVG surface, since 1.10, deprecated 1.18
  (OpenVG support have been removed, this surface type will never be set by cairo)</doc>
      </member>
      <member name="gl"
              value="18"
              c:identifier="CAIRO_SURFACE_TYPE_GL"
              glib:nick="gl"
              glib:name="CAIRO_SURFACE_TYPE_GL">
        <doc xml:space="preserve"
             filename="cairo.h"
             line="2520">The surface is of type OpenGL, since 1.10, deprecated 1.18
  (OpenGL support have been removed, this surface type will never be set by cairo)</doc>
      </member>
      <member name="drm"
              value="19"
              c:identifier="CAIRO_SURFACE_TYPE_DRM"
              glib:nick="drm"
              glib:name="CAIRO_SURFACE_TYPE_DRM">
        <doc xml:space="preserve"
             filename="cairo.h"
             line="2522">The surface is of type Direct Render Manager, since 1.10, deprecated 1.18
  (DRM support have been removed, this surface type will never be set by cairo)</doc>
      </member>
      <member name="tee"
              value="20"
              c:identifier="CAIRO_SURFACE_TYPE_TEE"
              glib:nick="tee"
              glib:name="CAIRO_SURFACE_TYPE_TEE">
        <doc xml:space="preserve"
             filename="cairo.h"
             line="2524">The surface is of type 'tee' (a multiplexing surface), since 1.10</doc>
      </member>
      <member name="xml"
              value="21"
              c:identifier="CAIRO_SURFACE_TYPE_XML"
              glib:nick="xml"
              glib:name="CAIRO_SURFACE_TYPE_XML">
        <doc xml:space="preserve"
             filename="cairo.h"
             line="2525">The surface is of type XML (for debugging), since 1.10</doc>
      </member>
      <member name="skia"
              value="22"
              c:identifier="CAIRO_SURFACE_TYPE_SKIA"
              glib:nick="skia"
              glib:name="CAIRO_SURFACE_TYPE_SKIA">
        <doc xml:space="preserve"
             filename="cairo.h"
             line="2526">The surface is of type Skia, since 1.10, deprecated 1.18
  (Skia support have been removed, this surface type will never be set by cairo)</doc>
      </member>
    </enumeration>
    <enumeration name="SvgUnit" version="1.16" c:type="cairo_svg_unit_t">
      <doc xml:space="preserve"
           filename="cairo-svg.h"
           line="56">#cairo_svg_unit_t is used to describe the units valid for coordinates and
lengths in the SVG specification.

See also:
- [SVG Units](https://www.w3.org/TR/SVG/coords.html#Units)
- [SVG Types](https://www.w3.org/TR/SVG/types.html#DataTypeLength)
- [CSS Length](https://www.w3.org/TR/css-values-3/#lengths)</doc>
      <source-position filename="cairo-svg.h" line="93"/>
      <member name="user" value="0" c:identifier="CAIRO_SVG_UNIT_USER">
        <doc xml:space="preserve"
             filename="cairo-svg.h"
             line="58">User unit, a value in the current coordinate system.
  If used in the root element for the initial coordinate systems it
  corresponds to pixels. (Since 1.16)</doc>
      </member>
      <member name="em" value="1" c:identifier="CAIRO_SVG_UNIT_EM">
        <doc xml:space="preserve"
             filename="cairo-svg.h"
             line="61">The size of the element's font. (Since 1.16)</doc>
      </member>
      <member name="ex" value="2" c:identifier="CAIRO_SVG_UNIT_EX">
        <doc xml:space="preserve"
             filename="cairo-svg.h"
             line="62">The x-height of the element’s font. (Since 1.16)</doc>
      </member>
      <member name="px" value="3" c:identifier="CAIRO_SVG_UNIT_PX">
        <doc xml:space="preserve"
             filename="cairo-svg.h"
             line="63">Pixels (1px = 1/96th of 1in). (Since 1.16)</doc>
      </member>
      <member name="in" value="4" c:identifier="CAIRO_SVG_UNIT_IN">
        <doc xml:space="preserve"
             filename="cairo-svg.h"
             line="64">Inches (1in = 2.54cm = 96px). (Since 1.16)</doc>
      </member>
      <member name="cm" value="5" c:identifier="CAIRO_SVG_UNIT_CM">
        <doc xml:space="preserve"
             filename="cairo-svg.h"
             line="65">Centimeters (1cm = 96px/2.54). (Since 1.16)</doc>
      </member>
      <member name="mm" value="6" c:identifier="CAIRO_SVG_UNIT_MM">
        <doc xml:space="preserve"
             filename="cairo-svg.h"
             line="66">Millimeters (1mm = 1/10th of 1cm). (Since 1.16)</doc>
      </member>
      <member name="pt" value="7" c:identifier="CAIRO_SVG_UNIT_PT">
        <doc xml:space="preserve"
             filename="cairo-svg.h"
             line="67">Points (1pt = 1/72th of 1in). (Since 1.16)</doc>
      </member>
      <member name="pc" value="8" c:identifier="CAIRO_SVG_UNIT_PC">
        <doc xml:space="preserve"
             filename="cairo-svg.h"
             line="68">Picas (1pc = 1/6th of 1in). (Since 1.16)</doc>
      </member>
      <member name="percent" value="9" c:identifier="CAIRO_SVG_UNIT_PERCENT">
        <doc xml:space="preserve"
             filename="cairo-svg.h"
             line="69">Percent, a value that is some fraction of another
  reference value. (Since 1.16)</doc>
      </member>
    </enumeration>
    <enumeration name="SvgVersion" version="1.2" c:type="cairo_svg_version_t">
      <doc xml:space="preserve"
           filename="cairo-svg.h"
           line="41">#cairo_svg_version_t is used to describe the version number of the SVG
specification that a generated SVG file will conform to.</doc>
      <source-position filename="cairo-svg.h" line="54"/>
      <member name="1" value="0" c:identifier="CAIRO_SVG_VERSION_1_1">
        <doc xml:space="preserve"
             filename="cairo-svg.h"
             line="43">The version 1.1 of the SVG specification. (Since 1.2)</doc>
      </member>
      <member name="2" value="1" c:identifier="CAIRO_SVG_VERSION_1_2">
        <doc xml:space="preserve"
             filename="cairo-svg.h"
             line="44">The version 1.2 of the SVG specification. (Since 1.2)</doc>
      </member>
    </enumeration>
    <constant name="TAG_CONTENT"
              value="cairo.content"
              c:type="CAIRO_TAG_CONTENT"
              version="1.18">
      <doc xml:space="preserve"
           filename="cairo.c"
           line="2905">Create a content tag.</doc>
      <source-position filename="cairo.h" line="1073"/>
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="TAG_CONTENT_REF"
              value="cairo.content_ref"
              c:type="CAIRO_TAG_CONTENT_REF"
              version="1.18">
      <doc xml:space="preserve"
           filename="cairo.c"
           line="2913">Create a content reference tag.</doc>
      <source-position filename="cairo.h" line="1074"/>
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="TAG_DEST"
              value="cairo.dest"
              c:type="CAIRO_TAG_DEST"
              version="1.16">
      <doc xml:space="preserve"
           filename="cairo.c"
           line="2887">Create a destination for a hyperlink. Destination tag attributes
are detailed at [Destinations][dest].</doc>
      <source-position filename="cairo.h" line="1071"/>
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="TAG_LINK"
              value="Link"
              c:type="CAIRO_TAG_LINK"
              version="1.16">
      <doc xml:space="preserve"
           filename="cairo.c"
           line="2896">Create hyperlink. Link tag attributes are detailed at
[Links][link].</doc>
      <source-position filename="cairo.h" line="1072"/>
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <record name="TextCluster"
            c:type="cairo_text_cluster_t"
            version="1.8"
            glib:type-name="cairo_text_cluster_t"
            glib:get-type="cairo_gobject_text_cluster_get_type"
            c:symbol-prefix="gobject_text_cluster">
      <doc xml:space="preserve"
           filename="cairo.h"
           line="1168">The #cairo_text_cluster_t structure holds information about a single
&lt;firstterm&gt;text cluster&lt;/firstterm&gt;.  A text cluster is a minimal
mapping of some glyphs corresponding to some UTF-8 text.

For a cluster to be valid, both @num_bytes and @num_glyphs should
be non-negative, and at least one should be non-zero.
Note that clusters with zero glyphs are not as well supported as
normal clusters.  For example, PDF rendering applications typically
ignore those clusters when PDF text is being selected.

See cairo_show_text_glyphs() for how clusters are used in advanced
text operations.</doc>
      <source-position filename="cairo.h" line="1191"/>
      <field name="num_bytes" writable="1">
        <doc xml:space="preserve"
             filename="cairo.h"
             line="1170">the number of bytes of UTF-8 text covered by cluster</doc>
        <type name="gint" c:type="int"/>
      </field>
      <field name="num_glyphs" writable="1">
        <doc xml:space="preserve"
             filename="cairo.h"
             line="1171">the number of glyphs covered by cluster</doc>
        <type name="gint" c:type="int"/>
      </field>
      <method name="free" c:identifier="cairo_text_cluster_free" version="1.8">
        <doc xml:space="preserve"
             filename="cairo-misc.c"
             line="264">Frees an array of #cairo_text_cluster's allocated using cairo_text_cluster_allocate().
This function is only useful to free text cluster array returned
by cairo_scaled_font_text_to_glyphs() where cairo returns
an array of text clusters that the user will free.
For all other uses, user can use their own allocation method
for text clusters.</doc>
        <source-position filename="cairo.h" line="1197"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="clusters" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cairo-misc.c"
                 line="266">array of text clusters to free, or %NULL</doc>
            <type name="TextCluster" c:type="cairo_text_cluster_t*"/>
          </instance-parameter>
        </parameters>
      </method>
    </record>
    <enumeration name="TextClusterFlags"
                 version="1.8"
                 glib:type-name="cairo_text_cluster_flags_t"
                 glib:get-type="cairo_gobject_text_cluster_flags_get_type"
                 c:type="cairo_text_cluster_flags_t">
      <doc xml:space="preserve"
           filename="cairo.h"
           line="1199">Specifies properties of a text cluster mapping.</doc>
      <member name="backward"
              value="1"
              c:identifier="CAIRO_TEXT_CLUSTER_FLAG_BACKWARD"
              glib:nick="backward"
              glib:name="CAIRO_TEXT_CLUSTER_FLAG_BACKWARD">
        <doc xml:space="preserve"
             filename="cairo.h"
             line="1201">The clusters in the cluster array
map to glyphs in the glyph array from end to start. (Since 1.8)</doc>
      </member>
    </enumeration>
    <record name="TextExtents" c:type="cairo_text_extents_t" version="1.0">
      <doc xml:space="preserve"
           filename="cairo.h"
           line="1212">The #cairo_text_extents_t structure stores the extents of a single
glyph or a string of glyphs in user-space coordinates. Because text
extents are in user-space coordinates, they are mostly, but not
entirely, independent of the current transformation matrix. If you call
&lt;literal&gt;cairo_scale(cr, 2.0, 2.0)&lt;/literal&gt;, text will
be drawn twice as big, but the reported text extents will not be
doubled. They will change slightly due to hinting (so you can't
assume that metrics are independent of the transformation matrix),
but otherwise will remain unchanged.</doc>
      <source-position filename="cairo.h" line="1248"/>
      <field name="x_bearing" writable="1">
        <doc xml:space="preserve"
             filename="cairo.h"
             line="1214">the horizontal distance from the origin to the
  leftmost part of the glyphs as drawn. Positive if the
  glyphs lie entirely to the right of the origin.</doc>
        <type name="gdouble" c:type="double"/>
      </field>
      <field name="y_bearing" writable="1">
        <doc xml:space="preserve"
             filename="cairo.h"
             line="1217">the vertical distance from the origin to the
  topmost part of the glyphs as drawn. Positive only if the
  glyphs lie completely below the origin; will usually be
  negative.</doc>
        <type name="gdouble" c:type="double"/>
      </field>
      <field name="width" writable="1">
        <doc xml:space="preserve"
             filename="cairo.h"
             line="1221">width of the glyphs as drawn</doc>
        <type name="gdouble" c:type="double"/>
      </field>
      <field name="height" writable="1">
        <doc xml:space="preserve"
             filename="cairo.h"
             line="1222">height of the glyphs as drawn</doc>
        <type name="gdouble" c:type="double"/>
      </field>
      <field name="x_advance" writable="1">
        <doc xml:space="preserve"
             filename="cairo.h"
             line="1223">distance to advance in the X direction
   after drawing these glyphs</doc>
        <type name="gdouble" c:type="double"/>
      </field>
      <field name="y_advance" writable="1">
        <doc xml:space="preserve"
             filename="cairo.h"
             line="1225">distance to advance in the Y direction
  after drawing these glyphs. Will typically be zero except
  for vertical text layout as found in East-Asian languages.</doc>
        <type name="gdouble" c:type="double"/>
      </field>
    </record>
    <record name="UserDataKey" c:type="cairo_user_data_key_t" version="1.0">
      <doc xml:space="preserve"
           filename="cairo.h"
           line="243">#cairo_user_data_key_t is used for attaching user data to cairo
data structures.  The actual contents of the struct is never used,
and there is no need to initialize the object; only the unique
address of a #cairo_data_key_t object is used.  Typically, you
would just use the address of a static #cairo_data_key_t object.</doc>
      <source-position filename="cairo.h" line="257"/>
      <field name="unused" writable="1">
        <doc xml:space="preserve"
             filename="cairo.h"
             line="245">not used; ignore.</doc>
        <type name="gint" c:type="int"/>
      </field>
    </record>
    <callback name="UserScaledFontInitFunc"
              c:type="cairo_user_scaled_font_init_func_t"
              version="1.8">
      <doc xml:space="preserve"
           filename="cairo.h"
           line="1798">#cairo_user_scaled_font_init_func_t is the type of function which is
called when a scaled-font needs to be created for a user font-face.

The cairo context @cr is not used by the caller, but is prepared in font
space, similar to what the cairo contexts passed to the render_glyph
method will look like.  The callback can use this context for extents
computation for example.  After the callback is called, @cr is checked
for any error status.

The @extents argument is where the user font sets the font extents for
@scaled_font.  It is in font space, which means that for most cases its
ascent and descent members should add to 1.0.  @extents is preset to
hold a value of 1.0 for ascent, height, and max_x_advance, and 0.0 for
descent and max_y_advance members.

The callback is optional.  If not set, default font extents as described
in the previous paragraph will be used.

Note that @scaled_font is not fully initialized at this
point and trying to use it for text operations in the callback will result
in deadlock.</doc>
      <source-position filename="cairo.h" line="1830"/>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve"
             filename="cairo.h"
             line="1826">%CAIRO_STATUS_SUCCESS upon success, or an error status on error.</doc>
        <type name="Status" c:type="cairo_status_t"/>
      </return-value>
      <parameters>
        <parameter name="scaled_font" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cairo.h"
               line="1800">the scaled-font being created</doc>
          <type name="ScaledFont" c:type="cairo_scaled_font_t*"/>
        </parameter>
        <parameter name="cr" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cairo.h"
               line="1801">a cairo context, in font space</doc>
          <type name="Context" c:type="cairo_t*"/>
        </parameter>
        <parameter name="extents" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cairo.h"
               line="1802">font extents to fill in, in font space</doc>
          <type name="FontExtents" c:type="cairo_font_extents_t*"/>
        </parameter>
      </parameters>
    </callback>
    <callback name="UserScaledFontRenderGlyphFunc"
              c:type="cairo_user_scaled_font_render_glyph_func_t"
              version="1.8">
      <doc xml:space="preserve"
           filename="cairo.h"
           line="1834">#cairo_user_scaled_font_render_glyph_func_t is the type of function which
is called when a user scaled-font needs to render a glyph.

The callback is mandatory, and expected to draw the glyph with code @glyph to
the cairo context @cr.  @cr is prepared such that the glyph drawing is done in
font space.  That is, the matrix set on @cr is the scale matrix of @scaled_font.
The @extents argument is where the user font sets the font extents for
@scaled_font.  However, if user prefers to draw in user space, they can
achieve that by changing the matrix on @cr.

All cairo rendering operations to @cr are permitted. However, when
this callback is set with
cairo_user_font_face_set_render_glyph_func(), the result is
undefined if any source other than the default source on @cr is
used.  That means, glyph bitmaps should be rendered using
cairo_mask() instead of cairo_paint().

When this callback is set with
cairo_user_font_face_set_render_color_glyph_func(), the default
source is black. Setting the source is a valid
operation. cairo_user_scaled_font_get_foreground_marker() or
cairo_user_scaled_font_get_foreground_source() may be called to
obtain the current source at the time the glyph is rendered.

Other non-default settings on @cr include a font size of 1.0 (given that
it is set up to be in font space), and font options corresponding to
@scaled_font.

The @extents argument is preset to have &lt;literal&gt;x_bearing&lt;/literal&gt;,
&lt;literal&gt;width&lt;/literal&gt;, and &lt;literal&gt;y_advance&lt;/literal&gt; of zero,
&lt;literal&gt;y_bearing&lt;/literal&gt; set to &lt;literal&gt;-font_extents.ascent&lt;/literal&gt;,
&lt;literal&gt;height&lt;/literal&gt; to &lt;literal&gt;font_extents.ascent+font_extents.descent&lt;/literal&gt;,
and &lt;literal&gt;x_advance&lt;/literal&gt; to &lt;literal&gt;font_extents.max_x_advance&lt;/literal&gt;.
The only field user needs to set in majority of cases is
&lt;literal&gt;x_advance&lt;/literal&gt;.
If the &lt;literal&gt;width&lt;/literal&gt; field is zero upon the callback returning
(which is its preset value), the glyph extents are automatically computed
based on the drawings done to @cr.  This is in most cases exactly what the
desired behavior is.  However, if for any reason the callback sets the
extents, it must be ink extents, and include the extents of all drawing
done to @cr in the callback.

Where both color and non-color callbacks has been set using
cairo_user_font_face_set_render_color_glyph_func(), and
cairo_user_font_face_set_render_glyph_func(), the color glyph
callback will be called first. If the color glyph callback returns
%CAIRO_STATUS_USER_FONT_NOT_IMPLEMENTED, any drawing operations are
discarded and the non-color callback will be called. This is the
only case in which the %CAIRO_STATUS_USER_FONT_NOT_IMPLEMENTED may
be returned from a render callback. This fallback sequence allows a
user font face to contain a combination of both color and non-color
glyphs.</doc>
      <source-position filename="cairo.h" line="1900"/>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve"
             filename="cairo.h"
             line="1894">%CAIRO_STATUS_SUCCESS upon success,
%CAIRO_STATUS_USER_FONT_NOT_IMPLEMENTED if fallback options should be tried,
or %CAIRO_STATUS_USER_FONT_ERROR or any other error status on error.</doc>
        <type name="Status" c:type="cairo_status_t"/>
      </return-value>
      <parameters>
        <parameter name="scaled_font" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cairo.h"
               line="1836">user scaled-font</doc>
          <type name="ScaledFont" c:type="cairo_scaled_font_t*"/>
        </parameter>
        <parameter name="glyph" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cairo.h"
               line="1837">glyph code to render</doc>
          <type name="gulong" c:type="unsigned long"/>
        </parameter>
        <parameter name="cr" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cairo.h"
               line="1838">cairo context to draw to, in font space</doc>
          <type name="Context" c:type="cairo_t*"/>
        </parameter>
        <parameter name="extents" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cairo.h"
               line="1839">glyph extents to fill in, in font space</doc>
          <type name="TextExtents" c:type="cairo_text_extents_t*"/>
        </parameter>
      </parameters>
    </callback>
    <callback name="UserScaledFontTextToGlyphsFunc"
              c:type="cairo_user_scaled_font_text_to_glyphs_func_t"
              version="1.8">
      <doc xml:space="preserve"
           filename="cairo.h"
           line="1905">#cairo_user_scaled_font_text_to_glyphs_func_t is the type of function which
is called to convert input text to an array of glyphs.  This is used by the
cairo_show_text() operation.

Using this callback the user-font has full control on glyphs and their
positions.  That means, it allows for features like ligatures and kerning,
as well as complex &lt;firstterm&gt;shaping&lt;/firstterm&gt; required for scripts like
Arabic and Indic.

The @num_glyphs argument is preset to the number of glyph entries available
in the @glyphs buffer. If the @glyphs buffer is %NULL, the value of
@num_glyphs will be zero.  If the provided glyph array is too short for
the conversion (or for convenience), a new glyph array may be allocated
using cairo_glyph_allocate() and placed in @glyphs.  Upon return,
@num_glyphs should contain the number of generated glyphs.  If the value
@glyphs points at has changed after the call, the caller will free the
allocated glyph array using cairo_glyph_free().  The caller will also free
the original value of @glyphs, so the callback shouldn't do so.
The callback should populate the glyph indices and positions (in font space)
assuming that the text is to be shown at the origin.

If @clusters is not %NULL, @num_clusters and @cluster_flags are also
non-%NULL, and cluster mapping should be computed. The semantics of how
cluster array allocation works is similar to the glyph array.  That is,
if @clusters initially points to a non-%NULL value, that array may be used
as a cluster buffer, and @num_clusters points to the number of cluster
entries available there.  If the provided cluster array is too short for
the conversion (or for convenience), a new cluster array may be allocated
using cairo_text_cluster_allocate() and placed in @clusters.  In this case,
the original value of @clusters will still be freed by the caller.  Upon
return, @num_clusters should contain the number of generated clusters.
If the value @clusters points at has changed after the call, the caller
will free the allocated cluster array using cairo_text_cluster_free().

The callback is optional.  If @num_glyphs is negative upon
the callback returning or if the return value
is %CAIRO_STATUS_USER_FONT_NOT_IMPLEMENTED, the unicode_to_glyph callback
is tried.  See #cairo_user_scaled_font_unicode_to_glyph_func_t.

Note: While cairo does not impose any limitation on glyph indices,
some applications may assume that a glyph index fits in a 16-bit
unsigned integer.  As such, it is advised that user-fonts keep their
glyphs in the 0 to 65535 range.  Furthermore, some applications may
assume that glyph 0 is a special glyph-not-found glyph.  User-fonts
are advised to use glyph 0 for such purposes and do not use that
glyph value for other purposes.</doc>
      <source-position filename="cairo.h" line="1970"/>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve"
             filename="cairo.h"
             line="1964">%CAIRO_STATUS_SUCCESS upon success,
%CAIRO_STATUS_USER_FONT_NOT_IMPLEMENTED if fallback options should be tried,
or %CAIRO_STATUS_USER_FONT_ERROR or any other error status on error.</doc>
        <type name="Status" c:type="cairo_status_t"/>
      </return-value>
      <parameters>
        <parameter name="scaled_font" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cairo.h"
               line="1907">the scaled-font being created</doc>
          <type name="ScaledFont" c:type="cairo_scaled_font_t*"/>
        </parameter>
        <parameter name="utf8" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cairo.h"
               line="1908">a string of text encoded in UTF-8</doc>
          <type name="utf8" c:type="const char*"/>
        </parameter>
        <parameter name="utf8_len" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cairo.h"
               line="1909">length of @utf8 in bytes</doc>
          <type name="gint" c:type="int"/>
        </parameter>
        <parameter name="glyphs" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cairo.h"
               line="1910">pointer to array of glyphs to fill, in font space</doc>
          <type name="Glyph" c:type="cairo_glyph_t**"/>
        </parameter>
        <parameter name="num_glyphs" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cairo.h"
               line="1911">pointer to number of glyphs</doc>
          <type name="gint" c:type="int*"/>
        </parameter>
        <parameter name="clusters" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cairo.h"
               line="1912">pointer to array of cluster mapping information to fill, or %NULL</doc>
          <type name="TextCluster" c:type="cairo_text_cluster_t**"/>
        </parameter>
        <parameter name="num_clusters" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cairo.h"
               line="1913">pointer to number of clusters</doc>
          <type name="gint" c:type="int*"/>
        </parameter>
        <parameter name="cluster_flags" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cairo.h"
               line="1914">pointer to location to store cluster flags corresponding to the
                output @clusters</doc>
          <type name="TextClusterFlags" c:type="cairo_text_cluster_flags_t*"/>
        </parameter>
      </parameters>
    </callback>
    <callback name="UserScaledFontUnicodeToGlyphFunc"
              c:type="cairo_user_scaled_font_unicode_to_glyph_func_t"
              version="1.8">
      <doc xml:space="preserve"
           filename="cairo.h"
           line="1979">#cairo_user_scaled_font_unicode_to_glyph_func_t is the type of function which
is called to convert an input Unicode character to a single glyph.
This is used by the cairo_show_text() operation.

This callback is used to provide the same functionality as the
text_to_glyphs callback does (see #cairo_user_scaled_font_text_to_glyphs_func_t)
but has much less control on the output,
in exchange for increased ease of use.  The inherent assumption to using
this callback is that each character maps to one glyph, and that the
mapping is context independent.  It also assumes that glyphs are positioned
according to their advance width.  These mean no ligatures, kerning, or
complex scripts can be implemented using this callback.

The callback is optional, and only used if text_to_glyphs callback is not
set or fails to return glyphs.  If this callback is not set or if it returns
%CAIRO_STATUS_USER_FONT_NOT_IMPLEMENTED, an identity mapping from Unicode
code-points to glyph indices is assumed.

Note: While cairo does not impose any limitation on glyph indices,
some applications may assume that a glyph index fits in a 16-bit
unsigned integer.  As such, it is advised that user-fonts keep their
glyphs in the 0 to 65535 range.  Furthermore, some applications may
assume that glyph 0 is a special glyph-not-found glyph.  User-fonts
are advised to use glyph 0 for such purposes and do not use that
glyph value for other purposes.</doc>
      <source-position filename="cairo.h" line="2017"/>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve"
             filename="cairo.h"
             line="2011">%CAIRO_STATUS_SUCCESS upon success,
%CAIRO_STATUS_USER_FONT_NOT_IMPLEMENTED if fallback options should be tried,
or %CAIRO_STATUS_USER_FONT_ERROR or any other error status on error.</doc>
        <type name="Status" c:type="cairo_status_t"/>
      </return-value>
      <parameters>
        <parameter name="scaled_font" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cairo.h"
               line="1981">the scaled-font being created</doc>
          <type name="ScaledFont" c:type="cairo_scaled_font_t*"/>
        </parameter>
        <parameter name="unicode" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cairo.h"
               line="1982">input unicode character code-point</doc>
          <type name="gulong" c:type="unsigned long"/>
        </parameter>
        <parameter name="glyph_index" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cairo.h"
               line="1983">output glyph index</doc>
          <type name="gulong" c:type="unsigned long*"/>
        </parameter>
      </parameters>
    </callback>
    <function-macro name="VERSION_ENCODE"
                    c:identifier="CAIRO_VERSION_ENCODE"
                    version="1.0"
                    introspectable="0">
      <doc xml:space="preserve"
           filename="cairo-version.c"
           line="179">This macro encodes the given cairo version into an integer.  The numbers
returned by %CAIRO_VERSION and cairo_version() are encoded using this macro.
Two encoded version numbers can be compared as integers.  The encoding ensures
that later versions compare greater than earlier versions.</doc>
      <source-position filename="cairo.h" line="74"/>
      <parameters>
        <parameter name="major">
          <doc xml:space="preserve"
               filename="cairo-version.c"
               line="181">the major component of the version number</doc>
        </parameter>
        <parameter name="minor">
          <doc xml:space="preserve"
               filename="cairo-version.c"
               line="182">the minor component of the version number</doc>
        </parameter>
        <parameter name="micro">
          <doc xml:space="preserve"
               filename="cairo-version.c"
               line="183">the micro component of the version number</doc>
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="VERSION_STRINGIZE"
                    c:identifier="CAIRO_VERSION_STRINGIZE"
                    version="1.8"
                    introspectable="0">
      <doc xml:space="preserve"
           filename="cairo-version.c"
           line="195">This macro encodes the given cairo version into an string.  The numbers
returned by %CAIRO_VERSION_STRING and cairo_version_string() are encoded using this macro.
The parameters to this macro must expand to numerical literals.</doc>
      <source-position filename="cairo.h" line="84"/>
      <parameters>
        <parameter name="major">
          <doc xml:space="preserve"
               filename="cairo-version.c"
               line="197">the major component of the version number</doc>
        </parameter>
        <parameter name="minor">
          <doc xml:space="preserve"
               filename="cairo-version.c"
               line="198">the minor component of the version number</doc>
        </parameter>
        <parameter name="micro">
          <doc xml:space="preserve"
               filename="cairo-version.c"
               line="199">the micro component of the version number</doc>
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="VERSION_STRINGIZE_"
                    c:identifier="CAIRO_VERSION_STRINGIZE_"
                    introspectable="0">
      <source-position filename="cairo.h" line="82"/>
      <parameters>
        <parameter name="major">
        </parameter>
        <parameter name="minor">
        </parameter>
        <parameter name="micro">
        </parameter>
      </parameters>
    </function-macro>
    <callback name="WriteFunc" c:type="cairo_write_func_t" version="1.0">
      <doc xml:space="preserve"
           filename="cairo.h"
           line="476">#cairo_write_func_t is the type of function which is called when a
backend needs to write data to an output stream.  It is passed the
closure which was specified by the user at the time the write
function was registered, the data to write and the length of the
data in bytes.  The write function should return
%CAIRO_STATUS_SUCCESS if all the data was successfully written,
%CAIRO_STATUS_WRITE_ERROR otherwise.</doc>
      <source-position filename="cairo.h" line="494"/>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve"
             filename="cairo.h"
             line="490">the status code of the write operation</doc>
        <type name="Status" c:type="cairo_status_t"/>
      </return-value>
      <parameters>
        <parameter name="closure"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1">
          <doc xml:space="preserve"
               filename="cairo.h"
               line="478">the output closure</doc>
          <type name="gpointer" c:type="void*"/>
        </parameter>
        <parameter name="data" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cairo.h"
               line="479">the buffer containing the data to write</doc>
          <type name="guint8" c:type="const unsigned char*"/>
        </parameter>
        <parameter name="length" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cairo.h"
               line="480">the amount of data to write</doc>
          <type name="guint" c:type="unsigned int"/>
        </parameter>
      </parameters>
    </callback>
    <docsection name="cairo">
      <doc xml:space="preserve"
           filename="cairo.c"
           line="53">#cairo_t is the main object used when drawing with cairo. To
draw with cairo, you create a #cairo_t, set the target surface,
and drawing options for the #cairo_t, create shapes with
functions like cairo_move_to() and cairo_line_to(), and then
draw shapes with cairo_stroke() or cairo_fill().

#cairo_t&lt;!-- --&gt;'s can be pushed to a stack via cairo_save().
They may then safely be changed, without losing the current state.
Use cairo_restore() to restore to the saved state.</doc>
    </docsection>
    <docsection name="cairo-device">
      <doc xml:space="preserve"
           filename="cairo-device.c"
           line="40">Devices are the abstraction Cairo employs for the rendering system
used by a #cairo_surface_t. You can get the device of a surface using
cairo_surface_get_device().

Devices are created using custom functions specific to the rendering
system you want to use. See the documentation for the surface types
for those functions.

An important function that devices fulfill is sharing access to the
rendering system between Cairo and your application. If you want to
access a device directly that you used to draw to with Cairo, you must
first call cairo_device_flush() to ensure that Cairo finishes all
operations on the device and resets it to a clean state.

Cairo also provides the functions cairo_device_acquire() and
cairo_device_release() to synchronize access to the rendering system
in a multithreaded environment. This is done internally, but can also
be used by applications.

Putting this all together, a function that works with devices should
look something like this:
&lt;informalexample&gt;&lt;programlisting&gt;
void
my_device_modifying_function (cairo_device_t *device)
{
  cairo_status_t status;

  // Ensure the device is properly reset
  cairo_device_flush (device);
  // Try to acquire the device
  status = cairo_device_acquire (device);
  if (status != CAIRO_STATUS_SUCCESS) {
    printf ("Failed to acquire the device: %s\n", cairo_status_to_string (status));
    return;
  }

  // Do the custom operations on the device here.
  // But do not call any Cairo functions that might acquire devices.
  
  // Release the device when done.
  cairo_device_release (device);
}
&lt;/programlisting&gt;&lt;/informalexample&gt;

&lt;note&gt;&lt;para&gt;Please refer to the documentation of each backend for
additional usage requirements, guarantees provided, and
interactions with existing surface API of the device functions for
surfaces of that type.
&lt;/para&gt;&lt;/note&gt;</doc>
    </docsection>
    <docsection name="cairo-font-face">
      <doc xml:space="preserve"
           filename="cairo-font-face.c"
           line="44">#cairo_font_face_t represents a particular font at a particular weight,
slant, and other characteristic but no size, transformation, or size.

Font faces are created using &lt;firstterm&gt;font-backend&lt;/firstterm&gt;-specific
constructors, typically of the form
&lt;function&gt;cairo_&lt;emphasis&gt;backend&lt;/emphasis&gt;_font_face_create(&lt;!-- --&gt;)&lt;/function&gt;,
or implicitly using the &lt;firstterm&gt;toy&lt;/firstterm&gt; text API by way of
cairo_select_font_face().  The resulting face can be accessed using
cairo_get_font_face().</doc>
    </docsection>
    <docsection name="cairo-font-options">
      <doc xml:space="preserve"
           filename="cairo-font-options.c"
           line="40">The font options specify how fonts should be rendered.  Most of the
time the font options implied by a surface are just right and do not
need any changes, but for pixel-based targets tweaking font options
may result in superior output on a particular display.</doc>
    </docsection>
    <docsection name="cairo-ft">
      <doc xml:space="preserve"
           filename="cairo-ft-font.c"
           line="142">The FreeType font backend is primarily used to render text on GNU/Linux
systems, but can be used on other platforms too.</doc>
    </docsection>
    <docsection name="cairo-image">
      <doc xml:space="preserve"
           filename="cairo-image-surface.c"
           line="64">Image surfaces provide the ability to render to memory buffers
either allocated by cairo or by the calling code.  The supported
image formats are those defined in #cairo_format_t.</doc>
    </docsection>
    <docsection name="cairo-matrix">
      <doc xml:space="preserve"
           filename="cairo-matrix.c"
           line="43">#cairo_matrix_t is used throughout cairo to convert between different
coordinate spaces.  A #cairo_matrix_t holds an affine transformation,
such as a scale, rotation, shear, or a combination of these.
The transformation of a point (&lt;literal&gt;x&lt;/literal&gt;,&lt;literal&gt;y&lt;/literal&gt;)
is given by:

&lt;programlisting&gt;
x_new = xx * x + xy * y + x0;
y_new = yx * x + yy * y + y0;
&lt;/programlisting&gt;

The current transformation matrix of a #cairo_t, represented as a
#cairo_matrix_t, defines the transformation from user-space
coordinates to device-space coordinates. See cairo_get_matrix() and
cairo_set_matrix().</doc>
    </docsection>
    <docsection name="cairo-paths">
      <doc xml:space="preserve"
           filename="cairo-path.c"
           line="45">Paths are the most basic drawing tools and are primarily used to implicitly
generate simple masks.</doc>
    </docsection>
    <docsection name="cairo-pattern">
      <doc xml:space="preserve"
           filename="cairo-pattern.c"
           line="47">#cairo_pattern_t is the paint with which cairo draws.
The primary use of patterns is as the source for all cairo drawing
operations, although they can also be used as masks, that is, as the
brush too.

A cairo pattern is created by using one of the many constructors,
of the form
&lt;function&gt;cairo_pattern_create_&lt;emphasis&gt;type&lt;/emphasis&gt;()&lt;/function&gt;
or implicitly through
&lt;function&gt;cairo_set_source_&lt;emphasis&gt;type&lt;/emphasis&gt;()&lt;/function&gt;
functions.</doc>
    </docsection>
    <docsection name="cairo-pdf">
      <doc xml:space="preserve"
           filename="cairo-pdf-surface.c"
           line="128">The PDF surface is used to render cairo graphics to Adobe
PDF files and is a multi-page vector surface backend.

The following mime types are supported on source patterns:
%CAIRO_MIME_TYPE_JPEG, %CAIRO_MIME_TYPE_JP2,
%CAIRO_MIME_TYPE_UNIQUE_ID, %CAIRO_MIME_TYPE_JBIG2,
%CAIRO_MIME_TYPE_JBIG2_GLOBAL, %CAIRO_MIME_TYPE_JBIG2_GLOBAL_ID,
%CAIRO_MIME_TYPE_CCITT_FAX, %CAIRO_MIME_TYPE_CCITT_FAX_PARAMS.

# JBIG2 Images #
JBIG2 data in PDF must be in the embedded format as described in
ISO/IEC 11544. Image specific JBIG2 data must be in
%CAIRO_MIME_TYPE_JBIG2.  Any global segments in the JBIG2 data
(segments with page association field set to 0) must be in
%CAIRO_MIME_TYPE_JBIG2_GLOBAL. The global data may be shared by
multiple images. All images sharing the same global data must set
%CAIRO_MIME_TYPE_JBIG2_GLOBAL_ID to a unique identifier. At least
one of the images must provide the global data using
%CAIRO_MIME_TYPE_JBIG2_GLOBAL. The global data will only be
embedded once and shared by all JBIG2 images with the same
%CAIRO_MIME_TYPE_JBIG2_GLOBAL_ID.

# CCITT Fax Images # {#ccitt}
The %CAIRO_MIME_TYPE_CCITT_FAX mime data requires a number of decoding
parameters These parameters are specified using %CAIRO_MIME_TYPE_CCITT_FAX_PARAMS.

%CAIRO_MIME_TYPE_CCITT_FAX_PARAMS mime data must contain a string of the form
"param1=value1 param2=value2 ...".

Columns: [required] An integer specifying the width of the image in pixels.

Rows: [required] An integer specifying the height of the image in scan lines.

K: [optional] An integer identifying the encoding scheme used. &lt; 0
is 2 dimensional Group 4, = 0 is Group3 1 dimensional, &gt; 0 is mixed 1
and 2 dimensional encoding. Default is 0.

EndOfLine: [optional] If true end-of-line bit patterns are present. Default is false.

EncodedByteAlign: [optional] If true the end of line is padded
with 0 bits so the next line begins on a byte boundary. Default is false.

EndOfBlock: [optional] If true the data contains an end-of-block pattern. Default is true.

BlackIs1: [optional] If true 1 bits are black pixels. Default is false.

DamagedRowsBeforeError: [optional] An integer specifying the
number of damages rows tolerated before an error occurs. Default is 0.

Boolean values may be "true" or "false", or 1 or 0.

These parameters are the same as the CCITTFaxDecode parameters in the
[PostScript Language Reference](https://www.adobe.com/products/postscript/pdfs/PLRM.pdf)
and [Portable Document Format (PDF)](https://www.adobe.com/content/dam/Adobe/en/devnet/pdf/pdfs/PDF32000_2008.pdf).
Refer to these documents for further details.

An example %CAIRO_MIME_TYPE_CCITT_FAX_PARAMS string is:

&lt;programlisting&gt;
"Columns=10230 Rows=40000 K=1 EndOfLine=true EncodedByteAlign=1 BlackIs1=false"
&lt;/programlisting&gt;</doc>
    </docsection>
    <docsection name="cairo-png">
      <doc xml:space="preserve"
           filename="cairo-png.c"
           line="49">The PNG functions allow reading PNG images into image surfaces, and writing
any surface to a PNG file.

It is a toy API. It only offers very simple support for reading and
writing PNG files, which is sufficient for testing and
demonstration purposes. Applications which need more control over
the generated PNG file should access the pixel data directly, using
cairo_image_surface_get_data() or a backend-specific access
function, and process it with another library, e.g. gdk-pixbuf or
libpng.</doc>
    </docsection>
    <docsection name="cairo-ps">
      <doc xml:space="preserve"
           filename="cairo-ps-surface.c"
           line="113">The PostScript surface is used to render cairo graphics to Adobe
PostScript files and is a multi-page vector surface backend.

The following mime types are supported on source patterns:
%CAIRO_MIME_TYPE_JPEG, %CAIRO_MIME_TYPE_UNIQUE_ID,
%CAIRO_MIME_TYPE_CCITT_FAX, %CAIRO_MIME_TYPE_CCITT_FAX_PARAMS,
%CAIRO_MIME_TYPE_EPS, %CAIRO_MIME_TYPE_EPS_PARAMS.

Source surfaces used by the PostScript surface that have a
%CAIRO_MIME_TYPE_UNIQUE_ID mime type will be stored in PostScript
printer memory for the duration of the print
job. %CAIRO_MIME_TYPE_UNIQUE_ID should only be used for small
frequently used sources.

The %CAIRO_MIME_TYPE_CCITT_FAX and %CAIRO_MIME_TYPE_CCITT_FAX_PARAMS mime types
are documented in [CCITT Fax Images][ccitt].

# Embedding EPS files # {#eps}

Encapsulated PostScript files can be embedded in the PS output by
setting the CAIRO_MIME_TYPE_EPS mime data on a surface to the EPS
data and painting the surface.  The EPS will be scaled and
translated to the extents of the surface the EPS data is attached
to.

The %CAIRO_MIME_TYPE_EPS mime type requires the
%CAIRO_MIME_TYPE_EPS_PARAMS mime data to also be provided in order
to specify the embeddding parameters.  %CAIRO_MIME_TYPE_EPS_PARAMS
mime data must contain a string of the form "bbox=[llx lly urx
ury]" that specifies the bounding box (in PS coordinates) of the
EPS graphics. The parameters are: lower left x, lower left y, upper
right x, upper right y. Normally the bbox data is identical to the
\%\%\%BoundingBox data in the EPS file.</doc>
    </docsection>
    <docsection name="cairo-quartz">
      <doc xml:space="preserve"
           filename="cairo-quartz-surface.c"
           line="94">The Quartz surface is used to render cairo graphics targeting the
Apple OS X Quartz rendering system.</doc>
    </docsection>
    <docsection name="cairo-quartz-fonts">
      <doc xml:space="preserve"
           filename="cairo-quartz-font.c"
           line="48">Provide support for font faces via Core Text.</doc>
    </docsection>
    <docsection name="cairo-raster-source">
      <doc xml:space="preserve"
           filename="cairo-raster-source-pattern.c"
           line="41">The raster source provides the ability to supply arbitrary pixel data
whilst rendering. The pixels are queried at the time of rasterisation
by means of user callback functions, allowing for the ultimate
flexibility. For example, in handling compressed image sources, you
may keep a MRU cache of decompressed images and decompress sources on the
fly and discard old ones to conserve memory.

For the raster source to be effective, you must at least specify
the acquire and release callbacks which are used to retrieve the pixel
data for the region of interest and demark when it can be freed afterwards.
Other callbacks are provided for when the pattern is copied temporarily
during rasterisation, or more permanently as a snapshot in order to keep
the pixel data available for printing.</doc>
    </docsection>
    <docsection name="cairo-recording">
      <doc xml:space="preserve"
           filename="cairo-recording-surface.c"
           line="40">A recording surface is a surface that records all drawing operations at
the highest level of the surface backend interface, (that is, the
level of paint, mask, stroke, fill, and show_text_glyphs). The recording
surface can then be "replayed" against any target surface by using it
as a source surface.

If you want to replay a surface so that the results in target will be
identical to the results that would have been obtained if the original
operations applied to the recording surface had instead been applied to the
target surface, you can use code like this:
&lt;informalexample&gt;&lt;programlisting&gt;
cairo_t *cr;

cr = cairo_create (target);
cairo_set_source_surface (cr, recording_surface, 0.0, 0.0);
cairo_paint (cr);
cairo_destroy (cr);
&lt;/programlisting&gt;&lt;/informalexample&gt;

A recording surface is logically unbounded, i.e. it has no implicit constraint
on the size of the drawing surface. However, in practice this is rarely
useful as you wish to replay against a particular target surface with
known bounds. For this case, it is more efficient to specify the target
extents to the recording surface upon creation.

The recording phase of the recording surface is careful to snapshot all
necessary objects (paths, patterns, etc.), in order to achieve
accurate replay. The efficiency of the recording surface could be
improved by improving the implementation of snapshot for the
various objects. For example, it would be nice to have a
copy-on-write implementation for _cairo_surface_snapshot.</doc>
    </docsection>
    <docsection name="cairo-region">
      <doc xml:space="preserve"
           filename="cairo-region.c"
           line="47">Regions are a simple graphical data type representing an area of
integer-aligned rectangles. They are often used on raster surfaces
to track areas of interest, such as change or clip areas.</doc>
    </docsection>
    <docsection name="cairo-scaled-font">
      <doc xml:space="preserve"
           filename="cairo-scaled-font.c"
           line="50">#cairo_scaled_font_t represents a realization of a font face at a particular
size and transformation and a certain set of font options.</doc>
    </docsection>
    <docsection name="cairo-script">
      <doc xml:space="preserve"
           filename="cairo-script-surface.c"
           line="45">The script surface provides the ability to render to a native
script that matches the cairo drawing model. The scripts can
be replayed using tools under the util/cairo-script directory,
or with cairo-perf-trace.</doc>
    </docsection>
    <docsection name="cairo-status">
      <doc xml:space="preserve"
           filename="cairo-misc.c"
           line="55">Cairo uses a single status type to represent all kinds of errors.  A status
value of %CAIRO_STATUS_SUCCESS represents no error and has an integer value
of zero.  All other status values represent an error.

Cairo's error handling is designed to be easy to use and safe.  All major
cairo objects &lt;firstterm&gt;retain&lt;/firstterm&gt; an error status internally which
can be queried anytime by the users using cairo*_status() calls.  In
the mean time, it is safe to call all cairo functions normally even if the
underlying object is in an error status.  This means that no error handling
code is required before or after each individual cairo function call.</doc>
    </docsection>
    <docsection name="cairo-surface">
      <doc xml:space="preserve"
           filename="cairo-surface.c"
           line="53">#cairo_surface_t is the abstract type representing all different drawing
targets that cairo can render to.  The actual drawings are
performed using a cairo &lt;firstterm&gt;context&lt;/firstterm&gt;.

A cairo surface is created by using &lt;firstterm&gt;backend&lt;/firstterm&gt;-specific
constructors, typically of the form
&lt;function&gt;cairo_&lt;emphasis&gt;backend&lt;/emphasis&gt;_surface_create(&lt;!-- --&gt;)&lt;/function&gt;.

Most surface types allow accessing the surface without using Cairo
functions. If you do this, keep in mind that it is mandatory that you call
cairo_surface_flush() before reading from or writing to the surface and that
you must use cairo_surface_mark_dirty() after modifying it.
&lt;example&gt;
&lt;title&gt;Directly modifying an image surface&lt;/title&gt;
&lt;programlisting&gt;
void
modify_image_surface (cairo_surface_t *surface)
{
  unsigned char *data;
  int width, height, stride;

  // flush to ensure all writing to the image was done
  cairo_surface_flush (surface);

  // modify the image
  data = cairo_image_surface_get_data (surface);
  width = cairo_image_surface_get_width (surface);
  height = cairo_image_surface_get_height (surface);
  stride = cairo_image_surface_get_stride (surface);
  modify_image_data (data, width, height, stride);

  // mark the image dirty so Cairo clears its caches.
  cairo_surface_mark_dirty (surface);
}
&lt;/programlisting&gt;
&lt;/example&gt;
Note that for other surface types it might be necessary to acquire the
surface's device first. See cairo_device_acquire() for a discussion of
devices.</doc>
    </docsection>
    <docsection name="cairo-surface-observer">
      <doc xml:space="preserve"
           filename="cairo-surface-observer.c"
           line="57">A surface that exists solely to watch what another surface is doing.</doc>
    </docsection>
    <docsection name="cairo-svg">
      <doc xml:space="preserve"
           filename="cairo-svg-surface.c"
           line="61">The SVG surface is used to render cairo graphics to
SVG files and is a multi-page vector surface backend.</doc>
    </docsection>
    <docsection name="cairo-tag">
      <doc xml:space="preserve"
           filename="cairo.c"
           line="110">The tag functions provide the ability to specify hyperlinks and
document logical structure on supported backends. The following tags are supported:
* [Link][link] - Create a hyperlink
* [Destinations][dest] - Create a hyperlink destination
* [Document Structure Tags][doc-struct] - Create PDF Document Structure

# Link Tags # {#link}
A hyperlink is specified by enclosing the hyperlink text with the %CAIRO_TAG_LINK tag.

For example:
&lt;informalexample&gt;&lt;programlisting&gt;
cairo_tag_begin (cr, CAIRO_TAG_LINK, "uri='https://cairographics.org'");
cairo_move_to (cr, 50, 50);
cairo_show_text (cr, "This is a link to the cairo website.");
cairo_tag_end (cr, CAIRO_TAG_LINK);
&lt;/programlisting&gt;&lt;/informalexample&gt;

The PDF backend uses one or more rectangles to define the clickable
area of the link.  By default cairo will use the extents of the
drawing operations enclosed by the begin/end link tags to define the
clickable area. In some cases, such as a link split across two
lines, the default rectangle is undesirable.

rect: [optional] The "rect" attribute allows the application to
specify one or more rectangles that form the clickable region.  The
value of this attribute is an array of floats. Each rectangle is
specified by four elements in the array: x, y, width, height. The
array size must be a multiple of four.

An example of creating a link with user specified clickable region:
&lt;informalexample&gt;&lt;programlisting&gt;
struct text {
    const char *s;
    double x, y;
};
const struct text text1 = { "This link is split", 450, 70 };
const struct text text2 = { "across two lines", 50, 70 };
cairo_text_extents_t text1_extents;
cairo_text_extents_t text2_extents;
char attribs[100];

cairo_text_extents (cr, text1.s, &amp;text1_extents);
cairo_text_extents (cr, text2.s, &amp;text2_extents);
sprintf (attribs,
         "rect=[%f %f %f %f %f %f %f %f] uri='https://cairographics.org'",
         text1_extents.x_bearing + text1.x,
         text1_extents.y_bearing + text1.y,
         text1_extents.width,
         text1_extents.height,
         text2_extents.x_bearing + text2.x,
         text2_extents.y_bearing + text2.y,
         text2_extents.width,
         text2_extents.height);

cairo_tag_begin (cr, CAIRO_TAG_LINK, attribs);
cairo_move_to (cr, text1.x, text1.y);
cairo_show_text (cr, text1.s);
cairo_move_to (cr, text2.x, text2.y);
cairo_show_text (cr, text2.s);
cairo_tag_end (cr, CAIRO_TAG_LINK);
&lt;/programlisting&gt;&lt;/informalexample&gt;

There are three types of links. Each type has its own attributes as detailed below.
* [Internal Links][internal-link] - A link to a location in the same document
* [URI Links][uri-link] - A link to a Uniform resource identifier
* [File Links][file-link] - A link to a location in another document

## Internal Links ## {#internal-link}
An internal link is a link to a location in the same document. The destination
is specified with either:

dest: a UTF-8 string specifying the destination in the PDF file to link
to. Destinations are created with the %CAIRO_TAG_DEST tag.

or the two attributes:

page: An integer specifying the page number in the PDF file to link to.

pos: [optional] An array of two floats specifying the x,y position
on the page.

An example of the link attributes to link to a page and x,y position:
&lt;programlisting&gt;
"page=3 pos=[3.1 6.2]"
&lt;/programlisting&gt;

## URI Links ## {#uri-link}
A URI link is a link to a Uniform Resource Identifier ([RFC 2396](http://tools.ietf.org/html/rfc2396)).

A URI is specified with the following attribute:

uri: An ASCII string specifying the URI.

An example of the link attributes to the cairo website:
&lt;programlisting&gt;
"uri='https://cairographics.org'"
&lt;/programlisting&gt;

## File Links ## {#file-link}
A file link is a link a location in another PDF file.

The file attribute (required) specifies the name of the PDF file:

file: File name of PDF file to link to.

The position is specified by either:

 dest: a UTF-8 string specifying the named destination in the PDF file.

or

 page: An integer specifying the page number in the PDF file.

 pos: [optional] An array of two floats specifying the x,y
 position on the page. Position coordinates in external files are in PDF
 coordinates (0,0 at bottom left).

An example of the link attributes to PDF file:
&lt;programlisting&gt;
"file='document.pdf' page=16 pos=[25 40]"
&lt;/programlisting&gt;

# Destination Tags # {#dest}

A destination is specified by enclosing the destination drawing
operations with the %CAIRO_TAG_DEST tag.

name: [required] A UTF-8 string specifying the name of this destination.

x: [optional] A float specifying the x coordinate of destination
                position on this page. If not specified the default
                x coordinate is the left side of the extents of the
                operations enclosed by the %CAIRO_TAG_DEST begin/end tags. If
                no operations are enclosed, the x coordidate is 0.

y: [optional] A float specifying the y coordinate of destination
                position on this page. If not specified the default
                y coordinate is the top of the extents of the
                operations enclosed by the %CAIRO_TAG_DEST begin/end tags. If
                no operations are enclosed, the y coordidate is 0.

internal: A boolean that if true, the destination name may be
           omitted from PDF where possible. In this case, links
           refer directly to the page and position instead of via
           the named destination table. Note that if this
           destination is referenced by another PDF (see [File Links][file-link]),
           this attribute must be false. Default is false.

&lt;informalexample&gt;&lt;programlisting&gt;
/&amp;ast; Create a hyperlink &amp;ast;/
cairo_tag_begin (cr, CAIRO_TAG_LINK, "dest='mydest' internal");
cairo_move_to (cr, 50, 50);
cairo_show_text (cr, "This is a hyperlink.");
cairo_tag_end (cr, CAIRO_TAG_LINK);

/&amp;ast; Create a destination &amp;ast;/
cairo_tag_begin (cr, CAIRO_TAG_DEST, "name='mydest'");
cairo_move_to (cr, 50, 250);
cairo_show_text (cr, "This paragraph is the destination of the above link.");
cairo_tag_end (cr, CAIRO_TAG_DEST);
&lt;/programlisting&gt;&lt;/informalexample&gt;

# Document Structure (PDF) # {#doc-struct}

The document structure tags provide a means of specifying structural information
such as headers, paragraphs, tables, and figures. The inclusion of structural information facilitates:
* Extraction of text and graphics for copy and paste
* Reflow of text and graphics in the viewer
* Processing text eg searching and indexing
* Conversion to other formats
* Accessability support

The list of structure types is specified in section 14.8.4 of the
[PDF Reference](http://www.adobe.com/content/dam/Adobe/en/devnet/acrobat/pdfs/PDF32000_2008.pdf).

Note the PDF "Link" structure tag is the same as the cairo %CAIRO_TAG_LINK tag.

The following example creates a document structure for a document containing two section, each with
a header and a paragraph.

&lt;informalexample&gt;&lt;programlisting&gt;
cairo_tag_begin (cr, "Document", NULL);

cairo_tag_begin (cr, "Sect", NULL);
cairo_tag_begin (cr, "H1", NULL);
cairo_show_text (cr, "Heading 1");
cairo_tag_end (cr, "H1");

cairo_tag_begin (cr, "P", NULL);
cairo_show_text (cr, "Paragraph 1");
cairo_tag_end (cr, "P");
cairo_tag_end (cr, "Sect");

cairo_tag_begin (cr, "Sect", NULL);
cairo_tag_begin (cr, "H1", NULL);
cairo_show_text (cr, "Heading 2");
cairo_tag_end (cr, "H1");

cairo_tag_begin (cr, "P", NULL);
cairo_show_text (cr, "Paragraph 2");
cairo_tag_end (cr, "P");
cairo_tag_end (cr, "Sect");

cairo_tag_end (cr, "Document");
&lt;/programlisting&gt;&lt;/informalexample&gt;</doc>
    </docsection>
    <docsection name="cairo-tee">
      <doc xml:space="preserve"
           filename="cairo-tee-surface.c"
           line="38">The "tee" surface supports redirecting all its input to multiple surfaces.</doc>
    </docsection>
    <docsection name="cairo-text">
      <doc xml:space="preserve"
           filename="cairo.c"
           line="70">The functions with &lt;emphasis&gt;text&lt;/emphasis&gt; in their name form cairo's
&lt;firstterm&gt;toy&lt;/firstterm&gt; text API.  The toy API takes UTF-8 encoded
text and is limited in its functionality to rendering simple
left-to-right text with no advanced features.  That means for example
that most complex scripts like Hebrew, Arabic, and Indic scripts are
out of question.  No kerning or correct positioning of diacritical marks
either.  The font selection is pretty limited too and doesn't handle the
case that the selected font does not cover the characters in the text.
This set of functions are really that, a toy text API, for testing and
demonstration purposes.  Any serious application should avoid them.

The functions with &lt;emphasis&gt;glyphs&lt;/emphasis&gt; in their name form cairo's
&lt;firstterm&gt;low-level&lt;/firstterm&gt; text API.  The low-level API relies on
the user to convert text to a set of glyph indexes and positions.  This
is a very hard problem and is best handled by external libraries, like
the pangocairo that is part of the Pango text layout and rendering library.
Pango is available from &lt;ulink
url="http://www.pango.org/"&gt;http://www.pango.org/&lt;/ulink&gt;.</doc>
    </docsection>
    <docsection name="cairo-transforms">
      <doc xml:space="preserve"
           filename="cairo.c"
           line="97">The current transformation matrix, &lt;firstterm&gt;ctm&lt;/firstterm&gt;, is a
two-dimensional affine transformation that maps all coordinates and other
drawing instruments from the &lt;firstterm&gt;user space&lt;/firstterm&gt; into the
surface's canonical coordinate system, also known as the &lt;firstterm&gt;device
space&lt;/firstterm&gt;.</doc>
    </docsection>
    <docsection name="cairo-user-fonts">
      <doc xml:space="preserve"
           filename="cairo-user-font.c"
           line="44">The user-font feature allows the cairo user to provide drawings for glyphs
in a font.  This is most useful in implementing fonts in non-standard
formats, like SVG fonts and Flash fonts, but can also be used by games and
other application to draw "funky" fonts.</doc>
    </docsection>
    <docsection name="cairo-version">
      <doc xml:space="preserve"
           filename="cairo-version.c"
           line="41">Cairo has a three-part version number scheme. In this scheme, we use
even vs. odd numbers to distinguish fixed points in the software
vs. in-progress development, (such as from git instead of a tar file,
or as a "snapshot" tar file as opposed to a "release" tar file).

&lt;informalexample&gt;&lt;screen&gt;
 _____ Major. Always 1, until we invent a new scheme.
/  ___ Minor. Even/Odd = Release/Snapshot (tar files) or Branch/Head (git)
| /  _ Micro. Even/Odd = Tar-file/git
| | /
1.0.0
&lt;/screen&gt;&lt;/informalexample&gt;

Here are a few examples of versions that one might see.
&lt;informalexample&gt;&lt;screen&gt;
Releases
--------
1.0.0 - A major release
1.0.2 - A subsequent maintenance release
1.2.0 - Another major release
&amp;nbsp;
Snapshots
---------
1.1.2 - A snapshot (working toward the 1.2.0 release)
&amp;nbsp;
In-progress development (eg. from git)
--------------------------------------
1.0.1 - Development on a maintenance branch (toward 1.0.2 release)
1.1.1 - Development on head (toward 1.1.2 snapshot and 1.2.0 release)
&lt;/screen&gt;&lt;/informalexample&gt;

&lt;refsect2&gt;
&lt;title&gt;Compatibility&lt;/title&gt;

The API/ABI compatibility guarantees for various versions are as
follows. First, let's assume some cairo-using application code that is
successfully using the API/ABI "from" one version of cairo. Then let's
ask the question whether this same code can be moved "to" the API/ABI
of another version of cairo.

Moving from a release to any later version (release, snapshot,
development) is always guaranteed to provide compatibility.

Moving from a snapshot to any later version is not guaranteed to
provide compatibility, since snapshots may introduce new API that ends
up being removed before the next release.

Moving from an in-development version (odd micro component) to any
later version is not guaranteed to provide compatibility. In fact,
there's not even a guarantee that the code will even continue to work
with the same in-development version number. This is because these
numbers don't correspond to any fixed state of the software, but
rather the many states between snapshots and releases.

&lt;/refsect2&gt;
&lt;refsect2&gt;
&lt;title&gt;Examining the version&lt;/title&gt;

Cairo provides the ability to examine the version at either
compile-time or run-time and in both a human-readable form as well as
an encoded form suitable for direct comparison. Cairo also provides the
macro CAIRO_VERSION_ENCODE() to perform the encoding.

&lt;informalexample&gt;&lt;screen&gt;
Compile-time
------------
#CAIRO_VERSION_STRING   Human-readable
#CAIRO_VERSION          Encoded, suitable for comparison
&amp;nbsp;
Run-time
--------
cairo_version_string()  Human-readable
cairo_version()         Encoded, suitable for comparison
&lt;/screen&gt;&lt;/informalexample&gt;

For example, checking that the cairo version is greater than or equal
to 1.0.0 could be achieved at compile-time or run-time as follows:

&lt;informalexample&gt;&lt;programlisting&gt;
##if CAIRO_VERSION &gt;= CAIRO_VERSION_ENCODE(1, 0, 0)
printf ("Compiling with suitable cairo version: %s\n", %CAIRO_VERSION_STRING);
##endif

if (cairo_version() &gt;= CAIRO_VERSION_ENCODE(1, 0, 0))
    printf ("Running with suitable cairo version: %s\n", cairo_version_string ());
&lt;/programlisting&gt;&lt;/informalexample&gt;

&lt;/refsect2&gt;</doc>
    </docsection>
    <docsection name="cairo-xcb">
      <doc xml:space="preserve"
           filename="cairo-xcb-surface.c"
           line="53">The XCB surface is used to render cairo graphics to X Window System
windows and pixmaps using the XCB library.

Note that the XCB surface automatically takes advantage of the X render
extension if it is available.</doc>
    </docsection>
    <docsection name="cairo-xlib">
      <doc xml:space="preserve"
           filename="cairo-xlib-surface.c"
           line="131">The XLib surface is used to render cairo graphics to X Window System
windows and pixmaps using the XLib library.

Note that the XLib surface automatically takes advantage of X render extension
if it is available.</doc>
    </docsection>
    <docsection name="cairo-xlib-xrender">
      <doc xml:space="preserve"
           filename="cairo-xlib-surface.c"
           line="153">The XLib surface is used to render cairo graphics to X Window System
windows and pixmaps using the XLib and Xrender libraries.

Note that the XLib surface automatically takes advantage of X Render extension
if it is available.</doc>
    </docsection>
    <function name="create" c:identifier="cairo_create" version="1.0">
      <doc xml:space="preserve"
           filename="cairo.c"
           line="417">Creates a new #cairo_t with all graphics state parameters set to
default values and with @target as a target surface. The target
surface should be constructed with a backend-specific function such
as cairo_image_surface_create() (or any other
&lt;function&gt;cairo_&lt;emphasis&gt;backend&lt;/emphasis&gt;_surface_create(&lt;!-- --&gt;)&lt;/function&gt;
variant).

This function references @target, so you can immediately
call cairo_surface_destroy() on it if you don't need to
maintain a separate reference to it.</doc>
      <source-position filename="cairo.h" line="540"/>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve"
             filename="cairo.c"
             line="432">a newly allocated #cairo_t with a reference
 count of 1. The initial reference count should be released
 with cairo_destroy() when you are done using the #cairo_t.
 This function never returns %NULL. If memory cannot be
 allocated, a special #cairo_t object will be returned on
 which cairo_status() returns %CAIRO_STATUS_NO_MEMORY. If
 you attempt to target a surface which does not support
 writing (such as #cairo_mime_surface_t) then a
 %CAIRO_STATUS_WRITE_ERROR will be raised.  You can use this
 object normally, but no drawing will be done.</doc>
        <type name="Context" c:type="cairo_t*"/>
      </return-value>
      <parameters>
        <parameter name="target" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cairo.c"
               line="419">target surface for the context</doc>
          <type name="Surface" c:type="cairo_surface_t*"/>
        </parameter>
      </parameters>
    </function>
    <function name="debug_reset_static_data"
              c:identifier="cairo_debug_reset_static_data"
              version="1.0">
      <doc xml:space="preserve"
           filename="cairo-debug.c"
           line="39">Resets all static data within cairo to its original state,
(ie. identical to the state at the time of program invocation). For
example, all caches within cairo will be flushed empty.

This function is intended to be useful when using memory-checking
tools such as valgrind. When valgrind's memcheck analyzes a
cairo-using program without a call to cairo_debug_reset_static_data(),
it will report all data reachable via cairo's static objects as
"still reachable". Calling cairo_debug_reset_static_data() just prior
to program termination will make it easier to get squeaky clean
reports from valgrind.

WARNING: It is only safe to call this function when there are no
active cairo objects remaining, (ie. the appropriate destroy
functions have been called as necessary). If there are active cairo
objects, this call is likely to cause a crash, (eg. an assertion
failure due to a hash table being destroyed when non-empty).</doc>
      <source-position filename="cairo.h" line="3337"/>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
    </function>
    <function name="destroy"
              c:identifier="cairo_destroy"
              version="1.0"
              introspectable="0">
      <doc xml:space="preserve"
           filename="cairo.c"
           line="507">Decreases the reference count on @cr by one. If the result
is zero, then @cr and all associated resources are freed.
See cairo_reference().</doc>
      <source-position filename="cairo.h" line="546"/>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="cr" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cairo.c"
               line="509">a #cairo_t</doc>
          <type name="Context" c:type="cairo_t*"/>
        </parameter>
      </parameters>
    </function>
    <function name="font_options_create"
              c:identifier="cairo_font_options_create"
              version="1.0">
      <doc xml:space="preserve"
           filename="cairo-font-options.c"
           line="143">Allocates a new font options object with all options initialized
 to default values.</doc>
      <source-position filename="cairo.h" line="1459"/>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve"
             filename="cairo-font-options.c"
             line="149">a newly allocated #cairo_font_options_t. Free with
  cairo_font_options_destroy(). This function always returns a
  valid pointer; if memory cannot be allocated, then a special
  error object is returned where all operations on the object do nothing.
  You can check for this with cairo_font_options_status().</doc>
        <type name="FontOptions" c:type="cairo_font_options_t*"/>
      </return-value>
    </function>
    <function name="format_stride_for_width"
              c:identifier="cairo_format_stride_for_width"
              version="1.6">
      <doc xml:space="preserve"
           filename="cairo-image-surface.c"
           line="439">This function provides a stride value that will respect all
alignment requirements of the accelerated image-rendering code
within cairo. Typical usage will be of the form:

&lt;informalexample&gt;&lt;programlisting&gt;
int stride;
unsigned char *data;
cairo_surface_t *surface;

stride = cairo_format_stride_for_width (format, width);
data = malloc (stride * height);
surface = cairo_image_surface_create_for_data (data, format,
					  width, height,
					  stride);
&lt;/programlisting&gt;&lt;/informalexample&gt;</doc>
      <source-position filename="cairo.h" line="2709"/>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve"
             filename="cairo-image-surface.c"
             line="460">the appropriate stride to use given the desired
format and width, or -1 if either the format is invalid or the width
too large.</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="format" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cairo-image-surface.c"
               line="441">A #cairo_format_t value</doc>
          <type name="Format" c:type="cairo_format_t"/>
        </parameter>
        <parameter name="width" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cairo-image-surface.c"
               line="442">The desired width of an image surface to be created.</doc>
          <type name="gint" c:type="int"/>
        </parameter>
      </parameters>
    </function>
    <function name="get_reference_count"
              c:identifier="cairo_get_reference_count"
              version="1.4"
              introspectable="0">
      <doc xml:space="preserve"
           filename="cairo.c"
           line="583">Returns the current reference count of @cr.</doc>
      <source-position filename="cairo.h" line="549"/>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve"
             filename="cairo.c"
             line="589">the current reference count of @cr.  If the
object is a nil object, 0 will be returned.</doc>
        <type name="guint" c:type="unsigned int"/>
      </return-value>
      <parameters>
        <parameter name="cr" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cairo.c"
               line="585">a #cairo_t</doc>
          <type name="Context" c:type="cairo_t*"/>
        </parameter>
      </parameters>
    </function>
    <function name="get_user_data"
              c:identifier="cairo_get_user_data"
              version="1.4">
      <doc xml:space="preserve"
           filename="cairo.c"
           line="531">Return user data previously attached to @cr using the specified
key.  If no user data has been attached with the given key this
function returns %NULL.</doc>
      <source-position filename="cairo.h" line="552"/>
      <return-value transfer-ownership="none" nullable="1">
        <doc xml:space="preserve"
             filename="cairo.c"
             line="541">the user data previously attached or %NULL.</doc>
        <type name="gpointer" c:type="void*"/>
      </return-value>
      <parameters>
        <parameter name="cr" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cairo.c"
               line="533">a #cairo_t</doc>
          <type name="Context" c:type="cairo_t*"/>
        </parameter>
        <parameter name="key" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cairo.c"
               line="534">the address of the #cairo_user_data_key_t the user data was
attached to</doc>
          <type name="UserDataKey" c:type="const cairo_user_data_key_t*"/>
        </parameter>
      </parameters>
    </function>
    <function name="glyph_allocate"
              c:identifier="cairo_glyph_allocate"
              version="1.8">
      <doc xml:space="preserve"
           filename="cairo-misc.c"
           line="187">Allocates an array of #cairo_glyph_t's.
This function is only useful in implementations of
#cairo_user_scaled_font_text_to_glyphs_func_t where the user
needs to allocate an array of glyphs that cairo will free.
For all other uses, user can use their own allocation method
for glyphs.

This function returns %NULL if @num_glyphs is not positive,
or if out of memory.  That means, the %NULL return value
signals out-of-memory only if @num_glyphs was positive.</doc>
      <source-position filename="cairo.h" line="1163"/>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve"
             filename="cairo-misc.c"
             line="202">the newly allocated array of glyphs that should be
         freed using cairo_glyph_free()</doc>
        <type name="Glyph" c:type="cairo_glyph_t*"/>
      </return-value>
      <parameters>
        <parameter name="num_glyphs" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cairo-misc.c"
               line="189">number of glyphs to allocate</doc>
          <type name="gint" c:type="int"/>
        </parameter>
      </parameters>
    </function>
    <function name="image_surface_create"
              c:identifier="cairo_image_surface_create"
              version="1.0">
      <doc xml:space="preserve"
           filename="cairo-image-surface.c"
           line="392">Creates an image surface of the specified format and
dimensions. Initially the surface contents are set to 0.
(Specifically, within each pixel, each color or alpha channel
belonging to format will be 0. The contents of bits within a pixel,
but not belonging to the given format are undefined).</doc>
      <source-position filename="cairo.h" line="2704"/>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve"
             filename="cairo-image-surface.c"
             line="404">a pointer to the newly created surface. The caller
owns the surface and should call cairo_surface_destroy() when done
with it.

This function always returns a valid pointer, but it will return a
pointer to a "nil" surface if an error such as out of memory
occurs. You can use cairo_surface_status() to check for this.</doc>
        <type name="Surface" c:type="cairo_surface_t*"/>
      </return-value>
      <parameters>
        <parameter name="format" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cairo-image-surface.c"
               line="394">format of pixels in the surface to create</doc>
          <type name="Format" c:type="cairo_format_t"/>
        </parameter>
        <parameter name="width" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cairo-image-surface.c"
               line="395">width of the surface, in pixels</doc>
          <type name="gint" c:type="int"/>
        </parameter>
        <parameter name="height" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cairo-image-surface.c"
               line="396">height of the surface, in pixels</doc>
          <type name="gint" c:type="int"/>
        </parameter>
      </parameters>
    </function>
    <function name="image_surface_create_for_data"
              c:identifier="cairo_image_surface_create_for_data"
              version="1.0">
      <doc xml:space="preserve"
           filename="cairo-image-surface.c"
           line="484">Creates an image surface for the provided pixel data. The output
buffer must be kept around until the #cairo_surface_t is destroyed
or cairo_surface_finish() is called on the surface.  The initial
contents of @data will be used as the initial image contents; you
must explicitly clear the buffer, using, for example,
cairo_rectangle() and cairo_fill() if you want it cleared.

Note that the stride may be larger than
width*bytes_per_pixel to provide proper alignment for each pixel
and row. This alignment is required to allow high-performance rendering
within cairo. The correct way to obtain a legal stride value is to
call cairo_format_stride_for_width() with the desired format and
maximum image width value, and then use the resulting stride value
to allocate the data and to create the image surface. See
cairo_format_stride_for_width() for example code.</doc>
      <source-position filename="cairo.h" line="2713"/>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve"
             filename="cairo-image-surface.c"
             line="513">a pointer to the newly created surface. The caller
owns the surface and should call cairo_surface_destroy() when done
with it.

This function always returns a valid pointer, but it will return a
pointer to a "nil" surface in the case of an error such as out of
memory or an invalid stride value. In case of invalid stride value
the error status of the returned surface will be
%CAIRO_STATUS_INVALID_STRIDE.  You can use
cairo_surface_status() to check for this.

See cairo_surface_set_user_data() for a means of attaching a
destroy-notification fallback to the surface if necessary.</doc>
        <type name="Surface" c:type="cairo_surface_t*"/>
      </return-value>
      <parameters>
        <parameter name="data" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cairo-image-surface.c"
               line="486">a pointer to a buffer supplied by the application in which
    to write contents. This pointer must be suitably aligned for any
    kind of variable, (for example, a pointer returned by malloc).</doc>
          <type name="guint8" c:type="unsigned char*"/>
        </parameter>
        <parameter name="format" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cairo-image-surface.c"
               line="489">the format of pixels in the buffer</doc>
          <type name="Format" c:type="cairo_format_t"/>
        </parameter>
        <parameter name="width" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cairo-image-surface.c"
               line="490">the width of the image to be stored in the buffer</doc>
          <type name="gint" c:type="int"/>
        </parameter>
        <parameter name="height" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cairo-image-surface.c"
               line="491">the height of the image to be stored in the buffer</doc>
          <type name="gint" c:type="int"/>
        </parameter>
        <parameter name="stride" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cairo-image-surface.c"
               line="492">the number of bytes between the start of rows in the
    buffer as allocated. This value should always be computed by
    cairo_format_stride_for_width() before allocating the data
    buffer.</doc>
          <type name="gint" c:type="int"/>
        </parameter>
      </parameters>
    </function>
    <function name="image_surface_create_from_png"
              c:identifier="cairo_image_surface_create_from_png"
              version="1.0">
      <doc xml:space="preserve"
           filename="cairo-png.c"
           line="894">Creates a new image surface and initializes the contents to the
given PNG file.</doc>
      <source-position filename="cairo.h" line="2737"/>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve"
             filename="cairo-png.c"
             line="902">a new #cairo_surface_t initialized with the contents
of the PNG file, or a "nil" surface if any error occurred. A nil
surface can be checked for with cairo_surface_status(surface) which
may return one of the following values:

%CAIRO_STATUS_NO_MEMORY
%CAIRO_STATUS_FILE_NOT_FOUND
%CAIRO_STATUS_READ_ERROR
%CAIRO_STATUS_PNG_ERROR

Alternatively, you can allow errors to propagate through the drawing
operations and check the status on the context upon completion
using cairo_status().</doc>
        <type name="Surface" c:type="cairo_surface_t*"/>
      </return-value>
      <parameters>
        <parameter name="filename" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cairo-png.c"
               line="896">name of PNG file to load. On Windows this filename
  is encoded in UTF-8.</doc>
          <type name="utf8" c:type="const char*"/>
        </parameter>
      </parameters>
    </function>
    <function name="image_surface_create_from_png_stream"
              c:identifier="cairo_image_surface_create_from_png_stream"
              version="1.0">
      <doc xml:space="preserve"
           filename="cairo-png.c"
           line="954">Creates a new image surface from PNG data read incrementally
via the @read_func function.</doc>
      <source-position filename="cairo.h" line="2740"/>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve"
             filename="cairo-png.c"
             line="962">a new #cairo_surface_t initialized with the contents
of the PNG file or a "nil" surface if the data read is not a valid PNG image
or memory could not be allocated for the operation.  A nil
surface can be checked for with cairo_surface_status(surface) which
may return one of the following values:

%CAIRO_STATUS_NO_MEMORY
%CAIRO_STATUS_READ_ERROR
%CAIRO_STATUS_PNG_ERROR

Alternatively, you can allow errors to propagate through the drawing
operations and check the status on the context upon completion
using cairo_status().</doc>
        <type name="Surface" c:type="cairo_surface_t*"/>
      </return-value>
      <parameters>
        <parameter name="read_func" transfer-ownership="none" scope="call">
          <doc xml:space="preserve"
               filename="cairo-png.c"
               line="956">function called to read the data of the file</doc>
          <type name="ReadFunc" c:type="cairo_read_func_t"/>
        </parameter>
        <parameter name="closure"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1">
          <doc xml:space="preserve"
               filename="cairo-png.c"
               line="957">data to pass to @read_func.</doc>
          <type name="gpointer" c:type="void*"/>
        </parameter>
      </parameters>
    </function>
    <function name="image_surface_get_data"
              c:identifier="cairo_image_surface_get_data"
              version="1.2">
      <doc xml:space="preserve"
           filename="cairo-image-surface.c"
           line="566">Get a pointer to the data of the image surface, for direct
inspection or modification.

A call to cairo_surface_flush() is required before accessing the
pixel data to ensure that all pending drawing operations are
finished. A call to cairo_surface_mark_dirty() is required after
the data is modified.</doc>
      <source-position filename="cairo.h" line="2720"/>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve"
             filename="cairo-image-surface.c"
             line="578">a pointer to the image data of this surface or %NULL
if @surface is not an image surface, or if cairo_surface_finish()
has been called.</doc>
        <type name="guint8" c:type="unsigned char*"/>
      </return-value>
      <parameters>
        <parameter name="surface" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cairo-image-surface.c"
               line="568">a #cairo_image_surface_t</doc>
          <type name="Surface" c:type="cairo_surface_t*"/>
        </parameter>
      </parameters>
    </function>
    <function name="image_surface_get_format"
              c:identifier="cairo_image_surface_get_format"
              version="1.2">
      <doc xml:space="preserve"
           filename="cairo-image-surface.c"
           line="597">Get the format of the surface.</doc>
      <source-position filename="cairo.h" line="2723"/>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve"
             filename="cairo-image-surface.c"
             line="603">the format of the surface</doc>
        <type name="Format" c:type="cairo_format_t"/>
      </return-value>
      <parameters>
        <parameter name="surface" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cairo-image-surface.c"
               line="599">a #cairo_image_surface_t</doc>
          <type name="Surface" c:type="cairo_surface_t*"/>
        </parameter>
      </parameters>
    </function>
    <function name="image_surface_get_height"
              c:identifier="cairo_image_surface_get_height"
              version="1.0">
      <doc xml:space="preserve"
           filename="cairo-image-surface.c"
           line="643">Get the height of the image surface in pixels.</doc>
      <source-position filename="cairo.h" line="2729"/>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve"
             filename="cairo-image-surface.c"
             line="649">the height of the surface in pixels.</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="surface" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cairo-image-surface.c"
               line="645">a #cairo_image_surface_t</doc>
          <type name="Surface" c:type="cairo_surface_t*"/>
        </parameter>
      </parameters>
    </function>
    <function name="image_surface_get_stride"
              c:identifier="cairo_image_surface_get_stride"
              version="1.2">
      <doc xml:space="preserve"
           filename="cairo-image-surface.c"
           line="666">Get the stride of the image surface in bytes</doc>
      <source-position filename="cairo.h" line="2732"/>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve"
             filename="cairo-image-surface.c"
             line="672">the stride of the image surface in bytes (or 0 if
@surface is not an image surface). The stride is the distance in
bytes from the beginning of one row of the image data to the
beginning of the next row.</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="surface" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cairo-image-surface.c"
               line="668">a #cairo_image_surface_t</doc>
          <type name="Surface" c:type="cairo_surface_t*"/>
        </parameter>
      </parameters>
    </function>
    <function name="image_surface_get_width"
              c:identifier="cairo_image_surface_get_width"
              version="1.0">
      <doc xml:space="preserve"
           filename="cairo-image-surface.c"
           line="620">Get the width of the image surface in pixels.</doc>
      <source-position filename="cairo.h" line="2726"/>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve"
             filename="cairo-image-surface.c"
             line="626">the width of the surface in pixels.</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="surface" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cairo-image-surface.c"
               line="622">a #cairo_image_surface_t</doc>
          <type name="Surface" c:type="cairo_surface_t*"/>
        </parameter>
      </parameters>
    </function>
    <function name="mesh_pattern_begin_patch"
              c:identifier="cairo_mesh_pattern_begin_patch"
              version="1.12">
      <doc xml:space="preserve"
           filename="cairo-pattern.c"
           line="1244">Begin a patch in a mesh pattern.

After calling this function, the patch shape should be defined with
cairo_mesh_pattern_move_to(), cairo_mesh_pattern_line_to() and
cairo_mesh_pattern_curve_to().

After defining the patch, cairo_mesh_pattern_end_patch() must be
called before using @pattern as a source or mask.

Note: If @pattern is not a mesh pattern then @pattern will be put
into an error status with a status of
%CAIRO_STATUS_PATTERN_TYPE_MISMATCH. If @pattern already has a
current patch, it will be put into an error status with a status of
%CAIRO_STATUS_INVALID_MESH_CONSTRUCTION.</doc>
      <source-position filename="cairo.h" line="3008"/>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="pattern" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cairo-pattern.c"
               line="1246">a #cairo_pattern_t</doc>
          <type name="Pattern" c:type="cairo_pattern_t*"/>
        </parameter>
      </parameters>
    </function>
    <function name="mesh_pattern_curve_to"
              c:identifier="cairo_mesh_pattern_curve_to"
              version="1.12">
      <doc xml:space="preserve"
           filename="cairo-pattern.c"
           line="1419">Adds a cubic Bézier spline to the current patch from the current
point to position (@x3, @y3) in pattern-space coordinates, using
(@x1, @y1) and (@x2, @y2) as the control points.

If the current patch has no current point before the call to
cairo_mesh_pattern_curve_to(), this function will behave as if
preceded by a call to cairo_mesh_pattern_move_to(@pattern, @x1,
@y1).

After this call the current point will be (@x3, @y3).

Note: If @pattern is not a mesh pattern then @pattern will be put
into an error status with a status of
%CAIRO_STATUS_PATTERN_TYPE_MISMATCH. If @pattern has no current
patch or the current patch already has 4 sides, @pattern will be
put into an error status with a status of
%CAIRO_STATUS_INVALID_MESH_CONSTRUCTION.</doc>
      <source-position filename="cairo.h" line="3014"/>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="pattern" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cairo-pattern.c"
               line="1421">a #cairo_pattern_t</doc>
          <type name="Pattern" c:type="cairo_pattern_t*"/>
        </parameter>
        <parameter name="x1" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cairo-pattern.c"
               line="1422">the X coordinate of the first control point</doc>
          <type name="gdouble" c:type="double"/>
        </parameter>
        <parameter name="y1" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cairo-pattern.c"
               line="1423">the Y coordinate of the first control point</doc>
          <type name="gdouble" c:type="double"/>
        </parameter>
        <parameter name="x2" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cairo-pattern.c"
               line="1424">the X coordinate of the second control point</doc>
          <type name="gdouble" c:type="double"/>
        </parameter>
        <parameter name="y2" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cairo-pattern.c"
               line="1425">the Y coordinate of the second control point</doc>
          <type name="gdouble" c:type="double"/>
        </parameter>
        <parameter name="x3" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cairo-pattern.c"
               line="1426">the X coordinate of the end of the curve</doc>
          <type name="gdouble" c:type="double"/>
        </parameter>
        <parameter name="y3" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cairo-pattern.c"
               line="1427">the Y coordinate of the end of the curve</doc>
          <type name="gdouble" c:type="double"/>
        </parameter>
      </parameters>
    </function>
    <function name="mesh_pattern_end_patch"
              c:identifier="cairo_mesh_pattern_end_patch"
              version="1.12">
      <doc xml:space="preserve"
           filename="cairo-pattern.c"
           line="1346">Indicates the end of the current patch in a mesh pattern.

If the current patch has less than 4 sides, it is closed with a
straight line from the current point to the first point of the
patch as if cairo_mesh_pattern_line_to() was used.

Note: If @pattern is not a mesh pattern then @pattern will be put
into an error status with a status of
%CAIRO_STATUS_PATTERN_TYPE_MISMATCH. If @pattern has no current
patch or the current patch has no current point, @pattern will be
put into an error status with a status of
%CAIRO_STATUS_INVALID_MESH_CONSTRUCTION.</doc>
      <source-position filename="cairo.h" line="3011"/>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="pattern" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cairo-pattern.c"
               line="1348">a #cairo_pattern_t</doc>
          <type name="Pattern" c:type="cairo_pattern_t*"/>
        </parameter>
      </parameters>
    </function>
    <function name="mesh_pattern_get_control_point"
              c:identifier="cairo_mesh_pattern_get_control_point"
              version="1.12">
      <doc xml:space="preserve"
           filename="cairo-pattern.c"
           line="4656">Gets the control point @point_num of patch @patch_num for a mesh
pattern.

@patch_num can range from 0 to n-1 where n is the number returned by
cairo_mesh_pattern_get_patch_count().

Valid values for @point_num are from 0 to 3 and identify the
control points as explained in cairo_pattern_create_mesh().</doc>
      <source-position filename="cairo.h" line="3170"/>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve"
             filename="cairo-pattern.c"
             line="4673">%CAIRO_STATUS_SUCCESS, or %CAIRO_STATUS_INVALID_INDEX
if @patch_num or @point_num is not valid for @pattern. If @pattern
is not a mesh pattern, %CAIRO_STATUS_PATTERN_TYPE_MISMATCH is
returned.</doc>
        <type name="Status" c:type="cairo_status_t"/>
      </return-value>
      <parameters>
        <parameter name="pattern" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cairo-pattern.c"
               line="4658">a #cairo_pattern_t</doc>
          <type name="Pattern" c:type="cairo_pattern_t*"/>
        </parameter>
        <parameter name="patch_num" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cairo-pattern.c"
               line="4659">the patch number to return data for</doc>
          <type name="guint" c:type="unsigned int"/>
        </parameter>
        <parameter name="point_num" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cairo-pattern.c"
               line="4660">the control point number to return data for</doc>
          <type name="guint" c:type="unsigned int"/>
        </parameter>
        <parameter name="x" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cairo-pattern.c"
               line="4661">return value for the x coordinate of the control point, or %NULL</doc>
          <type name="gdouble" c:type="double*"/>
        </parameter>
        <parameter name="y" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cairo-pattern.c"
               line="4662">return value for the y coordinate of the control point, or %NULL</doc>
          <type name="gdouble" c:type="double*"/>
        </parameter>
      </parameters>
    </function>
    <function name="mesh_pattern_get_corner_color_rgba"
              c:identifier="cairo_mesh_pattern_get_corner_color_rgba"
              version="1.12">
      <doc xml:space="preserve"
           filename="cairo-pattern.c"
           line="4587">Gets the color information in corner @corner_num of patch
@patch_num for a mesh pattern.

@patch_num can range from 0 to n-1 where n is the number returned by
cairo_mesh_pattern_get_patch_count().

Valid values for @corner_num are from 0 to 3 and identify the
corners as explained in cairo_pattern_create_mesh().

Note that the color and alpha values are not premultiplied.</doc>
      <source-position filename="cairo.h" line="3163"/>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve"
             filename="cairo-pattern.c"
             line="4608">%CAIRO_STATUS_SUCCESS, or %CAIRO_STATUS_INVALID_INDEX
if @patch_num or @corner_num is not valid for @pattern. If
@pattern is not a mesh pattern, %CAIRO_STATUS_PATTERN_TYPE_MISMATCH
is returned.</doc>
        <type name="Status" c:type="cairo_status_t"/>
      </return-value>
      <parameters>
        <parameter name="pattern" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cairo-pattern.c"
               line="4589">a #cairo_pattern_t</doc>
          <type name="Pattern" c:type="cairo_pattern_t*"/>
        </parameter>
        <parameter name="patch_num" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cairo-pattern.c"
               line="4590">the patch number to return data for</doc>
          <type name="guint" c:type="unsigned int"/>
        </parameter>
        <parameter name="corner_num" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cairo-pattern.c"
               line="4591">the corner number to return data for</doc>
          <type name="guint" c:type="unsigned int"/>
        </parameter>
        <parameter name="red" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cairo-pattern.c"
               line="4592">return value for red component of color, or %NULL</doc>
          <type name="gdouble" c:type="double*"/>
        </parameter>
        <parameter name="green" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cairo-pattern.c"
               line="4593">return value for green component of color, or %NULL</doc>
          <type name="gdouble" c:type="double*"/>
        </parameter>
        <parameter name="blue" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cairo-pattern.c"
               line="4594">return value for blue component of color, or %NULL</doc>
          <type name="gdouble" c:type="double*"/>
        </parameter>
        <parameter name="alpha" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cairo-pattern.c"
               line="4595">return value for alpha component of color, or %NULL</doc>
          <type name="gdouble" c:type="double*"/>
        </parameter>
      </parameters>
    </function>
    <function name="mesh_pattern_get_patch_count"
              c:identifier="cairo_mesh_pattern_get_patch_count"
              version="1.12">
      <doc xml:space="preserve"
           filename="cairo-pattern.c"
           line="4462">Gets the number of patches specified in the given mesh pattern.

The number only includes patches which have been finished by
calling cairo_mesh_pattern_end_patch(). For example it will be 0
during the definition of the first patch.</doc>
      <source-position filename="cairo.h" line="3155"/>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve"
             filename="cairo-pattern.c"
             line="4473">%CAIRO_STATUS_SUCCESS, or
%CAIRO_STATUS_PATTERN_TYPE_MISMATCH if @pattern is not a mesh
pattern.</doc>
        <type name="Status" c:type="cairo_status_t"/>
      </return-value>
      <parameters>
        <parameter name="pattern" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cairo-pattern.c"
               line="4464">a #cairo_pattern_t</doc>
          <type name="Pattern" c:type="cairo_pattern_t*"/>
        </parameter>
        <parameter name="count" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cairo-pattern.c"
               line="4465">return value for the number patches, or %NULL</doc>
          <type name="guint" c:type="unsigned int*"/>
        </parameter>
      </parameters>
    </function>
    <function name="mesh_pattern_get_path"
              c:identifier="cairo_mesh_pattern_get_path"
              version="1.12">
      <doc xml:space="preserve"
           filename="cairo-pattern.c"
           line="4500">Gets path defining the patch @patch_num for a mesh
pattern.

@patch_num can range from 0 to n-1 where n is the number returned by
cairo_mesh_pattern_get_patch_count().</doc>
      <source-position filename="cairo.h" line="3159"/>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve"
             filename="cairo-pattern.c"
             line="4511">the path defining the patch, or a path with status
%CAIRO_STATUS_INVALID_INDEX if @patch_num or @point_num is not
valid for @pattern. If @pattern is not a mesh pattern, a path with
status %CAIRO_STATUS_PATTERN_TYPE_MISMATCH is returned.</doc>
        <type name="Path" c:type="cairo_path_t*"/>
      </return-value>
      <parameters>
        <parameter name="pattern" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cairo-pattern.c"
               line="4502">a #cairo_pattern_t</doc>
          <type name="Pattern" c:type="cairo_pattern_t*"/>
        </parameter>
        <parameter name="patch_num" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cairo-pattern.c"
               line="4503">the patch number to return data for</doc>
          <type name="guint" c:type="unsigned int"/>
        </parameter>
      </parameters>
    </function>
    <function name="mesh_pattern_line_to"
              c:identifier="cairo_mesh_pattern_line_to"
              version="1.12">
      <doc xml:space="preserve"
           filename="cairo-pattern.c"
           line="1508">Adds a line to the current patch from the current point to position
(@x, @y) in pattern-space coordinates.

If there is no current point before the call to
cairo_mesh_pattern_line_to() this function will behave as
cairo_mesh_pattern_move_to(@pattern, @x, @y).

After this call the current point will be (@x, @y).

Note: If @pattern is not a mesh pattern then @pattern will be put
into an error status with a status of
%CAIRO_STATUS_PATTERN_TYPE_MISMATCH. If @pattern has no current
patch or the current patch already has 4 sides, @pattern will be
put into an error status with a status of
%CAIRO_STATUS_INVALID_MESH_CONSTRUCTION.</doc>
      <source-position filename="cairo.h" line="3020"/>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="pattern" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cairo-pattern.c"
               line="1510">a #cairo_pattern_t</doc>
          <type name="Pattern" c:type="cairo_pattern_t*"/>
        </parameter>
        <parameter name="x" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cairo-pattern.c"
               line="1511">the X coordinate of the end of the new line</doc>
          <type name="gdouble" c:type="double"/>
        </parameter>
        <parameter name="y" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cairo-pattern.c"
               line="1512">the Y coordinate of the end of the new line</doc>
          <type name="gdouble" c:type="double"/>
        </parameter>
      </parameters>
    </function>
    <function name="mesh_pattern_move_to"
              c:identifier="cairo_mesh_pattern_move_to"
              version="1.12">
      <doc xml:space="preserve"
           filename="cairo-pattern.c"
           line="1578">Define the first point of the current patch in a mesh pattern.

After this call the current point will be (@x, @y).

Note: If @pattern is not a mesh pattern then @pattern will be put
into an error status with a status of
%CAIRO_STATUS_PATTERN_TYPE_MISMATCH. If @pattern has no current
patch or the current patch already has at least one side, @pattern
will be put into an error status with a status of
%CAIRO_STATUS_INVALID_MESH_CONSTRUCTION.</doc>
      <source-position filename="cairo.h" line="3024"/>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="pattern" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cairo-pattern.c"
               line="1580">a #cairo_pattern_t</doc>
          <type name="Pattern" c:type="cairo_pattern_t*"/>
        </parameter>
        <parameter name="x" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cairo-pattern.c"
               line="1581">the X coordinate of the new position</doc>
          <type name="gdouble" c:type="double"/>
        </parameter>
        <parameter name="y" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cairo-pattern.c"
               line="1582">the Y coordinate of the new position</doc>
          <type name="gdouble" c:type="double"/>
        </parameter>
      </parameters>
    </function>
    <function name="mesh_pattern_set_control_point"
              c:identifier="cairo_mesh_pattern_set_control_point"
              version="1.12">
      <doc xml:space="preserve"
           filename="cairo-pattern.c"
           line="1627">Set an internal control point of the current patch.

Valid values for @point_num are from 0 to 3 and identify the
control points as explained in cairo_pattern_create_mesh().

Note: If @pattern is not a mesh pattern then @pattern will be put
into an error status with a status of
%CAIRO_STATUS_PATTERN_TYPE_MISMATCH. If @point_num is not valid,
@pattern will be put into an error status with a status of
%CAIRO_STATUS_INVALID_INDEX.  If @pattern has no current patch,
@pattern will be put into an error status with a status of
%CAIRO_STATUS_INVALID_MESH_CONSTRUCTION.</doc>
      <source-position filename="cairo.h" line="3028"/>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="pattern" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cairo-pattern.c"
               line="1629">a #cairo_pattern_t</doc>
          <type name="Pattern" c:type="cairo_pattern_t*"/>
        </parameter>
        <parameter name="point_num" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cairo-pattern.c"
               line="1630">the control point to set the position for</doc>
          <type name="guint" c:type="unsigned int"/>
        </parameter>
        <parameter name="x" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cairo-pattern.c"
               line="1631">the X coordinate of the control point</doc>
          <type name="gdouble" c:type="double"/>
        </parameter>
        <parameter name="y" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cairo-pattern.c"
               line="1632">the Y coordinate of the control point</doc>
          <type name="gdouble" c:type="double"/>
        </parameter>
      </parameters>
    </function>
    <function name="mesh_pattern_set_corner_color_rgb"
              c:identifier="cairo_mesh_pattern_set_corner_color_rgb"
              version="1.12">
      <doc xml:space="preserve"
           filename="cairo-pattern.c"
           line="1751">Sets the color of a corner of the current patch in a mesh pattern.

The color is specified in the same way as in cairo_set_source_rgb().

Valid values for @corner_num are from 0 to 3 and identify the
corners as explained in cairo_pattern_create_mesh().

Note: If @pattern is not a mesh pattern then @pattern will be put
into an error status with a status of
%CAIRO_STATUS_PATTERN_TYPE_MISMATCH. If @corner_num is not valid,
@pattern will be put into an error status with a status of
%CAIRO_STATUS_INVALID_INDEX.  If @pattern has no current patch,
@pattern will be put into an error status with a status of
%CAIRO_STATUS_INVALID_MESH_CONSTRUCTION.</doc>
      <source-position filename="cairo.h" line="3033"/>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="pattern" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cairo-pattern.c"
               line="1753">a #cairo_pattern_t</doc>
          <type name="Pattern" c:type="cairo_pattern_t*"/>
        </parameter>
        <parameter name="corner_num" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cairo-pattern.c"
               line="1754">the corner to set the color for</doc>
          <type name="guint" c:type="unsigned int"/>
        </parameter>
        <parameter name="red" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cairo-pattern.c"
               line="1755">red component of color</doc>
          <type name="gdouble" c:type="double"/>
        </parameter>
        <parameter name="green" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cairo-pattern.c"
               line="1756">green component of color</doc>
          <type name="gdouble" c:type="double"/>
        </parameter>
        <parameter name="blue" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cairo-pattern.c"
               line="1757">blue component of color</doc>
          <type name="gdouble" c:type="double"/>
        </parameter>
      </parameters>
    </function>
    <function name="mesh_pattern_set_corner_color_rgba"
              c:identifier="cairo_mesh_pattern_set_corner_color_rgba"
              version="1.12">
      <doc xml:space="preserve"
           filename="cairo-pattern.c"
           line="1784">Sets the color of a corner of the current patch in a mesh pattern.

The color is specified in the same way as in cairo_set_source_rgba().

Valid values for @corner_num are from 0 to 3 and identify the
corners as explained in cairo_pattern_create_mesh().

Note: If @pattern is not a mesh pattern then @pattern will be put
into an error status with a status of
%CAIRO_STATUS_PATTERN_TYPE_MISMATCH. If @corner_num is not valid,
@pattern will be put into an error status with a status of
%CAIRO_STATUS_INVALID_INDEX.  If @pattern has no current patch,
@pattern will be put into an error status with a status of
%CAIRO_STATUS_INVALID_MESH_CONSTRUCTION.</doc>
      <source-position filename="cairo.h" line="3038"/>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="pattern" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cairo-pattern.c"
               line="1786">a #cairo_pattern_t</doc>
          <type name="Pattern" c:type="cairo_pattern_t*"/>
        </parameter>
        <parameter name="corner_num" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cairo-pattern.c"
               line="1787">the corner to set the color for</doc>
          <type name="guint" c:type="unsigned int"/>
        </parameter>
        <parameter name="red" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cairo-pattern.c"
               line="1788">red component of color</doc>
          <type name="gdouble" c:type="double"/>
        </parameter>
        <parameter name="green" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cairo-pattern.c"
               line="1789">green component of color</doc>
          <type name="gdouble" c:type="double"/>
        </parameter>
        <parameter name="blue" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cairo-pattern.c"
               line="1790">blue component of color</doc>
          <type name="gdouble" c:type="double"/>
        </parameter>
        <parameter name="alpha" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cairo-pattern.c"
               line="1791">alpha component of color</doc>
          <type name="gdouble" c:type="double"/>
        </parameter>
      </parameters>
    </function>
    <function name="pattern_create_for_surface"
              c:identifier="cairo_pattern_create_for_surface"
              version="1.0">
      <doc xml:space="preserve"
           filename="cairo-pattern.c"
           line="738">Create a new #cairo_pattern_t for the given surface.</doc>
      <source-position filename="cairo.h" line="2917"/>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve"
             filename="cairo-pattern.c"
             line="744">the newly created #cairo_pattern_t if successful, or
an error pattern in case of no memory.  The caller owns the
returned object and should call cairo_pattern_destroy() when
finished with it.

This function will always return a valid pointer, but if an error
occurred the pattern status will be set to an error.  To inspect
the status of a pattern use cairo_pattern_status().</doc>
        <type name="Pattern" c:type="cairo_pattern_t*"/>
      </return-value>
      <parameters>
        <parameter name="surface" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cairo-pattern.c"
               line="740">the surface</doc>
          <type name="Surface" c:type="cairo_surface_t*"/>
        </parameter>
      </parameters>
    </function>
    <function name="pattern_create_linear"
              c:identifier="cairo_pattern_create_linear"
              version="1.0">
      <doc xml:space="preserve"
           filename="cairo-pattern.c"
           line="786">Create a new linear gradient #cairo_pattern_t along the line defined
by (x0, y0) and (x1, y1).  Before using the gradient pattern, a
number of color stops should be defined using
cairo_pattern_add_color_stop_rgb() or
cairo_pattern_add_color_stop_rgba().

Note: The coordinates here are in pattern space. For a new pattern,
pattern space is identical to user space, but the relationship
between the spaces can be changed with cairo_pattern_set_matrix().</doc>
      <source-position filename="cairo.h" line="2920"/>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve"
             filename="cairo-pattern.c"
             line="803">the newly created #cairo_pattern_t if successful, or
an error pattern in case of no memory.  The caller owns the
returned object and should call cairo_pattern_destroy() when
finished with it.

This function will always return a valid pointer, but if an error
occurred the pattern status will be set to an error.  To inspect
the status of a pattern use cairo_pattern_status().</doc>
        <type name="Pattern" c:type="cairo_pattern_t*"/>
      </return-value>
      <parameters>
        <parameter name="x0" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cairo-pattern.c"
               line="788">x coordinate of the start point</doc>
          <type name="gdouble" c:type="double"/>
        </parameter>
        <parameter name="y0" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cairo-pattern.c"
               line="789">y coordinate of the start point</doc>
          <type name="gdouble" c:type="double"/>
        </parameter>
        <parameter name="x1" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cairo-pattern.c"
               line="790">x coordinate of the end point</doc>
          <type name="gdouble" c:type="double"/>
        </parameter>
        <parameter name="y1" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cairo-pattern.c"
               line="791">y coordinate of the end point</doc>
          <type name="gdouble" c:type="double"/>
        </parameter>
      </parameters>
    </function>
    <function name="pattern_create_mesh"
              c:identifier="cairo_pattern_create_mesh"
              version="1.12">
      <doc xml:space="preserve"
           filename="cairo-pattern.c"
           line="898">Create a new mesh pattern.

Mesh patterns are tensor-product patch meshes (type 7 shadings in
PDF). Mesh patterns may also be used to create other types of
shadings that are special cases of tensor-product patch meshes such
as Coons patch meshes (type 6 shading in PDF) and Gouraud-shaded
triangle meshes (type 4 and 5 shadings in PDF).

Mesh patterns consist of one or more tensor-product patches, which
should be defined before using the mesh pattern. Using a mesh
pattern with a partially defined patch as source or mask will put
the context in an error status with a status of
%CAIRO_STATUS_INVALID_MESH_CONSTRUCTION.

A tensor-product patch is defined by 4 Bézier curves (side 0, 1, 2,
3) and by 4 additional control points (P0, P1, P2, P3) that provide
further control over the patch and complete the definition of the
tensor-product patch. The corner C0 is the first point of the
patch.

Degenerate sides are permitted so straight lines may be used. A
zero length line on one side may be used to create 3 sided patches.

&lt;informalexample&gt;&lt;screen&gt;
      C1     Side 1       C2
       +---------------+
       |               |
       |  P1       P2  |
       |               |
Side 0 |               | Side 2
       |               |
       |               |
       |  P0       P3  |
       |               |
       +---------------+
     C0     Side 3        C3
&lt;/screen&gt;&lt;/informalexample&gt;

Each patch is constructed by first calling
cairo_mesh_pattern_begin_patch(), then cairo_mesh_pattern_move_to()
to specify the first point in the patch (C0). Then the sides are
specified with calls to cairo_mesh_pattern_curve_to() and
cairo_mesh_pattern_line_to().

The four additional control points (P0, P1, P2, P3) in a patch can
be specified with cairo_mesh_pattern_set_control_point().

At each corner of the patch (C0, C1, C2, C3) a color may be
specified with cairo_mesh_pattern_set_corner_color_rgb() or
cairo_mesh_pattern_set_corner_color_rgba(). Any corner whose color
is not explicitly specified defaults to transparent black.

A Coons patch is a special case of the tensor-product patch where
the control points are implicitly defined by the sides of the
patch. The default value for any control point not specified is the
implicit value for a Coons patch, i.e. if no control points are
specified the patch is a Coons patch.

A triangle is a special case of the tensor-product patch where the
control points are implicitly defined by the sides of the patch,
all the sides are lines and one of them has length 0, i.e. if the
patch is specified using just 3 lines, it is a triangle. If the
corners connected by the 0-length side have the same color, the
patch is a Gouraud-shaded triangle.

Patches may be oriented differently to the above diagram. For
example the first point could be at the top left. The diagram only
shows the relationship between the sides, corners and control
points. Regardless of where the first point is located, when
specifying colors, corner 0 will always be the first point, corner
1 the point between side 0 and side 1 etc.

Calling cairo_mesh_pattern_end_patch() completes the current
patch. If less than 4 sides have been defined, the first missing
side is defined as a line from the current point to the first point
of the patch (C0) and the other sides are degenerate lines from C0
to C0. The corners between the added sides will all be coincident
with C0 of the patch and their color will be set to be the same as
the color of C0.

Additional patches may be added with additional calls to
cairo_mesh_pattern_begin_patch()/cairo_mesh_pattern_end_patch().

&lt;informalexample&gt;&lt;programlisting&gt;
cairo_pattern_t *pattern = cairo_pattern_create_mesh ();

/&amp;ast; Add a Coons patch &amp;ast;/
cairo_mesh_pattern_begin_patch (pattern);
cairo_mesh_pattern_move_to (pattern, 0, 0);
cairo_mesh_pattern_curve_to (pattern, 30, -30,  60,  30, 100, 0);
cairo_mesh_pattern_curve_to (pattern, 60,  30, 130,  60, 100, 100);
cairo_mesh_pattern_curve_to (pattern, 60,  70,  30, 130,   0, 100);
cairo_mesh_pattern_curve_to (pattern, 30,  70, -30,  30,   0, 0);
cairo_mesh_pattern_set_corner_color_rgb (pattern, 0, 1, 0, 0);
cairo_mesh_pattern_set_corner_color_rgb (pattern, 1, 0, 1, 0);
cairo_mesh_pattern_set_corner_color_rgb (pattern, 2, 0, 0, 1);
cairo_mesh_pattern_set_corner_color_rgb (pattern, 3, 1, 1, 0);
cairo_mesh_pattern_end_patch (pattern);

/&amp;ast; Add a Gouraud-shaded triangle &amp;ast;/
cairo_mesh_pattern_begin_patch (pattern)
cairo_mesh_pattern_move_to (pattern, 100, 100);
cairo_mesh_pattern_line_to (pattern, 130, 130);
cairo_mesh_pattern_line_to (pattern, 130,  70);
cairo_mesh_pattern_set_corner_color_rgb (pattern, 0, 1, 0, 0);
cairo_mesh_pattern_set_corner_color_rgb (pattern, 1, 0, 1, 0);
cairo_mesh_pattern_set_corner_color_rgb (pattern, 2, 0, 0, 1);
cairo_mesh_pattern_end_patch (pattern)
&lt;/programlisting&gt;&lt;/informalexample&gt;

When two patches overlap, the last one that has been added is drawn
over the first one.

When a patch folds over itself, points are sorted depending on
their parameter coordinates inside the patch. The v coordinate
ranges from 0 to 1 when moving from side 3 to side 1; the u
coordinate ranges from 0 to 1 when going from side 0 to side
2. Points with higher v coordinate hide points with lower v
coordinate. When two points have the same v coordinate, the one
with higher u coordinate is above. This means that points nearer to
side 1 are above points nearer to side 3; when this is not
sufficient to decide which point is above (for example when both
points belong to side 1 or side 3) points nearer to side 2 are
above points nearer to side 0.

For a complete definition of tensor-product patches, see the PDF
specification (ISO32000), which describes the parametrization in
detail.

Note: The coordinates are always in pattern space. For a new
pattern, pattern space is identical to user space, but the
relationship between the spaces can be changed with
cairo_pattern_set_matrix().</doc>
      <source-position filename="cairo.h" line="2928"/>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve"
             filename="cairo-pattern.c"
             line="1035">the newly created #cairo_pattern_t if successful, or
an error pattern in case of no memory. The caller owns the returned
object and should call cairo_pattern_destroy() when finished with
it.

This function will always return a valid pointer, but if an error
occurred the pattern status will be set to an error. To inspect the
status of a pattern use cairo_pattern_status().</doc>
        <type name="Pattern" c:type="cairo_pattern_t*"/>
      </return-value>
    </function>
    <function name="pattern_create_radial"
              c:identifier="cairo_pattern_create_radial"
              version="1.0">
      <doc xml:space="preserve"
           filename="cairo-pattern.c"
           line="837">Creates a new radial gradient #cairo_pattern_t between the two
circles defined by (cx0, cy0, radius0) and (cx1, cy1, radius1).  Before using the
gradient pattern, a number of color stops should be defined using
cairo_pattern_add_color_stop_rgb() or
cairo_pattern_add_color_stop_rgba().

Note: The coordinates here are in pattern space. For a new pattern,
pattern space is identical to user space, but the relationship
between the spaces can be changed with cairo_pattern_set_matrix().</doc>
      <source-position filename="cairo.h" line="2924"/>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve"
             filename="cairo-pattern.c"
             line="856">the newly created #cairo_pattern_t if successful, or
an error pattern in case of no memory.  The caller owns the
returned object and should call cairo_pattern_destroy() when
finished with it.

This function will always return a valid pointer, but if an error
occurred the pattern status will be set to an error.  To inspect
the status of a pattern use cairo_pattern_status().</doc>
        <type name="Pattern" c:type="cairo_pattern_t*"/>
      </return-value>
      <parameters>
        <parameter name="cx0" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cairo-pattern.c"
               line="839">x coordinate for the center of the start circle</doc>
          <type name="gdouble" c:type="double"/>
        </parameter>
        <parameter name="cy0" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cairo-pattern.c"
               line="840">y coordinate for the center of the start circle</doc>
          <type name="gdouble" c:type="double"/>
        </parameter>
        <parameter name="radius0" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cairo-pattern.c"
               line="841">radius of the start circle</doc>
          <type name="gdouble" c:type="double"/>
        </parameter>
        <parameter name="cx1" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cairo-pattern.c"
               line="842">x coordinate for the center of the end circle</doc>
          <type name="gdouble" c:type="double"/>
        </parameter>
        <parameter name="cy1" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cairo-pattern.c"
               line="843">y coordinate for the center of the end circle</doc>
          <type name="gdouble" c:type="double"/>
        </parameter>
        <parameter name="radius1" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cairo-pattern.c"
               line="844">radius of the end circle</doc>
          <type name="gdouble" c:type="double"/>
        </parameter>
      </parameters>
    </function>
    <function name="pattern_create_raster_source"
              c:identifier="cairo_pattern_create_raster_source"
              version="1.12">
      <doc xml:space="preserve"
           filename="cairo-raster-source-pattern.c"
           line="137">Creates a new user pattern for providing pixel data.

Use the setter functions to associate callbacks with the returned
pattern.  The only mandatory callback is acquire.</doc>
      <source-position filename="cairo.h" line="2866"/>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve"
             filename="cairo-raster-source-pattern.c"
             line="151">a newly created #cairo_pattern_t. Free with
 cairo_pattern_destroy() when you are done using it.</doc>
        <type name="Pattern" c:type="cairo_pattern_t*"/>
      </return-value>
      <parameters>
        <parameter name="user_data"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1">
          <doc xml:space="preserve"
               filename="cairo-raster-source-pattern.c"
               line="139">the user data to be passed to all callbacks</doc>
          <type name="gpointer" c:type="void*"/>
        </parameter>
        <parameter name="content" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cairo-raster-source-pattern.c"
               line="140">content type for the pixel data that will be returned. Knowing
the content type ahead of time is used for analysing the operation and
picking the appropriate rendering path.</doc>
          <type name="Content" c:type="cairo_content_t"/>
        </parameter>
        <parameter name="width" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cairo-raster-source-pattern.c"
               line="143">maximum size of the sample area</doc>
          <type name="gint" c:type="int"/>
        </parameter>
        <parameter name="height" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cairo-raster-source-pattern.c"
               line="144">maximum size of the sample area</doc>
          <type name="gint" c:type="int"/>
        </parameter>
      </parameters>
    </function>
    <function name="pattern_create_rgb"
              c:identifier="cairo_pattern_create_rgb"
              version="1.0">
      <doc xml:space="preserve"
           filename="cairo-pattern.c"
           line="667">Creates a new #cairo_pattern_t corresponding to an opaque color.  The
color components are floating point numbers in the range 0 to 1.
If the values passed in are outside that range, they will be
clamped.</doc>
      <source-position filename="cairo.h" line="2910"/>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve"
             filename="cairo-pattern.c"
             line="678">the newly created #cairo_pattern_t if successful, or
an error pattern in case of no memory.  The caller owns the
returned object and should call cairo_pattern_destroy() when
finished with it.

This function will always return a valid pointer, but if an error
occurred the pattern status will be set to an error.  To inspect
the status of a pattern use cairo_pattern_status().</doc>
        <type name="Pattern" c:type="cairo_pattern_t*"/>
      </return-value>
      <parameters>
        <parameter name="red" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cairo-pattern.c"
               line="669">red component of the color</doc>
          <type name="gdouble" c:type="double"/>
        </parameter>
        <parameter name="green" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cairo-pattern.c"
               line="670">green component of the color</doc>
          <type name="gdouble" c:type="double"/>
        </parameter>
        <parameter name="blue" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cairo-pattern.c"
               line="671">blue component of the color</doc>
          <type name="gdouble" c:type="double"/>
        </parameter>
      </parameters>
    </function>
    <function name="pattern_create_rgba"
              c:identifier="cairo_pattern_create_rgba"
              version="1.0">
      <doc xml:space="preserve"
           filename="cairo-pattern.c"
           line="695">Creates a new #cairo_pattern_t corresponding to a translucent color.
The color components are floating point numbers in the range 0 to
1.  If the values passed in are outside that range, they will be
clamped.

The color is specified in the same way as in cairo_set_source_rgb().</doc>
      <source-position filename="cairo.h" line="2913"/>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve"
             filename="cairo-pattern.c"
             line="709">the newly created #cairo_pattern_t if successful, or
an error pattern in case of no memory.  The caller owns the
returned object and should call cairo_pattern_destroy() when
finished with it.

This function will always return a valid pointer, but if an error
occurred the pattern status will be set to an error.  To inspect
the status of a pattern use cairo_pattern_status().</doc>
        <type name="Pattern" c:type="cairo_pattern_t*"/>
      </return-value>
      <parameters>
        <parameter name="red" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cairo-pattern.c"
               line="697">red component of the color</doc>
          <type name="gdouble" c:type="double"/>
        </parameter>
        <parameter name="green" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cairo-pattern.c"
               line="698">green component of the color</doc>
          <type name="gdouble" c:type="double"/>
        </parameter>
        <parameter name="blue" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cairo-pattern.c"
               line="699">blue component of the color</doc>
          <type name="gdouble" c:type="double"/>
        </parameter>
        <parameter name="alpha" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cairo-pattern.c"
               line="700">alpha component of the color</doc>
          <type name="gdouble" c:type="double"/>
        </parameter>
      </parameters>
    </function>
    <function name="pdf_get_versions"
              c:identifier="cairo_pdf_get_versions"
              version="1.10">
      <doc xml:space="preserve"
           filename="cairo-pdf-surface.c"
           line="765">Used to retrieve the list of supported versions. See
cairo_pdf_surface_restrict_to_version().</doc>
      <source-position filename="cairo-pdf.h" line="81"/>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="versions" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cairo-pdf-surface.c"
               line="767">supported version list</doc>
          <type name="PdfVersion" c:type="const cairo_pdf_version_t**"/>
        </parameter>
        <parameter name="num_versions" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cairo-pdf-surface.c"
               line="768">list length</doc>
          <type name="gint" c:type="int*"/>
        </parameter>
      </parameters>
    </function>
    <function name="pdf_surface_add_outline"
              c:identifier="cairo_pdf_surface_add_outline"
              version="1.16">
      <doc xml:space="preserve"
           filename="cairo-pdf-surface.c"
           line="853">Add an item to the document outline hierarchy with the name @utf8
that links to the location specified by @link_attribs. Link
attributes have the same keys and values as the [Link Tag][link],
excluding the "rect" attribute. The item will be a child of the
item with id @parent_id. Use %CAIRO_PDF_OUTLINE_ROOT as the parent
id of top level items.</doc>
      <source-position filename="cairo-pdf.h" line="114"/>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve"
             filename="cairo-pdf-surface.c"
             line="868">the id for the added item.</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="surface" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cairo-pdf-surface.c"
               line="855">a PDF #cairo_surface_t</doc>
          <type name="Surface" c:type="cairo_surface_t*"/>
        </parameter>
        <parameter name="parent_id" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cairo-pdf-surface.c"
               line="856">the id of the parent item or %CAIRO_PDF_OUTLINE_ROOT if this is a top level item.</doc>
          <type name="gint" c:type="int"/>
        </parameter>
        <parameter name="utf8" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cairo-pdf-surface.c"
               line="857">the name of the outline</doc>
          <type name="utf8" c:type="const char*"/>
        </parameter>
        <parameter name="link_attribs" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cairo-pdf-surface.c"
               line="858">the link attributes specifying where this outline links to</doc>
          <type name="utf8" c:type="const char*"/>
        </parameter>
        <parameter name="flags" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cairo-pdf-surface.c"
               line="859">outline item flags</doc>
          <type name="PdfOutlineFlags" c:type="cairo_pdf_outline_flags_t"/>
        </parameter>
      </parameters>
    </function>
    <function name="pdf_surface_create"
              c:identifier="cairo_pdf_surface_create"
              version="1.2">
      <doc xml:space="preserve"
           filename="cairo-pdf-surface.c"
           line="643">Creates a PDF surface of the specified size in points to be written
to @filename.</doc>
      <source-position filename="cairo-pdf.h" line="66"/>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve"
             filename="cairo-pdf-surface.c"
             line="655">a pointer to the newly created surface. The caller
owns the surface and should call cairo_surface_destroy() when done
with it.

This function always returns a valid pointer, but it will return a
pointer to a "nil" surface if an error such as out of memory
occurs. You can use cairo_surface_status() to check for this.</doc>
        <type name="Surface" c:type="cairo_surface_t*"/>
      </return-value>
      <parameters>
        <parameter name="filename" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cairo-pdf-surface.c"
               line="645">a filename for the PDF output (must be writable), %NULL may be
           used to specify no output. This will generate a PDF surface that
           may be queried and used as a source, without generating a
           temporary file.</doc>
          <type name="utf8" c:type="const char*"/>
        </parameter>
        <parameter name="width_in_points" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cairo-pdf-surface.c"
               line="649">width of the surface, in points (1 point == 1/72.0 inch)</doc>
          <type name="gdouble" c:type="double"/>
        </parameter>
        <parameter name="height_in_points" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cairo-pdf-surface.c"
               line="650">height of the surface, in points (1 point == 1/72.0 inch)</doc>
          <type name="gdouble" c:type="double"/>
        </parameter>
      </parameters>
    </function>
    <function name="pdf_surface_create_for_stream"
              c:identifier="cairo_pdf_surface_create_for_stream"
              version="1.2">
      <doc xml:space="preserve"
           filename="cairo-pdf-surface.c"
           line="603">Creates a PDF surface of the specified size in points to be written
incrementally to the stream represented by @write_func and @closure.</doc>
      <source-position filename="cairo-pdf.h" line="71"/>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve"
             filename="cairo-pdf-surface.c"
             line="616">a pointer to the newly created surface. The caller
owns the surface and should call cairo_surface_destroy() when done
with it.

This function always returns a valid pointer, but it will return a
pointer to a "nil" surface if an error such as out of memory
occurs. You can use cairo_surface_status() to check for this.</doc>
        <type name="Surface" c:type="cairo_surface_t*"/>
      </return-value>
      <parameters>
        <parameter name="write_func" transfer-ownership="none" scope="call">
          <doc xml:space="preserve"
               filename="cairo-pdf-surface.c"
               line="605">a #cairo_write_func_t to accept the output data, may be %NULL
             to indicate a no-op @write_func. With a no-op @write_func,
             the surface may be queried or used as a source without
             generating any temporary files.</doc>
          <type name="WriteFunc" c:type="cairo_write_func_t"/>
        </parameter>
        <parameter name="closure"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1">
          <doc xml:space="preserve"
               filename="cairo-pdf-surface.c"
               line="609">the closure argument for @write_func</doc>
          <type name="gpointer" c:type="void*"/>
        </parameter>
        <parameter name="width_in_points" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cairo-pdf-surface.c"
               line="610">width of the surface, in points (1 point == 1/72.0 inch)</doc>
          <type name="gdouble" c:type="double"/>
        </parameter>
        <parameter name="height_in_points" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cairo-pdf-surface.c"
               line="611">height of the surface, in points (1 point == 1/72.0 inch)</doc>
          <type name="gdouble" c:type="double"/>
        </parameter>
      </parameters>
    </function>
    <function name="pdf_surface_restrict_to_version"
              c:identifier="cairo_pdf_surface_restrict_to_version"
              version="1.10">
      <doc xml:space="preserve"
           filename="cairo-pdf-surface.c"
           line="734">Restricts the generated PDF file to @version. See cairo_pdf_get_versions()
for a list of available version values that can be used here.

This function should only be called before any drawing operations
have been performed on the given surface. The simplest way to do
this is to call this function immediately after creating the
surface.</doc>
      <source-position filename="cairo-pdf.h" line="77"/>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="surface" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cairo-pdf-surface.c"
               line="736">a PDF #cairo_surface_t</doc>
          <type name="Surface" c:type="cairo_surface_t*"/>
        </parameter>
        <parameter name="version" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cairo-pdf-surface.c"
               line="737">PDF version</doc>
          <type name="PdfVersion" c:type="cairo_pdf_version_t"/>
        </parameter>
      </parameters>
    </function>
    <function name="pdf_surface_set_custom_metadata"
              c:identifier="cairo_pdf_surface_set_custom_metadata"
              version="1.18">
      <doc xml:space="preserve"
           filename="cairo-pdf-surface.c"
           line="934">Set custom document metadata. @name may be any string except for
the following names reserved by PDF: "Title", "Author", "Subject",
"Keywords", "Creator", "Producer", "CreationDate", "ModDate",
"Trapped".

If @value is NULL or an empty string, the @name metadata will not be set.

For example:
&lt;informalexample&gt;&lt;programlisting&gt;
cairo_pdf_surface_set_custom_metadata (surface, "ISBN", "978-0123456789");
&lt;/programlisting&gt;&lt;/informalexample&gt;</doc>
      <source-position filename="cairo-pdf.h" line="151"/>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="surface" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cairo-pdf-surface.c"
               line="936">a PDF #cairo_surface_t</doc>
          <type name="Surface" c:type="cairo_surface_t*"/>
        </parameter>
        <parameter name="name" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cairo-pdf-surface.c"
               line="937">The name of the custom metadata item to set (utf8).</doc>
          <type name="utf8" c:type="const char*"/>
        </parameter>
        <parameter name="value" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cairo-pdf-surface.c"
               line="938">The value of the metadata (utf8).</doc>
          <type name="utf8" c:type="const char*"/>
        </parameter>
      </parameters>
    </function>
    <function name="pdf_surface_set_metadata"
              c:identifier="cairo_pdf_surface_set_metadata"
              version="1.16">
      <doc xml:space="preserve"
           filename="cairo-pdf-surface.c"
           line="898">Set document metadata. The %CAIRO_PDF_METADATA_CREATE_DATE and
%CAIRO_PDF_METADATA_MOD_DATE values must be in ISO-8601 format:
YYYY-MM-DDThh:mm:ss. An optional timezone of the form "[+/-]hh:mm"
or "Z" for UTC time can be appended. All other metadata values can be any UTF-8
string.

For example:
&lt;informalexample&gt;&lt;programlisting&gt;
cairo_pdf_surface_set_metadata (surface, CAIRO_PDF_METADATA_TITLE, "My Document");
cairo_pdf_surface_set_metadata (surface, CAIRO_PDF_METADATA_CREATE_DATE, "2015-12-31T23:59+02:00");
&lt;/programlisting&gt;&lt;/informalexample&gt;</doc>
      <source-position filename="cairo-pdf.h" line="146"/>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="surface" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cairo-pdf-surface.c"
               line="900">a PDF #cairo_surface_t</doc>
          <type name="Surface" c:type="cairo_surface_t*"/>
        </parameter>
        <parameter name="metadata" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cairo-pdf-surface.c"
               line="901">The metadata item to set.</doc>
          <type name="PdfMetadata" c:type="cairo_pdf_metadata_t"/>
        </parameter>
        <parameter name="utf8" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cairo-pdf-surface.c"
               line="902">metadata value</doc>
          <type name="utf8" c:type="const char*"/>
        </parameter>
      </parameters>
    </function>
    <function name="pdf_surface_set_page_label"
              c:identifier="cairo_pdf_surface_set_page_label"
              version="1.16">
      <doc xml:space="preserve"
           filename="cairo-pdf-surface.c"
           line="970">Set page label for the current page.</doc>
      <source-position filename="cairo-pdf.h" line="156"/>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="surface" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cairo-pdf-surface.c"
               line="972">a PDF #cairo_surface_t</doc>
          <type name="Surface" c:type="cairo_surface_t*"/>
        </parameter>
        <parameter name="utf8" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cairo-pdf-surface.c"
               line="973">The page label.</doc>
          <type name="utf8" c:type="const char*"/>
        </parameter>
      </parameters>
    </function>
    <function name="pdf_surface_set_size"
              c:identifier="cairo_pdf_surface_set_size"
              version="1.2">
      <doc xml:space="preserve"
           filename="cairo-pdf-surface.c"
           line="807">Changes the size of a PDF surface for the current (and
subsequent) pages.

This function should only be called before any drawing operations
have been performed on the current page. The simplest way to do
this is to call this function immediately after creating the
surface or immediately after completing a page with either
cairo_show_page() or cairo_copy_page().</doc>
      <source-position filename="cairo-pdf.h" line="88"/>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="surface" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cairo-pdf-surface.c"
               line="809">a PDF #cairo_surface_t</doc>
          <type name="Surface" c:type="cairo_surface_t*"/>
        </parameter>
        <parameter name="width_in_points" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cairo-pdf-surface.c"
               line="810">new surface width, in points (1 point == 1/72.0 inch)</doc>
          <type name="gdouble" c:type="double"/>
        </parameter>
        <parameter name="height_in_points" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cairo-pdf-surface.c"
               line="811">new surface height, in points (1 point == 1/72.0 inch)</doc>
          <type name="gdouble" c:type="double"/>
        </parameter>
      </parameters>
    </function>
    <function name="pdf_surface_set_thumbnail_size"
              c:identifier="cairo_pdf_surface_set_thumbnail_size"
              version="1.16">
      <doc xml:space="preserve"
           filename="cairo-pdf-surface.c"
           line="992">Set the thumbnail image size for the current and all subsequent
pages. Setting a width or height of 0 disables thumbnails for the
current and subsequent pages.</doc>
      <source-position filename="cairo-pdf.h" line="160"/>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="surface" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cairo-pdf-surface.c"
               line="994">a PDF #cairo_surface_t</doc>
          <type name="Surface" c:type="cairo_surface_t*"/>
        </parameter>
        <parameter name="width" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cairo-pdf-surface.c"
               line="995">Thumbnail width.</doc>
          <type name="gint" c:type="int"/>
        </parameter>
        <parameter name="height" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cairo-pdf-surface.c"
               line="996">Thumbnail height</doc>
          <type name="gint" c:type="int"/>
        </parameter>
      </parameters>
    </function>
    <function name="pdf_version_to_string"
              c:identifier="cairo_pdf_version_to_string"
              version="1.10">
      <doc xml:space="preserve"
           filename="cairo-pdf-surface.c"
           line="786">Get the string representation of the given @version id. This function
will return %NULL if @version isn't valid. See cairo_pdf_get_versions()
for a way to get the list of valid version ids.</doc>
      <source-position filename="cairo-pdf.h" line="85"/>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve"
             filename="cairo-pdf-surface.c"
             line="794">the string associated to given version.</doc>
        <type name="utf8" c:type="const char*"/>
      </return-value>
      <parameters>
        <parameter name="version" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cairo-pdf-surface.c"
               line="788">a version id</doc>
          <type name="PdfVersion" c:type="cairo_pdf_version_t"/>
        </parameter>
      </parameters>
    </function>
    <function name="ps_get_levels"
              c:identifier="cairo_ps_get_levels"
              version="1.6">
      <doc xml:space="preserve"
           filename="cairo-ps-surface.c"
           line="1391">Used to retrieve the list of supported levels. See
cairo_ps_surface_restrict_to_level().</doc>
      <source-position filename="cairo-ps.h" line="82"/>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="levels" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cairo-ps-surface.c"
               line="1393">supported level list</doc>
          <type name="PsLevel" c:type="const cairo_ps_level_t**"/>
        </parameter>
        <parameter name="num_levels" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cairo-ps-surface.c"
               line="1394">list length</doc>
          <type name="gint" c:type="int*"/>
        </parameter>
      </parameters>
    </function>
    <function name="ps_level_to_string"
              c:identifier="cairo_ps_level_to_string"
              version="1.6">
      <doc xml:space="preserve"
           filename="cairo-ps-surface.c"
           line="1412">Get the string representation of the given @level id. This function
will return %NULL if @level id isn't valid. See cairo_ps_get_levels()
for a way to get the list of valid level ids.</doc>
      <source-position filename="cairo-ps.h" line="86"/>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve"
             filename="cairo-ps-surface.c"
             line="1420">the string associated to given level.</doc>
        <type name="utf8" c:type="const char*"/>
      </return-value>
      <parameters>
        <parameter name="level" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cairo-ps-surface.c"
               line="1414">a level id</doc>
          <type name="PsLevel" c:type="cairo_ps_level_t"/>
        </parameter>
      </parameters>
    </function>
    <function name="ps_surface_create"
              c:identifier="cairo_ps_surface_create"
              version="1.2">
      <doc xml:space="preserve"
           filename="cairo-ps-surface.c"
           line="1217">Creates a PostScript surface of the specified size in points to be
written to @filename. See cairo_ps_surface_create_for_stream() for
a more flexible mechanism for handling the PostScript output than
simply writing it to a named file.

Note that the size of individual pages of the PostScript output can
vary. See cairo_ps_surface_set_size().</doc>
      <source-position filename="cairo-ps.h" line="67"/>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve"
             filename="cairo-ps-surface.c"
             line="1234">a pointer to the newly created surface. The caller
owns the surface and should call cairo_surface_destroy() when done
with it.

This function always returns a valid pointer, but it will return a
pointer to a "nil" surface if an error such as out of memory
occurs. You can use cairo_surface_status() to check for this.</doc>
        <type name="Surface" c:type="cairo_surface_t*"/>
      </return-value>
      <parameters>
        <parameter name="filename" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cairo-ps-surface.c"
               line="1219">a filename for the PS output (must be writable), %NULL may be
           used to specify no output. This will generate a PS surface that
           may be queried and used as a source, without generating a
           temporary file.</doc>
          <type name="utf8" c:type="const char*"/>
        </parameter>
        <parameter name="width_in_points" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cairo-ps-surface.c"
               line="1223">width of the surface, in points (1 point == 1/72.0 inch)</doc>
          <type name="gdouble" c:type="double"/>
        </parameter>
        <parameter name="height_in_points" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cairo-ps-surface.c"
               line="1224">height of the surface, in points (1 point == 1/72.0 inch)</doc>
          <type name="gdouble" c:type="double"/>
        </parameter>
      </parameters>
    </function>
    <function name="ps_surface_create_for_stream"
              c:identifier="cairo_ps_surface_create_for_stream"
              version="1.2">
      <doc xml:space="preserve"
           filename="cairo-ps-surface.c"
           line="1260">Creates a PostScript surface of the specified size in points to be
written incrementally to the stream represented by @write_func and
@closure. See cairo_ps_surface_create() for a more convenient way
to simply direct the PostScript output to a named file.

Note that the size of individual pages of the PostScript
output can vary. See cairo_ps_surface_set_size().</doc>
      <source-position filename="cairo-ps.h" line="72"/>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve"
             filename="cairo-ps-surface.c"
             line="1278">a pointer to the newly created surface. The caller
owns the surface and should call cairo_surface_destroy() when done
with it.

This function always returns a valid pointer, but it will return a
pointer to a "nil" surface if an error such as out of memory
occurs. You can use cairo_surface_status() to check for this.</doc>
        <type name="Surface" c:type="cairo_surface_t*"/>
      </return-value>
      <parameters>
        <parameter name="write_func" transfer-ownership="none" scope="call">
          <doc xml:space="preserve"
               filename="cairo-ps-surface.c"
               line="1262">a #cairo_write_func_t to accept the output data, may be %NULL
             to indicate a no-op @write_func. With a no-op @write_func,
             the surface may be queried or used as a source without
             generating any temporary files.</doc>
          <type name="WriteFunc" c:type="cairo_write_func_t"/>
        </parameter>
        <parameter name="closure"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1">
          <doc xml:space="preserve"
               filename="cairo-ps-surface.c"
               line="1266">the closure argument for @write_func</doc>
          <type name="gpointer" c:type="void*"/>
        </parameter>
        <parameter name="width_in_points" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cairo-ps-surface.c"
               line="1267">width of the surface, in points (1 point == 1/72.0 inch)</doc>
          <type name="gdouble" c:type="double"/>
        </parameter>
        <parameter name="height_in_points" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cairo-ps-surface.c"
               line="1268">height of the surface, in points (1 point == 1/72.0 inch)</doc>
          <type name="gdouble" c:type="double"/>
        </parameter>
      </parameters>
    </function>
    <function name="ps_surface_dsc_begin_page_setup"
              c:identifier="cairo_ps_surface_dsc_begin_page_setup"
              version="1.2">
      <doc xml:space="preserve"
           filename="cairo-ps-surface.c"
           line="1680">This function indicates that subsequent calls to
cairo_ps_surface_dsc_comment() should direct comments to the
PageSetup section of the PostScript output.

This function call is only needed for the first page of a
surface. It should be called after any call to
cairo_ps_surface_dsc_begin_setup() and before any drawing is
performed to the surface.

See cairo_ps_surface_dsc_comment() for more details.</doc>
      <source-position filename="cairo-ps.h" line="108"/>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="surface" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cairo-ps-surface.c"
               line="1682">a PostScript #cairo_surface_t</doc>
          <type name="Surface" c:type="cairo_surface_t*"/>
        </parameter>
      </parameters>
    </function>
    <function name="ps_surface_dsc_begin_setup"
              c:identifier="cairo_ps_surface_dsc_begin_setup"
              version="1.2">
      <doc xml:space="preserve"
           filename="cairo-ps-surface.c"
           line="1652">This function indicates that subsequent calls to
cairo_ps_surface_dsc_comment() should direct comments to the Setup
section of the PostScript output.

This function should be called at most once per surface, and must
be called before any call to cairo_ps_surface_dsc_begin_page_setup()
and before any drawing is performed to the surface.

See cairo_ps_surface_dsc_comment() for more details.</doc>
      <source-position filename="cairo-ps.h" line="105"/>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="surface" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cairo-ps-surface.c"
               line="1654">a PostScript #cairo_surface_t</doc>
          <type name="Surface" c:type="cairo_surface_t*"/>
        </parameter>
      </parameters>
    </function>
    <function name="ps_surface_dsc_comment"
              c:identifier="cairo_ps_surface_dsc_comment"
              version="1.2">
      <doc xml:space="preserve"
           filename="cairo-ps-surface.c"
           line="1526">Emit a comment into the PostScript output for the given surface.

The comment is expected to conform to the PostScript Language
Document Structuring Conventions (DSC). Please see that manual for
details on the available comments and their meanings. In
particular, the \%\%IncludeFeature comment allows a
device-independent means of controlling printer device features. So
the PostScript Printer Description Files Specification will also be
a useful reference.

The comment string must begin with a percent character (\%) and the
total length of the string (including any initial percent
characters) must not exceed 255 characters. Violating either of
these conditions will place @surface into an error state. But
beyond these two conditions, this function will not enforce
conformance of the comment with any particular specification.

The comment string must not contain any newline characters.

The DSC specifies different sections in which particular comments
can appear. This function provides for comments to be emitted
within three sections: the header, the Setup section, and the
PageSetup section.  Comments appearing in the first two sections
apply to the entire document while comments in the BeginPageSetup
section apply only to a single page.

For comments to appear in the header section, this function should
be called after the surface is created, but before a call to
cairo_ps_surface_dsc_begin_setup().

For comments to appear in the Setup section, this function should
be called after a call to cairo_ps_surface_dsc_begin_setup() but
before a call to cairo_ps_surface_dsc_begin_page_setup().

For comments to appear in the PageSetup section, this function
should be called after a call to
cairo_ps_surface_dsc_begin_page_setup().

Note that it is only necessary to call
cairo_ps_surface_dsc_begin_page_setup() for the first page of any
surface. After a call to cairo_show_page() or cairo_copy_page()
comments are unambiguously directed to the PageSetup section of the
current page. But it doesn't hurt to call this function at the
beginning of every page as that consistency may make the calling
code simpler.

As a final note, cairo automatically generates several comments on
its own. As such, applications must not manually generate any of
the following comments:

Header section: \%!PS-Adobe-3.0, \%\%Creator, \%\%CreationDate, \%\%Pages,
\%\%BoundingBox, \%\%DocumentData, \%\%LanguageLevel, \%\%EndComments.

Setup section: \%\%BeginSetup, \%\%EndSetup

PageSetup section: \%\%BeginPageSetup, \%\%PageBoundingBox, \%\%EndPageSetup.

Other sections: \%\%BeginProlog, \%\%EndProlog, \%\%Page, \%\%Trailer, \%\%EOF

Here is an example sequence showing how this function might be used:

&lt;informalexample&gt;&lt;programlisting&gt;
cairo_surface_t *surface = cairo_ps_surface_create (filename, width, height);
...
cairo_ps_surface_dsc_comment (surface, "%%Title: My excellent document");
cairo_ps_surface_dsc_comment (surface, "%%Copyright: Copyright (C) 2006 Cairo Lover")
...
cairo_ps_surface_dsc_begin_setup (surface);
cairo_ps_surface_dsc_comment (surface, "%%IncludeFeature: *MediaColor White");
...
cairo_ps_surface_dsc_begin_page_setup (surface);
cairo_ps_surface_dsc_comment (surface, "%%IncludeFeature: *PageSize A3");
cairo_ps_surface_dsc_comment (surface, "%%IncludeFeature: *InputSlot LargeCapacity");
cairo_ps_surface_dsc_comment (surface, "%%IncludeFeature: *MediaType Glossy");
cairo_ps_surface_dsc_comment (surface, "%%IncludeFeature: *MediaColor Blue");
... draw to first page here ..
cairo_show_page (cr);
...
cairo_ps_surface_dsc_comment (surface, "%%IncludeFeature: *PageSize A5");
...
&lt;/programlisting&gt;&lt;/informalexample&gt;</doc>
      <source-position filename="cairo-ps.h" line="101"/>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="surface" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cairo-ps-surface.c"
               line="1528">a PostScript #cairo_surface_t</doc>
          <type name="Surface" c:type="cairo_surface_t*"/>
        </parameter>
        <parameter name="comment" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cairo-ps-surface.c"
               line="1529">a comment string to be emitted into the PostScript output</doc>
          <type name="utf8" c:type="const char*"/>
        </parameter>
      </parameters>
    </function>
    <function name="ps_surface_get_eps"
              c:identifier="cairo_ps_surface_get_eps"
              version="1.6">
      <doc xml:space="preserve"
           filename="cairo-ps-surface.c"
           line="1461">Check whether the PostScript surface will output Encapsulated PostScript.</doc>
      <source-position filename="cairo-ps.h" line="93"/>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve"
             filename="cairo-ps-surface.c"
             line="1467">%TRUE if the surface will output Encapsulated PostScript.</doc>
        <type name="Bool" c:type="cairo_bool_t"/>
      </return-value>
      <parameters>
        <parameter name="surface" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cairo-ps-surface.c"
               line="1463">a PostScript #cairo_surface_t</doc>
          <type name="Surface" c:type="cairo_surface_t*"/>
        </parameter>
      </parameters>
    </function>
    <function name="ps_surface_restrict_to_level"
              c:identifier="cairo_ps_surface_restrict_to_level"
              version="1.6">
      <doc xml:space="preserve"
           filename="cairo-ps-surface.c"
           line="1362">Restricts the generated PostSript file to @level. See
cairo_ps_get_levels() for a list of available level values that
can be used here.

This function should only be called before any drawing operations
have been performed on the given surface. The simplest way to do
this is to call this function immediately after creating the
surface.</doc>
      <source-position filename="cairo-ps.h" line="78"/>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="surface" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cairo-ps-surface.c"
               line="1364">a PostScript #cairo_surface_t</doc>
          <type name="Surface" c:type="cairo_surface_t*"/>
        </parameter>
        <parameter name="level" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cairo-ps-surface.c"
               line="1365">PostScript level</doc>
          <type name="PsLevel" c:type="cairo_ps_level_t"/>
        </parameter>
      </parameters>
    </function>
    <function name="ps_surface_set_eps"
              c:identifier="cairo_ps_surface_set_eps"
              version="1.6">
      <doc xml:space="preserve"
           filename="cairo-ps-surface.c"
           line="1433">If @eps is %TRUE, the PostScript surface will output Encapsulated
PostScript.

This function should only be called before any drawing operations
have been performed on the current page. The simplest way to do
this is to call this function immediately after creating the
surface. An Encapsulated PostScript file should never contain more
than one page.</doc>
      <source-position filename="cairo-ps.h" line="89"/>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="surface" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cairo-ps-surface.c"
               line="1435">a PostScript #cairo_surface_t</doc>
          <type name="Surface" c:type="cairo_surface_t*"/>
        </parameter>
        <parameter name="eps" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cairo-ps-surface.c"
               line="1436">%TRUE to output EPS format PostScript</doc>
          <type name="Bool" c:type="cairo_bool_t"/>
        </parameter>
      </parameters>
    </function>
    <function name="ps_surface_set_size"
              c:identifier="cairo_ps_surface_set_size"
              version="1.2">
      <doc xml:space="preserve"
           filename="cairo-ps-surface.c"
           line="1482">Changes the size of a PostScript surface for the current (and
subsequent) pages.

This function should only be called before any drawing operations
have been performed on the current page. The simplest way to do
this is to call this function immediately after creating the
surface or immediately after completing a page with either
cairo_show_page() or cairo_copy_page().</doc>
      <source-position filename="cairo-ps.h" line="96"/>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="surface" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cairo-ps-surface.c"
               line="1484">a PostScript #cairo_surface_t</doc>
          <type name="Surface" c:type="cairo_surface_t*"/>
        </parameter>
        <parameter name="width_in_points" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cairo-ps-surface.c"
               line="1485">new surface width, in points (1 point == 1/72.0 inch)</doc>
          <type name="gdouble" c:type="double"/>
        </parameter>
        <parameter name="height_in_points" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cairo-ps-surface.c"
               line="1486">new surface height, in points (1 point == 1/72.0 inch)</doc>
          <type name="gdouble" c:type="double"/>
        </parameter>
      </parameters>
    </function>
    <function name="raster_source_pattern_get_acquire"
              c:identifier="cairo_raster_source_pattern_get_acquire"
              version="1.12"
              introspectable="0">
      <doc xml:space="preserve"
           filename="cairo-raster-source-pattern.c"
           line="269">Queries the current acquire and release callbacks.</doc>
      <source-position filename="cairo.h" line="2883"/>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="pattern" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cairo-raster-source-pattern.c"
               line="271">the pattern to query</doc>
          <type name="Pattern" c:type="cairo_pattern_t*"/>
        </parameter>
        <parameter name="acquire" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cairo-raster-source-pattern.c"
               line="272">return value for the current acquire callback</doc>
          <type name="RasterSourceAcquireFunc"
                c:type="cairo_raster_source_acquire_func_t*"/>
        </parameter>
        <parameter name="release" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cairo-raster-source-pattern.c"
               line="273">return value for the current release callback</doc>
          <type name="RasterSourceReleaseFunc"
                c:type="cairo_raster_source_release_func_t*"/>
        </parameter>
      </parameters>
    </function>
    <function name="raster_source_pattern_get_callback_data"
              c:identifier="cairo_raster_source_pattern_get_callback_data"
              version="1.12">
      <doc xml:space="preserve"
           filename="cairo-raster-source-pattern.c"
           line="213">Queries the current user data.</doc>
      <source-position filename="cairo.h" line="2875"/>
      <return-value transfer-ownership="none" nullable="1">
        <doc xml:space="preserve"
             filename="cairo-raster-source-pattern.c"
             line="219">the current user-data passed to each callback</doc>
        <type name="gpointer" c:type="void*"/>
      </return-value>
      <parameters>
        <parameter name="pattern" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cairo-raster-source-pattern.c"
               line="215">the pattern to update</doc>
          <type name="Pattern" c:type="cairo_pattern_t*"/>
        </parameter>
      </parameters>
    </function>
    <function name="raster_source_pattern_get_copy"
              c:identifier="cairo_raster_source_pattern_get_copy"
              version="1.12"
              introspectable="0">
      <doc xml:space="preserve"
           filename="cairo-raster-source-pattern.c"
           line="365">Queries the current copy callback.</doc>
      <source-position filename="cairo.h" line="2898"/>
      <return-value>
        <doc xml:space="preserve"
             filename="cairo-raster-source-pattern.c"
             line="371">the current copy callback</doc>
        <type name="RasterSourceCopyFunc"
              c:type="cairo_raster_source_copy_func_t"/>
      </return-value>
      <parameters>
        <parameter name="pattern" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cairo-raster-source-pattern.c"
               line="367">the pattern to query</doc>
          <type name="Pattern" c:type="cairo_pattern_t*"/>
        </parameter>
      </parameters>
    </function>
    <function name="raster_source_pattern_get_finish"
              c:identifier="cairo_raster_source_pattern_get_finish"
              version="1.12"
              introspectable="0">
      <doc xml:space="preserve"
           filename="cairo-raster-source-pattern.c"
           line="410">Queries the current finish callback.</doc>
      <source-position filename="cairo.h" line="2905"/>
      <return-value>
        <doc xml:space="preserve"
             filename="cairo-raster-source-pattern.c"
             line="416">the current finish callback</doc>
        <type name="RasterSourceFinishFunc"
              c:type="cairo_raster_source_finish_func_t"/>
      </return-value>
      <parameters>
        <parameter name="pattern" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cairo-raster-source-pattern.c"
               line="412">the pattern to query</doc>
          <type name="Pattern" c:type="cairo_pattern_t*"/>
        </parameter>
      </parameters>
    </function>
    <function name="raster_source_pattern_get_snapshot"
              c:identifier="cairo_raster_source_pattern_get_snapshot"
              version="1.12"
              introspectable="0">
      <doc xml:space="preserve"
           filename="cairo-raster-source-pattern.c"
           line="320">Queries the current snapshot callback.</doc>
      <source-position filename="cairo.h" line="2891"/>
      <return-value>
        <doc xml:space="preserve"
             filename="cairo-raster-source-pattern.c"
             line="326">the current snapshot callback</doc>
        <type name="RasterSourceSnapshotFunc"
              c:type="cairo_raster_source_snapshot_func_t"/>
      </return-value>
      <parameters>
        <parameter name="pattern" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cairo-raster-source-pattern.c"
               line="322">the pattern to query</doc>
          <type name="Pattern" c:type="cairo_pattern_t*"/>
        </parameter>
      </parameters>
    </function>
    <function name="raster_source_pattern_set_acquire"
              c:identifier="cairo_raster_source_pattern_set_acquire"
              version="1.12"
              introspectable="0">
      <doc xml:space="preserve"
           filename="cairo-raster-source-pattern.c"
           line="235">Specifies the callbacks used to generate the image surface for a rendering
operation (acquire) and the function used to cleanup that surface afterwards.

The @acquire callback should create a surface (preferably an image
surface created to match the target using
cairo_surface_create_similar_image()) that defines at least the region
of interest specified by extents. The surface is allowed to be the entire
sample area, but if it does contain a subsection of the sample area,
the surface extents should be provided by setting the device offset (along
with its width and height) using cairo_surface_set_device_offset().</doc>
      <source-position filename="cairo.h" line="2878"/>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="pattern" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cairo-raster-source-pattern.c"
               line="237">the pattern to update</doc>
          <type name="Pattern" c:type="cairo_pattern_t*"/>
        </parameter>
        <parameter name="acquire" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cairo-raster-source-pattern.c"
               line="238">acquire callback</doc>
          <type name="RasterSourceAcquireFunc"
                c:type="cairo_raster_source_acquire_func_t"/>
        </parameter>
        <parameter name="release" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cairo-raster-source-pattern.c"
               line="239">release callback</doc>
          <type name="RasterSourceReleaseFunc"
                c:type="cairo_raster_source_release_func_t"/>
        </parameter>
      </parameters>
    </function>
    <function name="raster_source_pattern_set_callback_data"
              c:identifier="cairo_raster_source_pattern_set_callback_data"
              version="1.12">
      <doc xml:space="preserve"
           filename="cairo-raster-source-pattern.c"
           line="191">Updates the user data that is provided to all callbacks.</doc>
      <source-position filename="cairo.h" line="2871"/>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="pattern" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cairo-raster-source-pattern.c"
               line="193">the pattern to update</doc>
          <type name="Pattern" c:type="cairo_pattern_t*"/>
        </parameter>
        <parameter name="data"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1">
          <doc xml:space="preserve"
               filename="cairo-raster-source-pattern.c"
               line="194">the user data to be passed to all callbacks</doc>
          <type name="gpointer" c:type="void*"/>
        </parameter>
      </parameters>
    </function>
    <function name="raster_source_pattern_set_copy"
              c:identifier="cairo_raster_source_pattern_set_copy"
              version="1.12"
              introspectable="0">
      <doc xml:space="preserve"
           filename="cairo-raster-source-pattern.c"
           line="342">Updates the copy callback which is used whenever a temporary copy of the
pattern is taken.</doc>
      <source-position filename="cairo.h" line="2894"/>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="pattern" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cairo-raster-source-pattern.c"
               line="344">the pattern to update</doc>
          <type name="Pattern" c:type="cairo_pattern_t*"/>
        </parameter>
        <parameter name="copy" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cairo-raster-source-pattern.c"
               line="345">the copy callback</doc>
          <type name="RasterSourceCopyFunc"
                c:type="cairo_raster_source_copy_func_t"/>
        </parameter>
      </parameters>
    </function>
    <function name="raster_source_pattern_set_finish"
              c:identifier="cairo_raster_source_pattern_set_finish"
              version="1.12"
              introspectable="0">
      <doc xml:space="preserve"
           filename="cairo-raster-source-pattern.c"
           line="387">Updates the finish callback which is used whenever a pattern (or a copy
thereof) will no longer be used.</doc>
      <source-position filename="cairo.h" line="2901"/>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="pattern" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cairo-raster-source-pattern.c"
               line="389">the pattern to update</doc>
          <type name="Pattern" c:type="cairo_pattern_t*"/>
        </parameter>
        <parameter name="finish" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cairo-raster-source-pattern.c"
               line="390">the finish callback</doc>
          <type name="RasterSourceFinishFunc"
                c:type="cairo_raster_source_finish_func_t"/>
        </parameter>
      </parameters>
    </function>
    <function name="raster_source_pattern_set_snapshot"
              c:identifier="cairo_raster_source_pattern_set_snapshot"
              version="1.12"
              introspectable="0">
      <doc xml:space="preserve"
           filename="cairo-raster-source-pattern.c"
           line="296">Sets the callback that will be used whenever a snapshot is taken of the
pattern, that is whenever the current contents of the pattern should be
preserved for later use. This is typically invoked whilst printing.</doc>
      <source-position filename="cairo.h" line="2887"/>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="pattern" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cairo-raster-source-pattern.c"
               line="298">the pattern to update</doc>
          <type name="Pattern" c:type="cairo_pattern_t*"/>
        </parameter>
        <parameter name="snapshot" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cairo-raster-source-pattern.c"
               line="299">snapshot callback</doc>
          <type name="RasterSourceSnapshotFunc"
                c:type="cairo_raster_source_snapshot_func_t"/>
        </parameter>
      </parameters>
    </function>
    <function name="recording_surface_create"
              c:identifier="cairo_recording_surface_create"
              version="1.10">
      <doc xml:space="preserve"
           filename="cairo-recording-surface.c"
           line="375">Creates a recording-surface which can be used to record all drawing operations
at the highest level (that is, the level of paint, mask, stroke, fill
and show_text_glyphs). The recording surface can then be "replayed" against
any target surface by using it as a source to drawing operations.

The recording phase of the recording surface is careful to snapshot all
necessary objects (paths, patterns, etc.), in order to achieve
accurate replay.</doc>
      <source-position filename="cairo.h" line="2748"/>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve"
             filename="cairo-recording-surface.c"
             line="390">a pointer to the newly created surface. The caller
owns the surface and should call cairo_surface_destroy() when done
with it.</doc>
        <type name="Surface" c:type="cairo_surface_t*"/>
      </return-value>
      <parameters>
        <parameter name="content" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cairo-recording-surface.c"
               line="377">the content of the recording surface</doc>
          <type name="Content" c:type="cairo_content_t"/>
        </parameter>
        <parameter name="extents" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cairo-recording-surface.c"
               line="378">the extents to record in pixels, can be %NULL to record
          unbounded operations.</doc>
          <type name="Rectangle" c:type="const cairo_rectangle_t*"/>
        </parameter>
      </parameters>
    </function>
    <function name="recording_surface_get_extents"
              c:identifier="cairo_recording_surface_get_extents"
              version="1.12">
      <doc xml:space="preserve"
           filename="cairo-recording-surface.c"
           line="2704">Get the extents of the recording-surface.</doc>
      <source-position filename="cairo.h" line="2759"/>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve"
             filename="cairo-recording-surface.c"
             line="2711">%TRUE if the surface is bounded, of recording type, and
not in an error state, otherwise %FALSE</doc>
        <type name="Bool" c:type="cairo_bool_t"/>
      </return-value>
      <parameters>
        <parameter name="surface" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cairo-recording-surface.c"
               line="2706">a #cairo_recording_surface_t</doc>
          <type name="Surface" c:type="cairo_surface_t*"/>
        </parameter>
        <parameter name="extents" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cairo-recording-surface.c"
               line="2707">the #cairo_rectangle_t to be assigned the extents</doc>
          <type name="Rectangle" c:type="cairo_rectangle_t*"/>
        </parameter>
      </parameters>
    </function>
    <function name="recording_surface_ink_extents"
              c:identifier="cairo_recording_surface_ink_extents"
              version="1.10">
      <doc xml:space="preserve"
           filename="cairo-recording-surface.c"
           line="2632">Measures the extents of the operations stored within the recording-surface.
This is useful to compute the required size of an image surface (or
equivalent) into which to replay the full sequence of drawing operations.</doc>
      <source-position filename="cairo.h" line="2752"/>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="surface" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cairo-recording-surface.c"
               line="2634">a #cairo_recording_surface_t</doc>
          <type name="Surface" c:type="cairo_surface_t*"/>
        </parameter>
        <parameter name="x0" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cairo-recording-surface.c"
               line="2635">the x-coordinate of the top-left of the ink bounding box</doc>
          <type name="gdouble" c:type="double*"/>
        </parameter>
        <parameter name="y0" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cairo-recording-surface.c"
               line="2636">the y-coordinate of the top-left of the ink bounding box</doc>
          <type name="gdouble" c:type="double*"/>
        </parameter>
        <parameter name="width" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cairo-recording-surface.c"
               line="2637">the width of the ink bounding box</doc>
          <type name="gdouble" c:type="double*"/>
        </parameter>
        <parameter name="height" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cairo-recording-surface.c"
               line="2638">the height of the ink bounding box</doc>
          <type name="gdouble" c:type="double*"/>
        </parameter>
      </parameters>
    </function>
    <function name="reference"
              c:identifier="cairo_reference"
              version="1.0"
              introspectable="0">
      <doc xml:space="preserve"
           filename="cairo.c"
           line="473">Increases the reference count on @cr by one. This prevents
@cr from being destroyed until a matching call to cairo_destroy()
is made.

Use cairo_get_reference_count() to get the number of references to
a #cairo_t.</doc>
      <source-position filename="cairo.h" line="543"/>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve"
             filename="cairo.c"
             line="484">the referenced #cairo_t.</doc>
        <type name="Context" c:type="cairo_t*"/>
      </return-value>
      <parameters>
        <parameter name="cr" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cairo.c"
               line="475">a #cairo_t</doc>
          <type name="Context" c:type="cairo_t*"/>
        </parameter>
      </parameters>
    </function>
    <function name="region_create"
              c:identifier="cairo_region_create"
              version="1.10">
      <doc xml:space="preserve"
           filename="cairo-region.c"
           line="187">Allocates a new empty region object.</doc>
      <source-position filename="cairo.h" line="3258"/>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve"
             filename="cairo-region.c"
             line="192">A newly allocated #cairo_region_t. Free with
  cairo_region_destroy(). This function always returns a
  valid pointer; if memory cannot be allocated, then a special
  error object is returned where all operations on the object do nothing.
  You can check for this with cairo_region_status().</doc>
        <type name="Region" c:type="cairo_region_t*"/>
      </return-value>
    </function>
    <function name="region_create_rectangle"
              c:identifier="cairo_region_create_rectangle"
              version="1.10">
      <doc xml:space="preserve"
           filename="cairo-region.c"
           line="316">Allocates a new region object containing @rectangle.</doc>
      <source-position filename="cairo.h" line="3261"/>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve"
             filename="cairo-region.c"
             line="322">A newly allocated #cairo_region_t. Free with
  cairo_region_destroy(). This function always returns a
  valid pointer; if memory cannot be allocated, then a special
  error object is returned where all operations on the object do nothing.
  You can check for this with cairo_region_status().</doc>
        <type name="Region" c:type="cairo_region_t*"/>
      </return-value>
      <parameters>
        <parameter name="rectangle" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cairo-region.c"
               line="318">a #cairo_rectangle_int_t</doc>
          <type name="RectangleInt" c:type="const cairo_rectangle_int_t*"/>
        </parameter>
      </parameters>
    </function>
    <function name="region_create_rectangles"
              c:identifier="cairo_region_create_rectangles"
              version="1.10">
      <doc xml:space="preserve"
           filename="cairo-region.c"
           line="217">Allocates a new region object containing the union of all given @rects.</doc>
      <source-position filename="cairo.h" line="3264"/>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve"
             filename="cairo-region.c"
             line="224">A newly allocated #cairo_region_t. Free with
  cairo_region_destroy(). This function always returns a
  valid pointer; if memory cannot be allocated, then a special
  error object is returned where all operations on the object do nothing.
  You can check for this with cairo_region_status().</doc>
        <type name="Region" c:type="cairo_region_t*"/>
      </return-value>
      <parameters>
        <parameter name="rects" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cairo-region.c"
               line="219">an array of @count rectangles</doc>
          <type name="RectangleInt" c:type="const cairo_rectangle_int_t*"/>
        </parameter>
        <parameter name="count" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cairo-region.c"
               line="220">number of rectangles</doc>
          <type name="gint" c:type="int"/>
        </parameter>
      </parameters>
    </function>
    <function name="scaled_font_create"
              c:identifier="cairo_scaled_font_create"
              version="1.0">
      <doc xml:space="preserve"
           filename="cairo-scaled-font.c"
           line="1020">Creates a #cairo_scaled_font_t object from a font face and matrices that
describe the size of the font and the environment in which it will
be used.</doc>
      <source-position filename="cairo.h" line="1697"/>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve"
             filename="cairo-scaled-font.c"
             line="1037">a newly created #cairo_scaled_font_t. Destroy with
 cairo_scaled_font_destroy()</doc>
        <type name="ScaledFont" c:type="cairo_scaled_font_t*"/>
      </return-value>
      <parameters>
        <parameter name="font_face" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cairo-scaled-font.c"
               line="1022">a #cairo_font_face_t</doc>
          <type name="FontFace" c:type="cairo_font_face_t*"/>
        </parameter>
        <parameter name="font_matrix" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cairo-scaled-font.c"
               line="1023">font space to user space transformation matrix for the
      font. In the simplest case of a N point font, this matrix is
      just a scale by N, but it can also be used to shear the font
      or stretch it unequally along the two axes. See
      cairo_set_font_matrix().</doc>
          <type name="Matrix" c:type="const cairo_matrix_t*"/>
        </parameter>
        <parameter name="ctm" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cairo-scaled-font.c"
               line="1028">user to device transformation matrix with which the font will
      be used.</doc>
          <type name="Matrix" c:type="const cairo_matrix_t*"/>
        </parameter>
        <parameter name="options" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cairo-scaled-font.c"
               line="1030">options to use when getting metrics for the font and
          rendering with it.</doc>
          <type name="FontOptions" c:type="const cairo_font_options_t*"/>
        </parameter>
      </parameters>
    </function>
    <function name="script_create"
              c:identifier="cairo_script_create"
              version="1.12">
      <doc xml:space="preserve"
           filename="cairo-script-surface.c"
           line="3826">Creates a output device for emitting the script, used when
creating the individual surfaces.</doc>
      <source-position filename="cairo-script.h" line="60"/>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve"
             filename="cairo-script-surface.c"
             line="3833">a pointer to the newly created device. The caller
owns the surface and should call cairo_device_destroy() when done
with it.

This function always returns a valid pointer, but it will return a
pointer to a "nil" device if an error such as out of memory
occurs. You can use cairo_device_status() to check for this.</doc>
        <type name="Device" c:type="cairo_device_t*"/>
      </return-value>
      <parameters>
        <parameter name="filename" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cairo-script-surface.c"
               line="3828">the name (path) of the file to write the script to</doc>
          <type name="utf8" c:type="const char*"/>
        </parameter>
      </parameters>
    </function>
    <function name="script_create_for_stream"
              c:identifier="cairo_script_create_for_stream"
              version="1.12">
      <doc xml:space="preserve"
           filename="cairo-script-surface.c"
           line="3856">Creates a output device for emitting the script, used when
creating the individual surfaces.</doc>
      <source-position filename="cairo-script.h" line="63"/>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve"
             filename="cairo-script-surface.c"
             line="3864">a pointer to the newly created device. The caller
owns the surface and should call cairo_device_destroy() when done
with it.

This function always returns a valid pointer, but it will return a
pointer to a "nil" device if an error such as out of memory
occurs. You can use cairo_device_status() to check for this.</doc>
        <type name="Device" c:type="cairo_device_t*"/>
      </return-value>
      <parameters>
        <parameter name="write_func" transfer-ownership="none" scope="call">
          <doc xml:space="preserve"
               filename="cairo-script-surface.c"
               line="3858">callback function passed the bytes written to the script</doc>
          <type name="WriteFunc" c:type="cairo_write_func_t"/>
        </parameter>
        <parameter name="closure"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1">
          <doc xml:space="preserve"
               filename="cairo-script-surface.c"
               line="3859">user data to be passed to the callback</doc>
          <type name="gpointer" c:type="void*"/>
        </parameter>
      </parameters>
    </function>
    <function name="script_from_recording_surface"
              c:identifier="cairo_script_from_recording_surface"
              version="1.12">
      <doc xml:space="preserve"
           filename="cairo-script-surface.c"
           line="4040">Converts the record operations in @recording_surface into a script.</doc>
      <source-position filename="cairo-script.h" line="89"/>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve"
             filename="cairo-script-surface.c"
             line="4047">#CAIRO_STATUS_SUCCESS on successful completion or an error code.</doc>
        <type name="Status" c:type="cairo_status_t"/>
      </return-value>
      <parameters>
        <parameter name="script" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cairo-script-surface.c"
               line="4042">the script (output device)</doc>
          <type name="Device" c:type="cairo_device_t*"/>
        </parameter>
        <parameter name="recording_surface" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cairo-script-surface.c"
               line="4043">the recording surface to replay</doc>
          <type name="Surface" c:type="cairo_surface_t*"/>
        </parameter>
      </parameters>
    </function>
    <function name="script_get_mode"
              c:identifier="cairo_script_get_mode"
              version="1.12">
      <doc xml:space="preserve"
           filename="cairo-script-surface.c"
           line="3931">Queries the script for its current output mode.</doc>
      <source-position filename="cairo-script.h" line="76"/>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve"
             filename="cairo-script-surface.c"
             line="3937">the current output mode of the script</doc>
        <type name="ScriptMode" c:type="cairo_script_mode_t"/>
      </return-value>
      <parameters>
        <parameter name="script" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cairo-script-surface.c"
               line="3933">The script (output device) to query</doc>
          <type name="Device" c:type="cairo_device_t*"/>
        </parameter>
      </parameters>
    </function>
    <function name="script_set_mode"
              c:identifier="cairo_script_set_mode"
              version="1.12">
      <doc xml:space="preserve"
           filename="cairo-script-surface.c"
           line="3913">Change the output mode of the script</doc>
      <source-position filename="cairo-script.h" line="72"/>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="script" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cairo-script-surface.c"
               line="3915">The script (output device)</doc>
          <type name="Device" c:type="cairo_device_t*"/>
        </parameter>
        <parameter name="mode" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cairo-script-surface.c"
               line="3916">the new mode</doc>
          <type name="ScriptMode" c:type="cairo_script_mode_t"/>
        </parameter>
      </parameters>
    </function>
    <function name="script_surface_create"
              c:identifier="cairo_script_surface_create"
              version="1.12">
      <doc xml:space="preserve"
           filename="cairo-script-surface.c"
           line="3949">Create a new surface that will emit its rendering through @script</doc>
      <source-position filename="cairo-script.h" line="79"/>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve"
             filename="cairo-script-surface.c"
             line="3958">a pointer to the newly created surface. The caller
owns the surface and should call cairo_surface_destroy() when done
with it.

This function always returns a valid pointer, but it will return a
pointer to a "nil" surface if an error such as out of memory
occurs. You can use cairo_surface_status() to check for this.</doc>
        <type name="Surface" c:type="cairo_surface_t*"/>
      </return-value>
      <parameters>
        <parameter name="script" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cairo-script-surface.c"
               line="3951">the script (output device)</doc>
          <type name="Device" c:type="cairo_device_t*"/>
        </parameter>
        <parameter name="content" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cairo-script-surface.c"
               line="3952">the content of the surface</doc>
          <type name="Content" c:type="cairo_content_t"/>
        </parameter>
        <parameter name="width" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cairo-script-surface.c"
               line="3953">width in pixels</doc>
          <type name="gdouble" c:type="double"/>
        </parameter>
        <parameter name="height" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cairo-script-surface.c"
               line="3954">height in pixels</doc>
          <type name="gdouble" c:type="double"/>
        </parameter>
      </parameters>
    </function>
    <function name="script_surface_create_for_target"
              c:identifier="cairo_script_surface_create_for_target"
              version="1.12">
      <doc xml:space="preserve"
           filename="cairo-script-surface.c"
           line="3994">Create a pxoy surface that will render to @target and record
the operations to @device.</doc>
      <source-position filename="cairo-script.h" line="85"/>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve"
             filename="cairo-script-surface.c"
             line="4002">a pointer to the newly created surface. The caller
owns the surface and should call cairo_surface_destroy() when done
with it.

This function always returns a valid pointer, but it will return a
pointer to a "nil" surface if an error such as out of memory
occurs. You can use cairo_surface_status() to check for this.</doc>
        <type name="Surface" c:type="cairo_surface_t*"/>
      </return-value>
      <parameters>
        <parameter name="script" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cairo-script-surface.c"
               line="3996">the script (output device)</doc>
          <type name="Device" c:type="cairo_device_t*"/>
        </parameter>
        <parameter name="target" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cairo-script-surface.c"
               line="3997">a target surface to wrap</doc>
          <type name="Surface" c:type="cairo_surface_t*"/>
        </parameter>
      </parameters>
    </function>
    <function name="script_write_comment"
              c:identifier="cairo_script_write_comment"
              version="1.12">
      <doc xml:space="preserve"
           filename="cairo-script-surface.c"
           line="3888">Emit a string verbatim into the script.</doc>
      <source-position filename="cairo-script.h" line="67"/>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="script" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cairo-script-surface.c"
               line="3890">the script (output device)</doc>
          <type name="Device" c:type="cairo_device_t*"/>
        </parameter>
        <parameter name="comment" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cairo-script-surface.c"
               line="3891">the string to emit</doc>
          <type name="utf8" c:type="const char*"/>
        </parameter>
        <parameter name="len" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cairo-script-surface.c"
               line="3892">the length of the string to write, or -1 to use strlen()</doc>
          <type name="gint" c:type="int"/>
        </parameter>
      </parameters>
    </function>
    <function name="set_user_data"
              c:identifier="cairo_set_user_data"
              version="1.4"
              introspectable="0">
      <doc xml:space="preserve"
           filename="cairo.c"
           line="552">Attach user data to @cr.  To remove user data from a surface,
call this function with the key that was used to set it and %NULL
for @data.</doc>
      <source-position filename="cairo.h" line="556"/>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve"
             filename="cairo.c"
             line="565">%CAIRO_STATUS_SUCCESS or %CAIRO_STATUS_NO_MEMORY if a
slot could not be allocated for the user data.</doc>
        <type name="Status" c:type="cairo_status_t"/>
      </return-value>
      <parameters>
        <parameter name="cr" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cairo.c"
               line="554">a #cairo_t</doc>
          <type name="Context" c:type="cairo_t*"/>
        </parameter>
        <parameter name="key" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cairo.c"
               line="555">the address of a #cairo_user_data_key_t to attach the user data to</doc>
          <type name="UserDataKey" c:type="const cairo_user_data_key_t*"/>
        </parameter>
        <parameter name="user_data"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1">
          <doc xml:space="preserve"
               filename="cairo.c"
               line="556">the user data to attach to the #cairo_t</doc>
          <type name="gpointer" c:type="void*"/>
        </parameter>
        <parameter name="destroy" transfer-ownership="none" scope="async">
          <doc xml:space="preserve"
               filename="cairo.c"
               line="557">a #cairo_destroy_func_t which will be called when the
#cairo_t is destroyed or when new user data is attached using the
same key.</doc>
          <type name="DestroyFunc" c:type="cairo_destroy_func_t"/>
        </parameter>
      </parameters>
    </function>
    <function name="status_to_string"
              c:identifier="cairo_status_to_string"
              version="1.0">
      <doc xml:space="preserve"
           filename="cairo-misc.c"
           line="77">Provides a human-readable description of a #cairo_status_t.</doc>
      <source-position filename="cairo.h" line="2264"/>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve"
             filename="cairo-misc.c"
             line="83">a string representation of the status</doc>
        <type name="utf8" c:type="const char*"/>
      </return-value>
      <parameters>
        <parameter name="status" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cairo-misc.c"
               line="79">a cairo status</doc>
          <type name="Status" c:type="cairo_status_t"/>
        </parameter>
      </parameters>
    </function>
    <function name="svg_get_versions"
              c:identifier="cairo_svg_get_versions"
              version="1.2">
      <doc xml:space="preserve"
           filename="cairo-svg-surface.c"
           line="756">Used to retrieve the list of supported versions. See
cairo_svg_surface_restrict_to_version().</doc>
      <source-position filename="cairo-svg.h" line="111"/>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="versions" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cairo-svg-surface.c"
               line="758">supported version list</doc>
          <type name="SvgVersion" c:type="const cairo_svg_version_t**"/>
        </parameter>
        <parameter name="num_versions" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cairo-svg-surface.c"
               line="759">list length</doc>
          <type name="gint" c:type="int*"/>
        </parameter>
      </parameters>
    </function>
    <function name="svg_surface_create"
              c:identifier="cairo_svg_surface_create"
              version="1.2">
      <doc xml:space="preserve"
           filename="cairo-svg-surface.c"
           line="626">Creates a SVG surface of the specified size in points to be written
to @filename.

The SVG surface backend recognizes the following MIME types for the
data attached to a surface (see cairo_surface_set_mime_data()) when
it is used as a source pattern for drawing on this surface:
%CAIRO_MIME_TYPE_JPEG, %CAIRO_MIME_TYPE_PNG,
%CAIRO_MIME_TYPE_URI. If any of them is specified, the SVG backend
emits a href with the content of MIME data instead of a surface
snapshot (PNG, Base64-encoded) in the corresponding image tag.

The unofficial MIME type %CAIRO_MIME_TYPE_URI is examined
first. If present, the URI is emitted as is: assuring the
correctness of URI is left to the client code.

If %CAIRO_MIME_TYPE_URI is not present, but %CAIRO_MIME_TYPE_JPEG
or %CAIRO_MIME_TYPE_PNG is specified, the corresponding data is
Base64-encoded and emitted.

If %CAIRO_MIME_TYPE_UNIQUE_ID is present, all surfaces with the same
unique identifier will only be embedded once.</doc>
      <source-position filename="cairo-svg.h" line="96"/>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve"
             filename="cairo-svg-surface.c"
             line="657">a pointer to the newly created surface. The caller
owns the surface and should call cairo_surface_destroy() when done
with it.

This function always returns a valid pointer, but it will return a
pointer to a "nil" surface if an error such as out of memory
occurs. You can use cairo_surface_status() to check for this.</doc>
        <type name="Surface" c:type="cairo_surface_t*"/>
      </return-value>
      <parameters>
        <parameter name="filename" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cairo-svg-surface.c"
               line="628">a filename for the SVG output (must be writable), %NULL may be
           used to specify no output. This will generate a SVG surface that
           may be queried and used as a source, without generating a
           temporary file.</doc>
          <type name="utf8" c:type="const char*"/>
        </parameter>
        <parameter name="width_in_points" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cairo-svg-surface.c"
               line="632">width of the surface, in points (1 point == 1/72.0 inch)</doc>
          <type name="gdouble" c:type="double"/>
        </parameter>
        <parameter name="height_in_points" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cairo-svg-surface.c"
               line="633">height of the surface, in points (1 point == 1/72.0 inch)</doc>
          <type name="gdouble" c:type="double"/>
        </parameter>
      </parameters>
    </function>
    <function name="svg_surface_create_for_stream"
              c:identifier="cairo_svg_surface_create_for_stream"
              version="1.2">
      <doc xml:space="preserve"
           filename="cairo-svg-surface.c"
           line="588">Creates a SVG surface of the specified size in points to be written
incrementally to the stream represented by @write_func and @closure.</doc>
      <source-position filename="cairo-svg.h" line="101"/>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve"
             filename="cairo-svg-surface.c"
             line="601">a pointer to the newly created surface. The caller
owns the surface and should call cairo_surface_destroy() when done
with it.

This function always returns a valid pointer, but it will return a
pointer to a "nil" surface if an error such as out of memory
occurs. You can use cairo_surface_status() to check for this.</doc>
        <type name="Surface" c:type="cairo_surface_t*"/>
      </return-value>
      <parameters>
        <parameter name="write_func" transfer-ownership="none" scope="call">
          <doc xml:space="preserve"
               filename="cairo-svg-surface.c"
               line="590">a #cairo_write_func_t to accept the output data, may be %NULL
             to indicate a no-op @write_func. With a no-op @write_func,
             the surface may be queried or used as a source without
             generating any temporary files.</doc>
          <type name="WriteFunc" c:type="cairo_write_func_t"/>
        </parameter>
        <parameter name="closure"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1">
          <doc xml:space="preserve"
               filename="cairo-svg-surface.c"
               line="594">the closure argument for @write_func</doc>
          <type name="gpointer" c:type="void*"/>
        </parameter>
        <parameter name="width_in_points" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cairo-svg-surface.c"
               line="595">width of the surface, in points (1 point == 1/72.0 inch)</doc>
          <type name="gdouble" c:type="double"/>
        </parameter>
        <parameter name="height_in_points" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cairo-svg-surface.c"
               line="596">height of the surface, in points (1 point == 1/72.0 inch)</doc>
          <type name="gdouble" c:type="double"/>
        </parameter>
      </parameters>
    </function>
    <function name="svg_surface_get_document_unit"
              c:identifier="cairo_svg_surface_get_document_unit"
              version="1.16">
      <doc xml:space="preserve"
           filename="cairo-svg-surface.c"
           line="834">Get the unit of the SVG surface.

If the surface passed as an argument is not a SVG surface, the function
sets the error status to CAIRO_STATUS_SURFACE_TYPE_MISMATCH and returns
CAIRO_SVG_UNIT_USER.</doc>
      <source-position filename="cairo-svg.h" line="122"/>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve"
             filename="cairo-svg-surface.c"
             line="844">the SVG unit of the SVG surface.</doc>
        <type name="SvgUnit" c:type="cairo_svg_unit_t"/>
      </return-value>
      <parameters>
        <parameter name="surface" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cairo-svg-surface.c"
               line="836">a SVG #cairo_surface_t</doc>
          <type name="Surface" c:type="cairo_surface_t*"/>
        </parameter>
      </parameters>
    </function>
    <function name="svg_surface_restrict_to_version"
              c:identifier="cairo_svg_surface_restrict_to_version"
              version="1.2">
      <doc xml:space="preserve"
           filename="cairo-svg-surface.c"
           line="728">Restricts the generated SVG file to @version. See cairo_svg_get_versions()
for a list of available version values that can be used here.

This function should only be called before any drawing operations
have been performed on the given surface. The simplest way to do
this is to call this function immediately after creating the
surface.</doc>
      <source-position filename="cairo-svg.h" line="107"/>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="surface" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cairo-svg-surface.c"
               line="730">a SVG #cairo_surface_t</doc>
          <type name="Surface" c:type="cairo_surface_t*"/>
        </parameter>
        <parameter name="version" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cairo-svg-surface.c"
               line="731">SVG version</doc>
          <type name="SvgVersion" c:type="cairo_svg_version_t"/>
        </parameter>
      </parameters>
    </function>
    <function name="svg_surface_set_document_unit"
              c:identifier="cairo_svg_surface_set_document_unit"
              version="1.16">
      <doc xml:space="preserve"
           filename="cairo-svg-surface.c"
           line="798">Use the specified unit for the width and height of the generated SVG file.
See #cairo_svg_unit_t for a list of available unit values that can be used
here.

This function can be called at any time before generating the SVG file.

However to minimize the risk of ambiguities it's recommended to call it
before any drawing operations have been performed on the given surface, to
make it clearer what the unit used in the drawing operations is.

The simplest way to do this is to call this function immediately after
creating the SVG surface.

Note if this function is never called, the default unit for SVG documents
generated by cairo will be user unit.</doc>
      <source-position filename="cairo-svg.h" line="118"/>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="surface" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cairo-svg-surface.c"
               line="800">a SVG #cairo_surface_t</doc>
          <type name="Surface" c:type="cairo_surface_t*"/>
        </parameter>
        <parameter name="unit" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cairo-svg-surface.c"
               line="801">SVG unit</doc>
          <type name="SvgUnit" c:type="cairo_svg_unit_t"/>
        </parameter>
      </parameters>
    </function>
    <function name="svg_version_to_string"
              c:identifier="cairo_svg_version_to_string"
              version="1.2">
      <doc xml:space="preserve"
           filename="cairo-svg-surface.c"
           line="777">Get the string representation of the given @version id. This function
will return %NULL if @version isn't valid. See cairo_svg_get_versions()
for a way to get the list of valid version ids.</doc>
      <source-position filename="cairo-svg.h" line="115"/>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve"
             filename="cairo-svg-surface.c"
             line="785">the string associated to given version.</doc>
        <type name="utf8" c:type="const char*"/>
      </return-value>
      <parameters>
        <parameter name="version" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cairo-svg-surface.c"
               line="779">a version id</doc>
          <type name="SvgVersion" c:type="cairo_svg_version_t"/>
        </parameter>
      </parameters>
    </function>
    <function name="tee_surface_add"
              c:identifier="cairo_tee_surface_add"
              version="1.10">
      <doc xml:space="preserve"
           filename="cairo-tee-surface.c"
           line="478">Adds a new target surface to the list of replicas of a
tee surface.</doc>
      <source-position filename="cairo-tee.h" line="49"/>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="abstract_surface" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cairo-tee-surface.c"
               line="480">a #cairo_tee_surface_t</doc>
          <type name="Surface" c:type="cairo_surface_t*"/>
        </parameter>
        <parameter name="target" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cairo-tee-surface.c"
               line="481">the surface to add</doc>
          <type name="Surface" c:type="cairo_surface_t*"/>
        </parameter>
      </parameters>
    </function>
    <function name="tee_surface_create"
              c:identifier="cairo_tee_surface_create"
              version="1.10">
      <doc xml:space="preserve"
           filename="cairo-tee-surface.c"
           line="437">Creates a new "tee" surface.

The @primary surface is used when querying surface options, like
font options and extents.

Operations performed on the tee surface will be replayed on any
surface added to it.</doc>
      <source-position filename="cairo-tee.h" line="46"/>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve"
             filename="cairo-tee-surface.c"
             line="449">the newly created surface</doc>
        <type name="Surface" c:type="cairo_surface_t*"/>
      </return-value>
      <parameters>
        <parameter name="primary" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cairo-tee-surface.c"
               line="439">the primary #cairo_surface_t</doc>
          <type name="Surface" c:type="cairo_surface_t*"/>
        </parameter>
      </parameters>
    </function>
    <function name="tee_surface_index"
              c:identifier="cairo_tee_surface_index"
              version="1.10">
      <doc xml:space="preserve"
           filename="cairo-tee-surface.c"
           line="583">Retrieves the replica surface at the given index.

The primary surface used to create the #cairo_tee_surface_t is
always set at the zero index.</doc>
      <source-position filename="cairo-tee.h" line="57"/>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve"
             filename="cairo-tee-surface.c"
             line="593">the surface at the given index</doc>
        <type name="Surface" c:type="cairo_surface_t*"/>
      </return-value>
      <parameters>
        <parameter name="abstract_surface" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cairo-tee-surface.c"
               line="585">a #cairo_tee_surface_t</doc>
          <type name="Surface" c:type="cairo_surface_t*"/>
        </parameter>
        <parameter name="index" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cairo-tee-surface.c"
               line="586">the index of the replica to retrieve</doc>
          <type name="guint" c:type="unsigned int"/>
        </parameter>
      </parameters>
    </function>
    <function name="tee_surface_remove"
              c:identifier="cairo_tee_surface_remove"
              version="1.10">
      <doc xml:space="preserve"
           filename="cairo-tee-surface.c"
           line="525">Removes the given surface from the list of replicas of a
tee surface.</doc>
      <source-position filename="cairo-tee.h" line="53"/>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="abstract_surface" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cairo-tee-surface.c"
               line="527">a #cairo_tee_surface_t</doc>
          <type name="Surface" c:type="cairo_surface_t*"/>
        </parameter>
        <parameter name="target" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cairo-tee-surface.c"
               line="528">the surface to remove</doc>
          <type name="Surface" c:type="cairo_surface_t*"/>
        </parameter>
      </parameters>
    </function>
    <function name="text_cluster_allocate"
              c:identifier="cairo_text_cluster_allocate"
              version="1.8">
      <doc xml:space="preserve"
           filename="cairo-misc.c"
           line="235">Allocates an array of #cairo_text_cluster_t's.
This function is only useful in implementations of
#cairo_user_scaled_font_text_to_glyphs_func_t where the user
needs to allocate an array of text clusters that cairo will free.
For all other uses, user can use their own allocation method
for text clusters.

This function returns %NULL if @num_clusters is not positive,
or if out of memory.  That means, the %NULL return value
signals out-of-memory only if @num_clusters was positive.</doc>
      <source-position filename="cairo.h" line="1194"/>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve"
             filename="cairo-misc.c"
             line="250">the newly allocated array of text clusters that should be
         freed using cairo_text_cluster_free()</doc>
        <type name="TextCluster" c:type="cairo_text_cluster_t*"/>
      </return-value>
      <parameters>
        <parameter name="num_clusters" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cairo-misc.c"
               line="237">number of text_clusters to allocate</doc>
          <type name="gint" c:type="int"/>
        </parameter>
      </parameters>
    </function>
    <function name="toy_font_face_create"
              c:identifier="cairo_toy_font_face_create"
              version="1.8">
      <doc xml:space="preserve"
           filename="cairo-toy-font-face.c"
           line="231">Creates a font face from a triplet of family, slant, and weight.
These font faces are used in implementation of the #cairo_t "toy"
font API.

If @family is the zero-length string "", the platform-specific default
family is assumed.  The default family then can be queried using
cairo_toy_font_face_get_family().

The cairo_select_font_face() function uses this to create font faces.
See that function for limitations and other details of toy font faces.</doc>
      <source-position filename="cairo.h" line="1777"/>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve"
             filename="cairo-toy-font-face.c"
             line="248">a newly created #cairo_font_face_t. Free with
 cairo_font_face_destroy() when you are done using it.</doc>
        <type name="FontFace" c:type="cairo_font_face_t*"/>
      </return-value>
      <parameters>
        <parameter name="family" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cairo-toy-font-face.c"
               line="233">a font family name, encoded in UTF-8</doc>
          <type name="utf8" c:type="const char*"/>
        </parameter>
        <parameter name="slant" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cairo-toy-font-face.c"
               line="234">the slant for the font</doc>
          <type name="FontSlant" c:type="cairo_font_slant_t"/>
        </parameter>
        <parameter name="weight" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cairo-toy-font-face.c"
               line="235">the weight for the font</doc>
          <type name="FontWeight" c:type="cairo_font_weight_t"/>
        </parameter>
      </parameters>
    </function>
    <function name="toy_font_face_get_family"
              c:identifier="cairo_toy_font_face_get_family"
              version="1.8">
      <doc xml:space="preserve"
           filename="cairo-toy-font-face.c"
           line="418">Gets the family name of a toy font.</doc>
      <source-position filename="cairo.h" line="1782"/>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve"
             filename="cairo-toy-font-face.c"
             line="424">The family name.  This string is owned by the font face
and remains valid as long as the font face is alive (referenced).</doc>
        <type name="utf8" c:type="const char*"/>
      </return-value>
      <parameters>
        <parameter name="font_face" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cairo-toy-font-face.c"
               line="420">A toy font face</doc>
          <type name="FontFace" c:type="cairo_font_face_t*"/>
        </parameter>
      </parameters>
    </function>
    <function name="toy_font_face_get_slant"
              c:identifier="cairo_toy_font_face_get_slant"
              version="1.8">
      <doc xml:space="preserve"
           filename="cairo-toy-font-face.c"
           line="446">Gets the slant a toy font.</doc>
      <source-position filename="cairo.h" line="1785"/>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve"
             filename="cairo-toy-font-face.c"
             line="452">The slant value</doc>
        <type name="FontSlant" c:type="cairo_font_slant_t"/>
      </return-value>
      <parameters>
        <parameter name="font_face" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cairo-toy-font-face.c"
               line="448">A toy font face</doc>
          <type name="FontFace" c:type="cairo_font_face_t*"/>
        </parameter>
      </parameters>
    </function>
    <function name="toy_font_face_get_weight"
              c:identifier="cairo_toy_font_face_get_weight"
              version="1.8">
      <doc xml:space="preserve"
           filename="cairo-toy-font-face.c"
           line="472">Gets the weight a toy font.</doc>
      <source-position filename="cairo.h" line="1788"/>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve"
             filename="cairo-toy-font-face.c"
             line="478">The weight value</doc>
        <type name="FontWeight" c:type="cairo_font_weight_t"/>
      </return-value>
      <parameters>
        <parameter name="font_face" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cairo-toy-font-face.c"
               line="474">A toy font face</doc>
          <type name="FontFace" c:type="cairo_font_face_t*"/>
        </parameter>
      </parameters>
    </function>
    <function name="user_font_face_create"
              c:identifier="cairo_user_font_face_create"
              version="1.8">
      <doc xml:space="preserve"
           filename="cairo-user-font.c"
           line="699">Creates a new user font-face.

Use the setter functions to associate callbacks with the returned
user font.  The only mandatory callback is render_glyph.

After the font-face is created, the user can attach arbitrary data
(the actual font data) to it using cairo_font_face_set_user_data()
and access it from the user-font callbacks by using
cairo_scaled_font_get_font_face() followed by
cairo_font_face_get_user_data().</doc>
      <source-position filename="cairo.h" line="1794"/>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve"
             filename="cairo-user-font.c"
             line="713">a newly created #cairo_font_face_t. Free with
 cairo_font_face_destroy() when you are done using it.</doc>
        <type name="FontFace" c:type="cairo_font_face_t*"/>
      </return-value>
    </function>
    <function name="user_font_face_get_init_func"
              c:identifier="cairo_user_font_face_get_init_func"
              version="1.8"
              introspectable="0">
      <doc xml:space="preserve"
           filename="cairo-user-font.c"
           line="952">Gets the scaled-font initialization function of a user-font.</doc>
      <source-position filename="cairo.h" line="2046"/>
      <return-value>
        <doc xml:space="preserve"
             filename="cairo-user-font.c"
             line="958">The init callback of @font_face
or %NULL if none set or an error has occurred.</doc>
        <type name="UserScaledFontInitFunc"
              c:type="cairo_user_scaled_font_init_func_t"/>
      </return-value>
      <parameters>
        <parameter name="font_face" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cairo-user-font.c"
               line="954">A user font face</doc>
          <type name="FontFace" c:type="cairo_font_face_t*"/>
        </parameter>
      </parameters>
    </function>
    <function name="user_font_face_get_render_color_glyph_func"
              c:identifier="cairo_user_font_face_get_render_color_glyph_func"
              version="1.18"
              introspectable="0">
      <doc xml:space="preserve"
           filename="cairo-user-font.c"
           line="980">Gets the color glyph rendering function of a user-font.</doc>
      <source-position filename="cairo.h" line="2052"/>
      <return-value>
        <doc xml:space="preserve"
             filename="cairo-user-font.c"
             line="986">The render_glyph callback of @font_face
or %NULL if none set or an error has occurred.</doc>
        <type name="UserScaledFontRenderGlyphFunc"
              c:type="cairo_user_scaled_font_render_glyph_func_t"/>
      </return-value>
      <parameters>
        <parameter name="font_face" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cairo-user-font.c"
               line="982">A user font face</doc>
          <type name="FontFace" c:type="cairo_font_face_t*"/>
        </parameter>
      </parameters>
    </function>
    <function name="user_font_face_get_render_glyph_func"
              c:identifier="cairo_user_font_face_get_render_glyph_func"
              version="1.8"
              introspectable="0">
      <doc xml:space="preserve"
           filename="cairo-user-font.c"
           line="1008">Gets the glyph rendering function of a user-font.</doc>
      <source-position filename="cairo.h" line="2049"/>
      <return-value>
        <doc xml:space="preserve"
             filename="cairo-user-font.c"
             line="1014">The render_glyph callback of @font_face
or %NULL if none set or an error has occurred.</doc>
        <type name="UserScaledFontRenderGlyphFunc"
              c:type="cairo_user_scaled_font_render_glyph_func_t"/>
      </return-value>
      <parameters>
        <parameter name="font_face" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cairo-user-font.c"
               line="1010">A user font face</doc>
          <type name="FontFace" c:type="cairo_font_face_t*"/>
        </parameter>
      </parameters>
    </function>
    <function name="user_font_face_get_text_to_glyphs_func"
              c:identifier="cairo_user_font_face_get_text_to_glyphs_func"
              version="1.8"
              introspectable="0">
      <doc xml:space="preserve"
           filename="cairo-user-font.c"
           line="1036">Gets the text-to-glyphs conversion function of a user-font.</doc>
      <source-position filename="cairo.h" line="2055"/>
      <return-value>
        <doc xml:space="preserve"
             filename="cairo-user-font.c"
             line="1042">The text_to_glyphs callback of @font_face
or %NULL if none set or an error occurred.</doc>
        <type name="UserScaledFontTextToGlyphsFunc"
              c:type="cairo_user_scaled_font_text_to_glyphs_func_t"/>
      </return-value>
      <parameters>
        <parameter name="font_face" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cairo-user-font.c"
               line="1038">A user font face</doc>
          <type name="FontFace" c:type="cairo_font_face_t*"/>
        </parameter>
      </parameters>
    </function>
    <function name="user_font_face_get_unicode_to_glyph_func"
              c:identifier="cairo_user_font_face_get_unicode_to_glyph_func"
              version="1.8"
              introspectable="0">
      <doc xml:space="preserve"
           filename="cairo-user-font.c"
           line="1064">Gets the unicode-to-glyph conversion function of a user-font.</doc>
      <source-position filename="cairo.h" line="2058"/>
      <return-value>
        <doc xml:space="preserve"
             filename="cairo-user-font.c"
             line="1070">The unicode_to_glyph callback of @font_face
or %NULL if none set or an error occurred.</doc>
        <type name="UserScaledFontUnicodeToGlyphFunc"
              c:type="cairo_user_scaled_font_unicode_to_glyph_func_t"/>
      </return-value>
      <parameters>
        <parameter name="font_face" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cairo-user-font.c"
               line="1066">A user font face</doc>
          <type name="FontFace" c:type="cairo_font_face_t*"/>
        </parameter>
      </parameters>
    </function>
    <function name="user_font_face_set_init_func"
              c:identifier="cairo_user_font_face_set_init_func"
              version="1.8"
              introspectable="0">
      <doc xml:space="preserve"
           filename="cairo-user-font.c"
           line="741">Sets the scaled-font initialization function of a user-font.
See #cairo_user_scaled_font_init_func_t for details of how the callback
works.

The font-face should not be immutable or a %CAIRO_STATUS_USER_FONT_IMMUTABLE
error will occur.  A user font-face is immutable as soon as a scaled-font
is created from it.</doc>
      <source-position filename="cairo.h" line="2024"/>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="font_face" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cairo-user-font.c"
               line="743">A user font face</doc>
          <type name="FontFace" c:type="cairo_font_face_t*"/>
        </parameter>
        <parameter name="init_func" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cairo-user-font.c"
               line="744">The init callback, or %NULL</doc>
          <type name="UserScaledFontInitFunc"
                c:type="cairo_user_scaled_font_init_func_t"/>
        </parameter>
      </parameters>
    </function>
    <function name="user_font_face_set_render_color_glyph_func"
              c:identifier="cairo_user_font_face_set_render_color_glyph_func"
              version="1.18"
              introspectable="0">
      <doc xml:space="preserve"
           filename="cairo-user-font.c"
           line="778">Sets the color glyph rendering function of a user-font.
See #cairo_user_scaled_font_render_glyph_func_t for details of how the callback
works.

The font-face should not be immutable or a %CAIRO_STATUS_USER_FONT_IMMUTABLE
error will occur.  A user font-face is immutable as soon as a scaled-font
is created from it.

The render_glyph callback is the only mandatory callback of a
user-font. At least one of
cairo_user_font_face_set_render_color_glyph_func() or
cairo_user_font_face_set_render_glyph_func() must be called to set
a render callback. If both callbacks are set, the color glyph
render callback is invoked first. If the color glyph render
callback returns %CAIRO_STATUS_USER_FONT_NOT_IMPLEMENTED, the
non-color version of the callback is invoked.

If the callback is %NULL and a glyph is tried to be rendered using
@font_face, a %CAIRO_STATUS_USER_FONT_ERROR will occur.</doc>
      <source-position filename="cairo.h" line="2032"/>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="font_face" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cairo-user-font.c"
               line="780">A user font face</doc>
          <type name="FontFace" c:type="cairo_font_face_t*"/>
        </parameter>
        <parameter name="render_glyph_func" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cairo-user-font.c"
               line="781">The render_glyph callback, or %NULL</doc>
          <type name="UserScaledFontRenderGlyphFunc"
                c:type="cairo_user_scaled_font_render_glyph_func_t"/>
        </parameter>
      </parameters>
    </function>
    <function name="user_font_face_set_render_glyph_func"
              c:identifier="cairo_user_font_face_set_render_glyph_func"
              version="1.8"
              introspectable="0">
      <doc xml:space="preserve"
           filename="cairo-user-font.c"
           line="828">Sets the glyph rendering function of a user-font.
See #cairo_user_scaled_font_render_glyph_func_t for details of how the callback
works.

The font-face should not be immutable or a %CAIRO_STATUS_USER_FONT_IMMUTABLE
error will occur.  A user font-face is immutable as soon as a scaled-font
is created from it.

The render_glyph callback is the only mandatory callback of a
user-font. At least one of
cairo_user_font_face_set_render_color_glyph_func() or
cairo_user_font_face_set_render_glyph_func() must be called to set
a render callback. If both callbacks are set, the color glyph
render callback is invoked first. If the color glyph render
callback returns %CAIRO_STATUS_USER_FONT_NOT_IMPLEMENTED, the
non-color version of the callback is invoked.

If the callback is %NULL and a glyph is tried to be rendered using
@font_face, a %CAIRO_STATUS_USER_FONT_ERROR will occur.</doc>
      <source-position filename="cairo.h" line="2028"/>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="font_face" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cairo-user-font.c"
               line="830">A user font face</doc>
          <type name="FontFace" c:type="cairo_font_face_t*"/>
        </parameter>
        <parameter name="render_glyph_func" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cairo-user-font.c"
               line="831">The render_glyph callback, or %NULL</doc>
          <type name="UserScaledFontRenderGlyphFunc"
                c:type="cairo_user_scaled_font_render_glyph_func_t"/>
        </parameter>
      </parameters>
    </function>
    <function name="user_font_face_set_text_to_glyphs_func"
              c:identifier="cairo_user_font_face_set_text_to_glyphs_func"
              version="1.8"
              introspectable="0">
      <doc xml:space="preserve"
           filename="cairo-user-font.c"
           line="877">Sets th text-to-glyphs conversion function of a user-font.
See #cairo_user_scaled_font_text_to_glyphs_func_t for details of how the callback
works.

The font-face should not be immutable or a %CAIRO_STATUS_USER_FONT_IMMUTABLE
error will occur.  A user font-face is immutable as soon as a scaled-font
is created from it.</doc>
      <source-position filename="cairo.h" line="2036"/>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="font_face" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cairo-user-font.c"
               line="879">A user font face</doc>
          <type name="FontFace" c:type="cairo_font_face_t*"/>
        </parameter>
        <parameter name="text_to_glyphs_func" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cairo-user-font.c"
               line="880">The text_to_glyphs callback, or %NULL</doc>
          <type name="UserScaledFontTextToGlyphsFunc"
                c:type="cairo_user_scaled_font_text_to_glyphs_func_t"/>
        </parameter>
      </parameters>
    </function>
    <function name="user_font_face_set_unicode_to_glyph_func"
              c:identifier="cairo_user_font_face_set_unicode_to_glyph_func"
              version="1.8"
              introspectable="0">
      <doc xml:space="preserve"
           filename="cairo-user-font.c"
           line="914">Sets the unicode-to-glyph conversion function of a user-font.
See #cairo_user_scaled_font_unicode_to_glyph_func_t for details of how the callback
works.

The font-face should not be immutable or a %CAIRO_STATUS_USER_FONT_IMMUTABLE
error will occur.  A user font-face is immutable as soon as a scaled-font
is created from it.</doc>
      <source-position filename="cairo.h" line="2040"/>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="font_face" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cairo-user-font.c"
               line="916">A user font face</doc>
          <type name="FontFace" c:type="cairo_font_face_t*"/>
        </parameter>
        <parameter name="unicode_to_glyph_func" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cairo-user-font.c"
               line="917">The unicode_to_glyph callback, or %NULL</doc>
          <type name="UserScaledFontUnicodeToGlyphFunc"
                c:type="cairo_user_scaled_font_unicode_to_glyph_func_t"/>
        </parameter>
      </parameters>
    </function>
    <function name="user_scaled_font_get_foreground_marker"
              c:identifier="cairo_user_scaled_font_get_foreground_marker"
              version="1.18">
      <doc xml:space="preserve"
           filename="cairo-user-font.c"
           line="1092">Gets the foreground pattern of the glyph currently being
rendered. A #cairo_user_scaled_font_render_glyph_func_t function
that has been set with
cairo_user_font_face_set_render_color_glyph_func() may call this
function to retrieve the current foreground pattern for the glyph
being rendered. The function should not be called outside of a
cairo_user_font_face_set_render_color_glyph_func() callback.

The foreground marker pattern contains an internal marker to
indicate that it is to be substituted with the current source when
rendered to a surface. Querying the foreground marker will reveal a
solid black color, however this is not representative of the color
that will actually be used. Similarly, setting a solid black color
will render black, not the foreground pattern when the glyph is
painted to a surface. Using the foreground marker as the source
instead of cairo_user_scaled_font_get_foreground_source() in a
color render callback has the following benefits:

1. Cairo only needs to call the render callback once as it can
cache the recording. Cairo will substitute the actual foreground
color when rendering the recording.

2. On backends that have the concept of a foreground color in fonts such as
PDF, PostScript, and SVG, cairo can generate more optimal
output. The glyph can be included in an embedded font.

The one drawback of the using foreground marker is the render
callback can not access the color components of the pattern as the
actual foreground pattern is not available at the time the render
callback is invoked. If the render callback needs to query the
foreground pattern, use
cairo_user_scaled_font_get_foreground_source().

If the render callback simply wants to call cairo_set_source() with
the foreground pattern,
cairo_user_scaled_font_get_foreground_marker() is the preferred
function to use as it results in better performance than
cairo_user_scaled_font_get_foreground_source().</doc>
      <source-position filename="cairo.h" line="2061"/>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve"
             filename="cairo-user-font.c"
             line="1135">the current foreground source marker pattern. This
object is owned by cairo. This object must not be modified or used
outside of a color render callback. To keep a reference to it,
you must call cairo_pattern_reference().</doc>
        <type name="Pattern" c:type="cairo_pattern_t*"/>
      </return-value>
      <parameters>
        <parameter name="scaled_font" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cairo-user-font.c"
               line="1094">A user scaled font</doc>
          <type name="ScaledFont" c:type="cairo_scaled_font_t*"/>
        </parameter>
      </parameters>
    </function>
    <function name="user_scaled_font_get_foreground_source"
              c:identifier="cairo_user_scaled_font_get_foreground_source"
              version="1.18">
      <doc xml:space="preserve"
           filename="cairo-user-font.c"
           line="1154">Gets the foreground pattern of the glyph currently being
rendered. A #cairo_user_scaled_font_render_glyph_func_t function
that has been set with
cairo_user_font_face_set_render_color_glyph_func() may call this
function to retrieve the current foreground pattern for the glyph
being rendered. The function should not be called outside of a
cairo_user_font_face_set_render_color_glyph_func() callback.

This function returns the current source at the time the glyph is
rendered. Compared with
cairo_user_scaled_font_get_foreground_marker(), this function
returns the actual source pattern that will be used to render the
glyph.  The render callback is free to query the pattern and
extract color components or other pattern data. For example if the
render callback wants to create a gradient stop based on colors in
the foreground source pattern, it will need to use this function in
order to be able to query the colors in the foreground pattern.

While this function does not have the restrictions on using the
pattern that cairo_user_scaled_font_get_foreground_marker() has, it
does incur a performance penalty. If a render callback calls this
function:

1. Cairo will call the render callback whenever the current pattern
of the context in which the glyph is rendered changes.

2. On backends that support font embedding (PDF, PostScript, and
SVG), cairo can not embed this glyph in a font. Instead the glyph
will be emitted as an image or sequence of drawing operations each
time it is used.</doc>
      <source-position filename="cairo.h" line="2064"/>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve"
             filename="cairo-user-font.c"
             line="1189">the current foreground source pattern. This object is
owned by cairo. To keep a reference to it, you must call
cairo_pattern_reference().</doc>
        <type name="Pattern" c:type="cairo_pattern_t*"/>
      </return-value>
      <parameters>
        <parameter name="scaled_font" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cairo-user-font.c"
               line="1156">A user scaled font</doc>
          <type name="ScaledFont" c:type="cairo_scaled_font_t*"/>
        </parameter>
      </parameters>
    </function>
    <function name="version" c:identifier="cairo_version" version="1.0">
      <doc xml:space="preserve"
           filename="cairo-version.c"
           line="210">Returns the version of the cairo library encoded in a single
integer as per %CAIRO_VERSION_ENCODE. The encoding ensures that
later versions compare greater than earlier versions.

A run-time comparison to check that cairo's version is greater than
or equal to version X.Y.Z could be performed as follows:

&lt;informalexample&gt;&lt;programlisting&gt;
if (cairo_version() &gt;= CAIRO_VERSION_ENCODE(X,Y,Z)) {...}
&lt;/programlisting&gt;&lt;/informalexample&gt;

See also cairo_version_string() as well as the compile-time
equivalents %CAIRO_VERSION and %CAIRO_VERSION_STRING.</doc>
      <source-position filename="cairo.h" line="97"/>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve"
             filename="cairo-version.c"
             line="227">the encoded version.</doc>
        <type name="gint" c:type="int"/>
      </return-value>
    </function>
    <function name="version_string"
              c:identifier="cairo_version_string"
              version="1.0">
      <doc xml:space="preserve"
           filename="cairo-version.c"
           line="237">Returns the version of the cairo library as a human-readable string
of the form "X.Y.Z".

See also cairo_version() as well as the compile-time equivalents
%CAIRO_VERSION_STRING and %CAIRO_VERSION.</doc>
      <source-position filename="cairo.h" line="100"/>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve"
             filename="cairo-version.c"
             line="246">a string containing the version.</doc>
        <type name="utf8" c:type="const char*"/>
      </return-value>
    </function>
  </namespace>
</repository>
